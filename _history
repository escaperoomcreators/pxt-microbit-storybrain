{"entries":[{"timestamp":1761689974632,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":312,"diffs":[[1,""]]},{"start1":1,"length1":48579,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":255,"length1":45,"diffs":[[1,"    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1761700358148,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":45574,"length1":113,"diffs":[[1,""]]},{"start1":45613,"length1":0,"diffs":[[1,"    elementType: string;\n"]]},{"start1":45694,"length1":29,"diffs":[[1,""]]},{"start1":45695,"length1":58,"diffs":[[1,"    constructor(name: string, elementType: string) {\n"]]},{"start1":45774,"length1":0,"diffs":[[1,"        this.elementType = elementType;\n"]]},{"start1":45863,"length1":62,"diffs":[[1,""]]},{"start1":45869,"length1":82,"diffs":[[1,""]]},{"start1":46355,"length1":413,"diffs":[[1,"function registerElement(name: string) {\n\n"]]},{"start1":46907,"length1":104,"diffs":[[1,""]]},{"start1":47866,"length1":40,"diffs":[[1,"    // Process a check-in string.\n"]]},{"start1":48000,"length1":161,"diffs":[[1,""]]}]}]},{"timestamp":1761708992982,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":9733,"length1":90,"diffs":[[1,"function lcdDisplayIamge(num: number, name: string, x: number, y: number, size: number) {\n"]]},{"start1":45574,"length1":1399,"diffs":[[1,"const enum RoomElementImage {\n    UNKNOWN = ''\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n"]]},{"start1":45945,"length1":54,"diffs":[[1,"        switch(imageCode) {\n            case null:\n\n        }\n"]]},{"start1":46095,"length1":151,"diffs":[[1,""]]},{"start1":46822,"length1":63,"diffs":[[1,"    if (imageCode === null) {\n        registeredElements.push(new RoomElement(name));\n    } else {\n        registeredElements.push(new RoomElement(name, imageCode));\n    }\n"]]},{"start1":48868,"length1":309,"diffs":[[1,""]]},{"start1":49266,"length1":15,"diffs":[[1,""]]},{"start1":49321,"length1":648,"diffs":[[1,"    // In this loop, add code that keeps the screen updated to show checked-in elements, which flash when they have unchecked messages.\n    // They go green when they check in, but lose the green when they haven't checked in for a while.\n    basic.pause(100);\n    lcdDisplayText('hello', 1, 120, 120, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n"]]},{"start1":49758,"length1":127,"diffs":[[1,""]]}]}]},{"timestamp":1761718122109,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":45574,"length1":2,"diffs":[[1,""]]},{"start1":47529,"length1":1578,"diffs":[[1,""]]},{"start1":47715,"length1":1,"diffs":[[1,""]]},{"start1":47787,"length1":173,"diffs":[[1,"let registeredElements: RoomElement[] = [];\nlet uncheckedStoryMessages: StoryMessage[] = [];\nlet storyMessageReceivedFire: (params: any) => void\n"]]},{"start1":47933,"length1":541,"diffs":[[1,""]]},{"start1":48319,"length1":0,"diffs":[[1,"// A block that sets up the story brain with a room name and radio group unique in the vicinity.\n/*export*/ function initialiseBrain(room: string, radioGroup: number) {\n    initialise(room, radioGroup);\n}\n\n//% block=\"On Story Message Received\"\n/*export*/ function onStoryMessageReceived(codeToFire: () => void): void {\n    storyMessageReceivedFire = codeToFire;\n}\n\n"]]},{"start1":50499,"length1":88,"diffs":[[1,"    uncheckedStoryMessages.push(new StoryMessage(messageParts[1], messageParts[2]));\n"]]},{"start1":50834,"length1":250,"diffs":[[1,""]]},{"start1":50866,"length1":336,"diffs":[[1,"// Test display.\nlcdInitIIC();\nlcdClearAll();\nlcdSetBgcolor(lcdGetRgbColor(0,0,127));\n"]]},{"start1":50967,"length1":22,"diffs":[[1,"    basic.pause(80);\n    lcdDisplayImage(254, '/escape room icon/story_brain.png', 123, 71, 255);\n    lcdDisplayImage(1, '/escape room icon/box_mid.png', 5, 5, 255);\n    lcdDisplayText('box', 3, 5 + 6, 5 + 46 - 2 - 18, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n    lcdDrawLine(100, 5 + 46, 5 + 23, 121, 77, 5, lcdGetRgbColor(0, 255, 0));\n    basic.pause(1000)\n    lcdDeleteWidget(LCDWidgetCategoryTwo.Line, 100);\n    lcdDeleteWidget(LCDWidgetCategoryTwo.Icon, 1);\n    lcdDisplayImage(2, '/escape room icon/box_dark.png', 5, 5+46, 255);\n    lcdDisplayText('box', 4, 5 + 6, 5 + 46 + 46 - 2 - 18, FontSize.Small, lcdGetRgbColor(128, 128, 128));\n    // storyMessageReceivedFire(null)   // This fires the onStoryMessageReceived event:\n"]]},{"start1":51708,"length1":557,"diffs":[[1,""]]},{"start1":51766,"length1":169,"diffs":[[1,""]]},{"start1":51813,"length1":121,"diffs":[[1,"\n"]]},{"start1":51824,"length1":467,"diffs":[[1,""]]},{"start1":51832,"length1":198,"diffs":[[1,""]]}]}]},{"timestamp":1761725822165,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":24,"diffs":[[1,""]]},{"start1":49639,"length1":68,"diffs":[[1,"/*export*/ function initialiseBrain(room: string, radioGroup: number) {\n"]]},{"start1":49748,"length1":38,"diffs":[[1,"//% block=\"On Story Message Received\"\n"]]},{"start1":49940,"length1":132,"diffs":[[1,"/*export*/ function onStoryMessageReceived(handler: (sender: string, message: string) => void) {\n"]]},{"start1":52904,"length1":0,"diffs":[[1,"// Test everything.\ninitialise('Mars', 10);\n"]]},{"start1":53241,"length1":578,"diffs":[[1,"while(true) {\n    basic.pause(100);\n    \n    // If there are new story messages, fire the event with the oldest unchecked message popped.\n    if (uncheckedStoryMessages.length > 0) {\n        // NOTE TO SELF: For some reason, we have to check that the handler is not null before firing it. Right now, it never gets fired...\n        if (storyMessageReceivedHandler != null) {\n            let nextUncheckedMessage = uncheckedStoryMessages.pop();\n            storyMessageReceivedHandler(nextUncheckedMessage.sender, nextUncheckedMessage.message);\n"]]},{"start1":53794,"length1":0,"diffs":[[1,"    }    \n"]]},{"start1":53805,"length1":950,"diffs":[[1,"    // Update elements on screen.\n    for (let i = 0; i < registeredElements.length; i++) {\n        let widgetOrder = (i + 1) * 3;        \n        let path = registeredElements[i].image.getFilePath(false);\n        let textColour = lcdGetRgbColor(255, 255, 255)\n        if (registeredElements[i].isStale()) {\n            path = registeredElements[i].image.getFilePath(true);\n            textColour = lcdGetRgbColor(128, 128, 128)\n"]]},{"start1":54244,"length1":0,"diffs":[[1,"        lcdDisplayImage(widgetOrder + 1, path, getIconXPlacement(i), getIconYPlacement(i), 255);\n        lcdDisplayText(registeredElements[i].name, widgetOrder + 2, getIconXPlacement(i) + 6, getIconYPlacement(i) + 46 - 2 - 18, FontSize.Small, textColour);\n        // TODO: Draw a line if there is an unchecked message from that element.\n        //lcdDrawLine(widgetOrder, getIconXPlacement(i) + 23, getIconYPlacement(i) + 23, 159, 119, 5, lcdGetRgbColor(0, 255, 0));\n"]]},{"start1":54717,"length1":1,"diffs":[[1,""]]},{"start1":54720,"length1":62,"diffs":[[1,""]]},{"start1":54833,"length1":62,"diffs":[[1,"onStoryMessageReceived(function(sender, message) {\n"]]}]}]},{"timestamp":1761775657445,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":49489,"length1":82,"diffs":[[1,"let storyMessageReceivedHandler: (sender: string, message: string) => void;\n"]]},{"start1":49768,"length1":3,"diffs":[[1,""]]},{"start1":50137,"length1":3,"diffs":[[1,""]]},{"start1":53399,"length1":11,"diffs":[[1,""]]},{"start1":53840,"length1":11,"diffs":[[1,""]]},{"start1":54873,"length1":3,"diffs":[[1,""]]},{"start1":55079,"length1":5,"diffs":[[1,"})"]]}]}]},{"timestamp":1761785581216,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":60269,"diffs":[[1,"namespace storybrain {\n\n// --------------------------------------\n// Code from DFRobot lcdDisplay extension\n// --------------------------------------\n// Original code has MIT license and copyright (c) 2021 TgJe.\n// Available at: https://github.com/DFRobot/pxt-DFRobot_lcdDisplay\n// Modified to hide blocks that access display directly.\n\nconst enum LCDWidgetCategoryOne {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n}\n\nconst enum LCDWidgetCategoryTwo {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n    Chart = 6,\n    Text = 7,\n    Line = 8,\n    Rectangle = 9,\n    Circle = 10,\n    Triangle = 11,\n    Icon = 12,\n    Gif = 13,\n}\n\nenum FontSize {\n    Large = 1,\n    Small = 2,\n}\n\nenum RectangleRound {\n    IsRound = 1,\n    NoneRound = 2,\n}\n\nenum ChartStyles {\n    LineChart = 3,\n    BarChart = 2,\n    ShadingLineChart = 1,\n}\n\nenum DrawType {\n    Fill = 1,\n    NotFill = 2,\n}\n\nenum Protocol {\n    IIC = 1,\n    Serial = 2,\n}\n\nconst IIC_MAX_TRANSFER_SIZE = 32;\n\n// cmd len\nconst CMDLEN_OF_HEAD_LEN = 3;\nconst CMD_DELETE_OBJ_LEN = 0x06;\nconst CMD_SET_TOP_OBJ_LEN = 0x06;\nconst CMD_SET_COMPASS_VALUE_LEN = 0x07;\nconst CMD_SET_LEN = 0x07;\nconst CMD_SET_GAUGE_VALUE_LEN = 0x07;\nconst CMD_SET_LINE_METER_VALUE_LEN = 0x07;\nconst CMD_SET_BAR_VALUE_LEN = 0x07;\nconst CMD_SET_SLIDER_VALUE_LEN = 0x07;\nconst CMD_SET_ANGLE_OBJ_LEN = 0x08;\nconst CMD_DRAW_COMPASS_LEN = 0x0B;\nconst CMD_DRAW_CHART_LEN = 0x09;\nconst CMD_DRAW_SERIE_LEN = 0x09;\nconst CMD_OF_DRAW_ICON_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_GIF_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_BAR_LEN = 0x10;\nconst CMD_OF_DRAW_SLIDER_LEN = 0x10;\nconst CMD_DRAW_PIXEL_LEN = 0x11;\nconst CMD_DRAW_LINE_LEN = 0x11;\nconst CMD_OF_DRAW_CIRCLE_LEN = 0x13;\nconst CMD_OF_DRAW_GAUGE_LEN = 0x15;\nconst CMD_OF_DRAW_LINE_METER_LEN = 0x15;\nconst CMD_OF_DRAW_RECT_LEN = 0x16;\nconst CMD_OF_DRAW_TRIANGLE_LEN = 0x19;\n\n// cmd\nconst CMD_SET_BACKGROUND_COLOR = 0x19;\nconst CMD_SET_BACKGROUND_IMG = 0x1A;\nconst CMD_OF_DRAW_PIXEL = 0x02;\nconst CMD_OF_DRAW_LINE = 0x03;\nconst CMD_OF_DRAW_RECT = 0x04;\nconst CMD_OF_DRAW_CIRCLE = 0x06;\nconst CMD_OF_DRAW_TRIANGLE = 0x07;\nconst CMD_OF_DRAW_ICON_INTERNAL = 0x08;\nconst CMD_OF_DRAW_ICON_EXTERNAL = 0x09;\nconst CMD_OF_DRAW_BAR = 0x0A;\nconst CMD_OF_DRAW_BAR_VALUE = 0x0B;\nconst CMD_OF_DRAW_SLIDER = 0x0C;\nconst CMD_OF_DRAW_SLIDER_VALUE = 0x0D;\nconst CMD_OF_DRAW_LINE_METER = 0x10;\nconst CMD_OF_DRAW_LINE_METER_VALUE = 0x11;\nconst CMD_OF_DRAW_COMPASS = 0x0E;\nconst CMD_OF_DRAW_COMPASS_VALUE = 0x0F;\nconst CMD_OF_DRAW_GAUGE = 0x12;\nconst CMD_OF_DRAW_GAUGE_VALUE = 0x13;\nconst CMD_OF_DRAW_LINE_CHART = 0x14;\nconst CMD_OF_DRAW_LINE_CHART_TEXT = 0x15;\nconst CMD_OF_DRAW_SERIE = 0x16;\nconst CMD_OF_DRAW_SERIE_DATA = 0x17;\nconst CMD_OF_DRAW_TEXT = 0x18;\nconst CMD_DELETE_OBJ = 0x1B;\nconst CMD_SET_TOP_OBJ = 0x1C;\nconst CMD_SET_ANGLE_OBJ = 0x1E;\nconst CMD_OF_DRAW_GIF_INTERNAL = 0x1F;\nconst CMD_OF_DRAW_GIF_EXTERNAL = 0x20;\n\nconst CMD_HEADER_HIGH = 0x55;\nconst CMD_HEADER_LOW = 0xaa;\n\nlet address = 0x2c;\nclass GenericNode {\n    id: number\n    next: GenericNode\n    constructor(id: number) {\n        this.id = id;\n        this.next = null;\n    }\n}\n\nclass LinkedList {\n    head: GenericNode\n    size: number\n    id: number\n    constructor() {\n        this.head = null;\n        this.size = 0;\n        this.id = 1;\n    }\n\n    // adds a node to the end of the linked list\n    append() {\n        const newNode = new GenericNode(this.id);\n        if (this.head == null) {\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        this.size++;\n        this.id++;\n    }\n    // insert a node at a specific location\n    insert(index: number, id: number): boolean {\n        if (index < 0 || index > this.size) {\n            return false;\n        }\n        const newNode = new GenericNode(id);\n        if (index == 0) {\n            newNode.next = this.head;\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            newNode.next = current;\n            previous.next = newNode;\n        }\n        this.size++;\n        return true;\n    }\n    // removes a node at a specific location\n    removeAt(index: number): boolean {\n        if (index < 0 || index >= this.size || this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (index == 0) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n\n    // example Remove a node with a specific id\n    removeId(id: number): boolean {\n        if (this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (current.id == id) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            while (current.id != id) {\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n}\n\ntype GenericList = {\n    lineChartHead: LinkedList | null,\n    seriesHead: LinkedList | null,\n    compassHead: LinkedList | null,\n    textHead: LinkedList | null,\n    gaugeHead: LinkedList | null,\n    lineHead: LinkedList | null,\n    rectHead: LinkedList | null,\n    circleHead: LinkedList | null,\n    triangleHead: LinkedList | null,\n    lineMeterHead: LinkedList | null,\n    barHead: LinkedList | null,\n    sliderHead: LinkedList | null,\n    iconHead: LinkedList | null,\n    gifHead: LinkedList | null,\n}\n\nlet list: GenericList = {\n    lineChartHead: null,\n    seriesHead: null,\n    compassHead: null,\n    textHead: null,\n    gaugeHead: null,\n    lineHead: null,\n    rectHead: null,\n    circleHead: null,\n    triangleHead: null,\n    lineMeterHead: null,\n    barHead: null,\n    sliderHead: null,\n    iconHead: null,\n    gifHead: null,\n}\nlet protocol: Protocol = Protocol.IIC;\nlet chartID = 0;\nlet axisListX: string[] = [];\nlet axisListY: string[] = [];\nlet axisYData: number[] = [];\nlet seriesData: any = {};\nlet dataFactor = 1; // \"data coordinate conversion factors\n\n/**\n * Original block \"ColorScreen I2C initialization\"\n */\nfunction lcdInitIIC() {\n    creatList();\n    protocol = Protocol.IIC;\n    basic.pause(1000);\n}\n \n/**\n * Original block \"clear the screen\"\n */\nfunction lcdClearAll() {\n    cleanScreen();\n}\n\n/**\n * Original block \"set the background color %color\"\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdSetBgcolor(color: number) {\n    setBackgroundColor(colorToCustom(color));\n}\n\n/**\n * Original block \"red %red green %green blue %blue\"\n * Convert red, green and blue channels into a RGB color\n * @param red to red ,eg: 255 (min 0, max 255, default 255)\n * @param green to green ,eg: 255 (min 0, max 255, default 255)\n * @param blue to blue ,eg: 255 (min 0, max 255, default 255)\n */\nfunction lcdGetRgbColor(red: number, green: number, blue: number): number {\n    return (red << 16) + (green << 8) + (blue);\n}\n\n/**\n * Original block \"set the background picture %picture\"\n * @param picture to picture ,eg: \"fruit.png\"\n */\nfunction lcdSetBgIamge(picture: string) {\n    //setBackgroundImg(0, picture); // Internal storage of pictures\n    setBackgroundImg(1, picture); // Usb flash drive to store pictures\n}\n\n/**\n * Original block \"display text %text number %num position x: %x y: %y size %size color %color\"\n * @param text to text ,eg: \"hello\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayText(text: string, num: number, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, text, size, color);\n}\n\n/**\n * Original block \"display time number %num time %time position x: %x y: %y size %size color %color\"\n * Was marked as deprecated.\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param time to time ,eg: \"12:40:30\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayTime(num: number, time: string, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, time, size, color);\n}\n\n/**\n * Original block \"hour %hour minutes %min second %sec\"\n * @param hour to hour ,eg: 12 (min 0, max 23, default 12)\n * @param min to min ,eg: 40 (min 0, max 59, default 40)\n * @param sec to sec ,eg: 30 (min 0, max 59, default 30)\n */\nfunction lcdGetTime(hour: number, min: number, sec: number): string {\n    return `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`\n}\n\n/**\n * Original block \"display image number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param name to name ,eg: \"/expression icon/happy.png\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayImage(num: number, name: string, x: number, y: number, size: number) {\n    updateIcon(num, x, y, name, size);\n}\n\n/**\n * Original block \"rotate image number %num angle %angle\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param angle to angle ,eg: 180 (min 0, max 360, default 180)\n */\nfunction lcdRotateIamge(num: number, angle: number) {\n    setAngleIcon(num, angle * 10);\n}\n\n/**\n * Original block \"display gif number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1\n * @param name to name ,eg: \"Snowy.gif\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayGif(num: number, name: string, x: number, y: number, size: number) {\n    updateGif(num, x, y, name, size);\n}\n\n/**\n * Original block \"draw line number %num start x1: %x1 y1: %y1 end x2: %x2 y2: %y2 width %width color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 40 (min 0, max 320, default 40)\n * @param y1 to y1 ,eg: 120 (min 0, max 240, default 120)\n * @param x2 to x2 ,eg: 300 (min 0, max 320, default 300)\n * @param y2 to y2 ,eg: 120 (min 0, max 240, default 120)\n * @param width to width ,eg: 20\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawLine(num: number, x1: number, y1: number, x2: number, y2: number, width: number, color: number) {\n    updateLine(num, x1, y1, x2, y2, width, color);\n}\n\n/**\n * Original block \"draw rectangle number %num start x: %x y: %y width %w height %h line width %width Border color %bocolor %fill color %fcolor %round\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param w to w ,eg: 300 (min 0, max 320, default 300)\n * @param h to h ,eg: 200 (min 0, max 240, default 200)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n * @param round to round ,eg: lcdDisplay.RectangleRound.NoneRound\n */\nfunction lcdDrawRectangle(num: number, x: number, y: number, w: number, h: number, width: number, bocolor: number, fill: DrawType, fcolor: number, round: RectangleRound) {\n    updateRect(num, x, y, w, h, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor, round === RectangleRound.IsRound ? 1 : 0);\n}\n\n/**\n * Original block \"draw circle number %num center x: %x y: %y radius %r line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 160 (min 0, max 320, default 160)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param r to r ,eg: 120 (min 0, max 120, default 120)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawCircle(num: number, x: number, y: number, r: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateCircle(num, x, y, r, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw triangle number %num x1: %x1 y1: %y1 x2: %x2 y2: %y2 x3: %x3 y3: %y3 line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 160 (min 0, max 320, default 160)\n * @param y1 to y1 ,eg: 0 (min 0, max 240, default 0)\n * @param x2 to x2 ,eg: 0 (min 0, max 320, default 0)\n * @param y2 to y2 ,eg: 240 (min 0, max 240, default 240)\n * @param x3 to x3 ,eg: 320 (min 0, max 320, default 320)\n * @param y3 to y3 ,eg: 240 (min 0, max 240, default 240)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawTriangle(num: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateTriangle(num, x1, y1, x2, y2, x3, y3, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw slider number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawSlider(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateSlider(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw bar number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawBar(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateBar(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw compass number %num position x: %x y: %y radius %r\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n */\nfunction lcdDrawCompass(num: number, x: number, y: number, r: number) {\n    updateCompass(num, x, y, r);\n}\n\n/**\n * Original block \"draw gauge number %num position x: %x y: %y radius %r start of scale %start End of scale %end Pointer color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 360 (min 0, max 360, default 360)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawGauge(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateGauge(num, x, y, r, start, end, color, dcolor);\n}\n\n    /**\n     * Original block \"draw lineMeter number %num position x: %x y: %y radius %r start of scale %start End of scale %end Data color %color Dial color %dcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 0 (min 0, max 320, default 0)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     * @param start to start ,eg: 0 (min 0, max 360, default 0)\n     * @param end to end ,eg: 100 (min 0, max 360, default 100)\n     * @param color to color ,eg: 0x000000\n     * @param dcolor to dcolor ,eg: 0xFFFFFF\n     */\nfunction lcdDrawLineMeter(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateLineMeter(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"set %type=LCDWidgetCategoryOne_conv widget number %num data %data\"\n * @param type to type ,eg: LCDWidgetCategoryOne.Slider\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param data to data ,eg: 80\n */\nfunction lcdSetWidgetData(type: number, num: number, data: number) {\n    switch (type) {\n        case LCDWidgetCategoryOne.Slider:\n            setSliderValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Bar:\n            setBarValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Compass:\n            setCompassScale(num, (data / 360) * 3600);\n            break;\n        case LCDWidgetCategoryOne.Gauge:\n            setGaugeValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.LineMeter:\n            setMeterValue(num, data);\n            break;\n        default:\n            break;\n    }\n}\n\n/**\n * Original block \"draw chart number %num X-axis %xaxis Y-axis %yaxis background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan Feb Mar Apr May Jun\"\n * @param yaxis to yaxis ,eg: \"100 80 60 40 20 0\"\n * @param color to color ,eg: 0xFFFFFF\n * @param styles to styles ,eg: ChartStyles.LineChart\n */\nfunction lcdDrawChart(num: number, xaxis: string, yaxis: string, color: number, styles: ChartStyles) {\n    chartID = num;\n    axisListX = xaxis.split(\" \");\n    axisListY = yaxis.split(\" \");\n    axisListX.forEach((value, index) => { axisYData.push(0) });\n    dataFactor = Math.abs((parseInt(axisListY[0]) - parseInt(axisListY[axisListY.length - 1])) / 100);\n    updateChart(chartID, color, styles);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 0, axisListX);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 1, axisListY);\n}\n\n/**\n * Original block \"Set chart data number %num color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdAddChartData(num: number, color: number) {\n    seriesData[num] = axisYData;\n    updateChartSeries(chartID, num, color);\n    addChartSeriesData(chartID, num, seriesData[num], axisListX.length)\n}\n\n/**\n * Original block \"set chart data number %num X-axis %xaxis data %data\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan\"\n * @param data to data ,eg: 80\n */\nfunction lcdSetChartData(num: number, xaxis: string, data: number) {\n    let index = axisListX.indexOf(xaxis);\n    if (data < parseInt(axisListY[axisListY.length - 1]) || data > parseInt(axisListY[0]))\n        return\n    if (index !== -1) {\n        updateChartPoint(chartID, num, index, Math.round((data - parseInt(axisListY[axisListY.length - 1])) / dataFactor));\n        // seriesData[num][index] = Math.round(data / 10);\n    }\n}\n\n/**\n * Original block \"update chart number %num background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0x007FFF\n * @param styles to styles ,eg: lcdDisplay.ChartStyles.BarChart\n */\nfunction lcdUpdateChart(num: number, color: number, styles: ChartStyles) {\n    updateChart(num, color, styles);\n}\n\n/**\n * Original block \"delete %type=LCDWidgetCategoryTwo_conv number %num\"\n * @param type to type ,eg: LCDWidgetCategoryTwo.Text\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n */\nfunction lcdDeleteWidget(type: number, num: number) {\n    switch (type) {\n        case LCDWidgetCategoryTwo.Slider:\n            deleteSlider(num);\n            break;\n        case LCDWidgetCategoryTwo.Bar:\n            deleteBar(num);\n            break;\n        case LCDWidgetCategoryTwo.Compass:\n            deleteCompass(num);\n            break;\n        case LCDWidgetCategoryTwo.Gauge:\n            deleteGauge(num);\n            break;\n        case LCDWidgetCategoryTwo.LineMeter:\n            deleteLineMeter(num);\n            break;\n        case LCDWidgetCategoryTwo.Chart:\n            deleteChart(num);\n            break;\n        case LCDWidgetCategoryTwo.Text:\n            deleteString(num);\n            break;\n        case LCDWidgetCategoryTwo.Line:\n            deleteLine(num);\n            break;\n        case LCDWidgetCategoryTwo.Rectangle:\n            deleteRect(num);\n            break;\n        case LCDWidgetCategoryTwo.Circle:\n            deleteCircle(num);\n            break;\n        case LCDWidgetCategoryTwo.Triangle:\n            deleteTriangle(num);\n            break;\n        case LCDWidgetCategoryTwo.Icon:\n            deleteIcon(num);\n            break;\n        case LCDWidgetCategoryTwo.Gif:\n            deleteGif(num);\n        default:\n            break;\n    }\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryOne_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryOne number\n */\nfunction getWidgetCategoryOne(item: LCDWidgetCategoryOne): number {\n    return item as number;\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryTwo_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryTwo number\n */\nfunction getLCDWidgetCategoryTwo(item: LCDWidgetCategoryTwo): number {\n    return item as number;\n}\n\nfunction cleanScreen() {\n    let cmd = creatCommand(0x1D, 0x04);\n    writeCommand(cmd, 4);\n    basic.pause(1500);\n}\n\nfunction setBackgroundColor(color: number) {\n    let cmd = creatCommand(CMD_SET_BACKGROUND_COLOR, CMD_SET_LEN);\n    cmd = cmd.concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_SET_LEN);\n    basic.pause(300);\n}\n\nfunction setBackgroundImg(location: number, str: string) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_SET_BACKGROUND_IMG, len + 5);\n    cmd = cmd.concat([location]);\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 5);\n}\n\nfunction drawString(x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TEXT), fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction updateString(id: number, x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([id, fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction deleteString(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TEXT, id])\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.textHead, id);\n}\n\nfunction drawLcdTime(x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    drawString(x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction updateLcdTime(id: number, x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    updateString(id, x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction drawIcon(x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_ICON_INTERNAL)]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction setAngleIcon(id: number, angle: number) {\n    let cmd = creatCommand(CMD_SET_ANGLE_OBJ, CMD_SET_ANGLE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]).concat(data16Tobyte(angle));\n    writeCommand(cmd, CMD_SET_ANGLE_OBJ_LEN);\n}\n\nfunction updateIcon(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteIcon(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.iconHead, id);\n}\n\nfunction drawGif(x: number, y: number, str: string, zoom: number): number {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    let id = getID(CMD_OF_DRAW_GIF_EXTERNAL);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n    return id;\n}\n\nfunction updateGif(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteGif(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GIF_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gifHead, id);\n}\n\nfunction drawLine(x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE), width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n}\n\nfunction updateLine(id: number, x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([id, width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n    basic.pause(10);\n}\n\nfunction deleteLine(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineHead, id);\n}\n\nfunction drawRect(x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_RECT), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction updateRect(id: number, x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction deleteRect(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_RECT, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.rectHead, id);\n}\n\nfunction drawCircle(x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_CIRCLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction updateCircle(id: number, x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction deleteCircle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_CIRCLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.circleHead, id);\n}\n\nfunction drawTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TRIANGLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction updateTriangle(id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction deleteTriangle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TRIANGLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.triangleHead, id);\n}\n\nfunction creatSlider(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_SLIDER)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction updateSlider(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction setSliderValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER_VALUE, CMD_SET_SLIDER_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_SLIDER_VALUE_LEN);\n}\n\nfunction deleteSlider(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_SLIDER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.sliderHead, id);\n}\n\nfunction creatBar(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_BAR)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction updateBar(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction setBarValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR_VALUE, CMD_SET_BAR_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_BAR_VALUE_LEN);\n}\n\nfunction deleteBar(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_BAR, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.barHead, id);\n}\n\nfunction creatCompass(x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_COMPASS)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction updateCompass(id: number, x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction setCompassScale(id: number, scale: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS_VALUE, CMD_SET_COMPASS_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(scale));\n    writeCommand(cmd, CMD_SET_COMPASS_VALUE_LEN);\n}\n\nfunction deleteCompass(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_COMPASS, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.compassHead, id);\n}\n\nfunction creatGauge(x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_GAUGE)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction updateGauge(id: number, x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction setGaugeValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE_VALUE, CMD_SET_GAUGE_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_GAUGE_VALUE_LEN);\n}\n\nfunction deleteGauge(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GAUGE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gaugeHead, id);\n}\n\nfunction creatLineMeter(x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE_METER)]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction updateLineMeter(id: number, x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction setTopLineMeter(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n}\n\nfunction deleteLineMeter(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineMeterHead, id);\n}\n\nfunction creatChart(strX: string[], strY: string[], bgColor: number, type: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    let id = getID(CMD_OF_DRAW_LINE_CHART);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n    basic.pause(100);\n    setChartAxisTexts(id, 0, strX);\n    basic.pause(100);\n    setChartAxisTexts(id, 1, strY);\n    return id;\n}\n\nfunction updateChart(id: number, bgColor: number, type: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n}\n\nfunction creatChartSeries(chartId: number, color: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    let serieId = getID(CMD_OF_DRAW_SERIE);\n    cmd = cmd.concat([serieId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n    return serieId;\n}\n\nfunction updateChartSeries(chartId: number, seriesId: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    cmd = cmd.concat([seriesId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n}\n\nfunction setChartAxisTexts(chartId: number, axis: number, text: string[]) {\n    let len = text.length - 1;\n    text.forEach((value, index) => { len = len + value.length });\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART_TEXT, len + 6);\n    cmd = cmd.concat([chartId, axis]);\n    for (let i = 0; i < text.length; i++) {\n        text[i].split(\"\").forEach((value, index) => {\n            cmd.push(value.charCodeAt(0))\n        })\n        if (i != text.length - 1) {\n            cmd.push(0x0A); // \"\\n\"\n        }\n    }\n    writeCommand(cmd, len + 6);\n}\n\nfunction updateChartPoint(chartId: number, seriesId: number, pointNum: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, 10);\n    cmd = cmd.concat([chartId, seriesId, 1, pointNum]).concat(data16Tobyte(value));\n    writeCommand(cmd, 10);\n}\n\nfunction addChartSeriesData(chartId: number, seriesId: number, point: number[], len: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, len * 2 + 8);\n    cmd = cmd.concat([chartId, seriesId, 0, 0]);\n    point.forEach((value, index) => { cmd = cmd.concat(data16Tobyte(value)) });\n    writeCommand(cmd, len * 2 + 8);\n    return 1;\n}\n\nfunction setTopChart(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_SET_TOP_OBJ_LEN);\n}\n\nfunction deleteChart(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineChartHead, id);\n}\n\nfunction setMeterValue(lineMeterId: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER_VALUE, CMD_SET_LINE_METER_VALUE_LEN);\n    cmd = cmd.concat([lineMeterId]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_LINE_METER_VALUE_LEN);\n}\n\n/********************************************************************************************************************/\nfunction creatList() {\n    list.lineChartHead = new LinkedList();\n    list.seriesHead = new LinkedList();\n    list.compassHead = new LinkedList();\n    list.textHead = new LinkedList();\n    list.gaugeHead = new LinkedList();\n    list.lineHead = new LinkedList();\n    list.rectHead = new LinkedList();\n    list.circleHead = new LinkedList();\n    list.triangleHead = new LinkedList();\n    list.lineMeterHead = new LinkedList();\n    list.barHead = new LinkedList();\n    list.sliderHead = new LinkedList();\n    list.iconHead = new LinkedList();\n    list.gifHead = new LinkedList();\n}\n\nfunction getID(type: number): number {\n    let id = 0;\n    switch (type) {\n        case CMD_OF_DRAW_LINE_CHART:\n            id = getNewID(list.lineChartHead);\n            break;\n        case CMD_OF_DRAW_SERIE:\n            id = getNewID(list.seriesHead);\n            break;\n        case CMD_OF_DRAW_COMPASS:\n            id = getNewID(list.compassHead);\n            break;\n        case CMD_OF_DRAW_TEXT:\n            id = getNewID(list.textHead);\n            break;\n        case CMD_OF_DRAW_GAUGE:\n            id = getNewID(list.gaugeHead);\n            break;\n        case CMD_OF_DRAW_LINE:\n            id = getNewID(list.lineHead);\n            break;\n        case CMD_OF_DRAW_RECT:\n            id = getNewID(list.rectHead);\n            break;\n        case CMD_OF_DRAW_TRIANGLE:\n            id = getNewID(list.triangleHead);\n            break;\n        case CMD_OF_DRAW_CIRCLE:\n            id = getNewID(list.circleHead);\n            break;\n        case CMD_OF_DRAW_LINE_METER:\n            id = getNewID(list.lineMeterHead);\n            break;\n        case CMD_OF_DRAW_BAR:\n            id = getNewID(list.barHead);\n            break;\n        case CMD_OF_DRAW_SLIDER:\n            id = getNewID(list.sliderHead);\n            break;\n        case CMD_OF_DRAW_ICON_INTERNAL:\n            id = getNewID(list.iconHead);\n            break;\n        case CMD_OF_DRAW_GIF_INTERNAL:\n            id = getNewID(list.gifHead);\n            break;\n        default:\n            break;\n    }\n    return id;\n}\n\nfunction getNewID(linkList: LinkedList): number {\n    linkList.append();\n    return linkList.head.id;\n}\n\nfunction deleteNodeByID(linkList: LinkedList, id: number) {\n    linkList.removeId(id);\n}\n\nfunction data16Tobyte(data: number): number[] {\n    return [(data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction data24Tobyte(data: number): number[] {\n    return [(data >> 16) & 0xFF, (data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction colorToCustom(color: number): number {\n    switch (color) {\n        case 0x999999:\n            return 0x696969;\n        case 0x7f00ff:\n            return 0x800080;\n        default:\n            return color;\n    }\n}\n\nfunction creatCommand(cmd: number, len: number): number[] {\n    return [CMD_HEADER_HIGH, CMD_HEADER_LOW, len - CMDLEN_OF_HEAD_LEN, cmd];\n}\n\nfunction writeCommand(data: number[], len: number) {\n    // serial.writeNumbers(data);\n    if (protocol == Protocol.IIC) {\n        let remain = len;\n        let i = 0;\n        while (remain > 0) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? 32 : remain;\n            if (remain > IIC_MAX_TRANSFER_SIZE) {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), true);\n            } else {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), false);\n            }\n            remain = remain - currentTransferSize;\n            i = i + 1;\n        }\n    } else {\n     }\n}\n\nfunction readACK(length: number): Buffer {\n    if (protocol == Protocol.IIC) {\n        let remain = length;\n        let buf: Buffer = pins.createBuffer(0);\n        while (remain) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? IIC_MAX_TRANSFER_SIZE : remain;\n            buf = buf.concat(pins.i2cReadBuffer(address, currentTransferSize));\n            remain = remain - currentTransferSize;\n        }\n        return buf;\n    } else {\n        let buf: Buffer = pins.createBuffer(0);\n        return buf;\n    }\n}\n\n// --------------------------------------\n// End of code from DFRobot lcdDisplay extension\n// --------------------------------------\n\n\n\nconst ROOM_ELEMENT_IMAGE_CODE_UNKNOWN = 'UNKNOWN';\nconst ROOM_ELEMENT_IMAGE_FILENAME_UNKNOWN = 'unknown';\nconst ROOM_ELEMENT_IMAGE_CODE_BOX = 'BOX';\nconst ROOM_ELEMENT_IMAGE_FILENAME_BOX = 'box';\nconst ROOM_ELEMENT_IMAGE_CODE_LIGHTS = 'LIGHTS';\nconst ROOM_ELEMENT_IMAGE_FILENAME_LIGHTS = 'lights';\n\n/**\n * Information about an image for an escape room element.\n */\nclass RoomElementImage {\n    code: string;\n    private _filename: string;\n\n    /**\n     * Constructs the image using \n     */\n    constructor(code: string = null) {\n        if (code === null) {\n            this.code = ROOM_ELEMENT_IMAGE_CODE_UNKNOWN;\n        } else {\n            this.code = code;\n        }\n        switch(code.toUpperCase()) {\n            case ROOM_ELEMENT_IMAGE_CODE_BOX:\n                this._filename = ROOM_ELEMENT_IMAGE_FILENAME_BOX;\n                break;\n            case ROOM_ELEMENT_IMAGE_CODE_LIGHTS:\n                this._filename = ROOM_ELEMENT_IMAGE_FILENAME_LIGHTS;\n                break;\n            case ROOM_ELEMENT_IMAGE_CODE_UNKNOWN:\n            default:\n                this._filename = ROOM_ELEMENT_IMAGE_FILENAME_UNKNOWN;\n        }\n    }\n\n    public getFilePath(stale: boolean = false) {\n        if (stale) {\n            return \"/escape room icon/\" + this._filename + \"_dark.png\";\n        } else {\n            return \"/escape room icon/\" + this._filename + \"_mid.png\";\n        }\n        \n    }\n}\n\nclass RoomElement {\n    name: string;\n    lastCheckInTime: number;  // Millis since power on.\n    image: RoomElementImage;\n\n    constructor(name: string, imageCode: string = null) {\n        this.name = name;\n        this.lastCheckInTime = control.millis();\n        this.image = new RoomElementImage(imageCode);\n    }\n\n    updateCheckInTime() {\n        this.lastCheckInTime = control.millis();\n    }\n\n    isStale(): boolean {\n        if (control.millis() - this.lastCheckInTime > 8000) {\n            return true;\n        }\n        return false;\n    }\n}\n\nfunction getIconXPlacement(elementOrder: number) {\n    switch(elementOrder) {\n        case 0: return 2;           \n        case 1: return 2;\n        case 2: return 2;\n        case 3: return 2;\n        case 4: return 2;\n        case 5: return 2 + 45 * 1;\n        case 6: return 2 + 45 * 2;\n        case 7: return 2 + 45 * 3;\n        case 8: return 2 + 45 * 4;\n        case 9: return 2 + 45 * 5;\n        case 10: return 2 + 45 * 6;\n        case 11: return 2 + 45 * 6;\n        case 12: return 2 + 45 * 6;\n        case 13: return 2 + 45 * 6;\n        case 14: return 2 + 45 * 6;\n        case 15: return 2 + 45 * 5;\n        case 16: return 2 + 45 * 4;\n        case 17: return 2 + 45 * 3;\n        case 18: return 2 + 45 * 2;\n        case 19: return 2 + 45 * 1;\n        default: return 0;\n    }\n}\n\nfunction getIconYPlacement(elementOrder: number) {\n    switch (elementOrder) {\n        case 0: return 2;\n        case 1: return 2 + 47;\n        case 2: return 2 + 47 * 2;\n        case 3: return 2 + 47 * 3;\n        case 4: return 2 + 47 * 4;\n        case 5: return 2 + 47 * 4;\n        case 6: return 2 + 47 * 4;\n        case 7: return 2 + 47 * 4;\n        case 8: return 2 + 47 * 4;\n        case 9: return 2 + 47 * 4;\n        case 10: return 2 + 47 * 4;\n        case 11: return 2 + 47 * 3;\n        case 12: return 2 + 47 * 2;\n        case 13: return 2 + 47 * 1;\n        case 14: return 2 + 47;\n        case 15: return 2 + 47;\n        case 16: return 2 + 47;\n        case 17: return 2 + 47;\n        case 18: return 2 + 47;\n        case 19: return 2 + 47;\n        default: return 0;\n    }\n}\n\nclass StoryMessage {\n    sender: string;\n    message: string; \n\n    constructor(sender: string, message: string) {\n        this.sender = sender;\n        this.message = message;\n    }\n}\n\n\nlet roomName: string = 'UNNAMED'\nlet brainInitialized: boolean = false;\nconst registeredElements: RoomElement[] = [];\nconst uncheckedStoryMessages: StoryMessage[] = [];\n/* let storyMessageReceivedHandler: (sender: string, message: string) => void; */\n\n// A block that sets up the story brain with a room name and radio group unique in the vicinity.\nexport function initialiseBrain(room: string, radioGroup: number) {\n    initialise(room, radioGroup);\n}\n\n/*\n//% block=\"on story message received\"\n//% draggableParameters=\"reporter\"\n// NOTE TO SELF: This is supposed to set up the event block for when a new processed message is available to the user.\nexport function onStoryMessageReceived(handler: (sender: string, message: string) => void) {\n    //basic.showIcon(IconNames.Heart);\n    storyMessageReceivedHandler = handler;\n}\n*/\n\n// Ensures that an element is kept up to date in the registeredElements array.\nfunction registerElement(name: string, imageCode: string = null) {\n    for (let element of registeredElements) {\n        if (element.name.toUpperCase() === name) {\n            element.updateCheckInTime();\n            return;\n        }\n    }\n    registeredElements.push(new RoomElement(name, imageCode));\n}\n\n// Capture and process all radio messages coming in as strings.\n/*\n/ Check-in messages are formatted as follows:   [room name]*[element name]\n/ Check-in messages can also be formatted to give an image:   [room name]*[element name]*I*[image code]\n/ Trigger messages are formatted as follows:   [room name]*[element name]*[message]\n/\n/ room name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all escape rooms in the vicinity.\n/ element name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all elements in this escape room.\n/ message is a string of no more than 9 characters. Asterisk not allowed.\n/\n/ Case is always ignored when comparing, so names and IDs must be unique ignoring case.\n*/\nradio.onReceivedString(function(receivedString: string) {\n    if (!brainInitialized) {\n        return;\n    }    \n    \n    let messageParts: string[] = receivedString.split('*');\n    \n    // If the received string could not be split, ignore it.\n    if (messageParts.length <= 1) {\n        return;\n    }\n    // If the room name doesn't match, ignore it.\n    if (messageParts[0].toUpperCase() != roomName.toUpperCase()) {\n        return;\n    }\n    // Process a basic check-in string.\n    if (messageParts.length == 2) {\n        registerElement(messageParts[1]);\n        return;\n    }\n    // Process an advanced check-in string.\n    if (messageParts.length == 4) {\n        registerElement(messageParts[1], messageParts[3]);\n        return;\n    }\n    registerElement(messageParts[1]);\n    // Process a true story message, but ignore if there is already an unchecked message from that element.\n    for (let message of uncheckedStoryMessages) {\n        if (message.sender.toUpperCase() == messageParts[1].toUpperCase()) {\n            return;\n        }\n    }\n    uncheckedStoryMessages.unshift(new StoryMessage(messageParts[1], messageParts[2]));\n});\n\n// Sets up the story brain with a room name and radio group unique in the vicinity.\n// Must be called before other functions will work.\nfunction initialise(room: string, radioGroup: number) {\n    roomName = room;\n    radio.setGroup(radioGroup);\n    lcdInitIIC();\n    lcdClearAll();\n    lcdSetBgcolor(lcdGetRgbColor(0, 0, 0));\n    lcdDisplayImage(250, '/escape room icon/story_brain.png', 123, 71, 255);\n    lcdDisplayText(roomName, 251, 123, 143, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n    brainInitialized = true;\n}\n\nregisterElement('box1', 'BOX');\nregisterElement('box2', 'BOX');\nregisterElement('box3', 'BOX');\nuncheckedStoryMessages.unshift(new StoryMessage('box1', 'hello'));\nuncheckedStoryMessages.unshift(new StoryMessage('box2', 'yo'));\nuncheckedStoryMessages.unshift(new StoryMessage('box3', 'hi!'));\n\n    while (true) {\n        basic.pause(100);\n\n        // If there are new story messages, fire the event with the oldest unchecked message popped.\n        /*\n        if (uncheckedStoryMessages.length > 0) {\n            // NOTE TO SELF: For some reason, we have to check that the handler is not null before firing it. Right now, it never gets fired...\n            if (storyMessageReceivedHandler) {\n                let nextUncheckedMessage = uncheckedStoryMessages.pop();\n                storyMessageReceivedHandler(nextUncheckedMessage.sender, nextUncheckedMessage.message);\n            }\n        }\n        */\n\n        // Update elements on screen.\n        for (let i = 0; i < registeredElements.length; i++) {\n            let widgetOrder = (i + 1) * 3;\n            let path = registeredElements[i].image.getFilePath(false);\n            let textColour = lcdGetRgbColor(255, 255, 255)\n            if (registeredElements[i].isStale()) {\n                path = registeredElements[i].image.getFilePath(true);\n                textColour = lcdGetRgbColor(128, 128, 128)\n            }\n            lcdDisplayImage(widgetOrder + 1, path, getIconXPlacement(i), getIconYPlacement(i), 255);\n            lcdDisplayText(registeredElements[i].name, widgetOrder + 2, getIconXPlacement(i) + 6, getIconYPlacement(i) + 46 - 2 - 18, FontSize.Small, textColour);\n            // TODO: Draw a line if there is an unchecked message from that element.\n            //lcdDrawLine(widgetOrder, getIconXPlacement(i) + 23, getIconYPlacement(i) + 23, 159, 119, 5, lcdGetRgbColor(0, 255, 0));\n        }\n    }\n\n}\n\n// Test everything.\nstorybrain.initialiseBrain('Mars', 10);\n\n\n/*\n// NOTE TO SELF: This is just testing the function/block made above. This wouldn't be included in the extension.\nstorybrain.onStoryMessageReceived(function(sender, message) {\n    basic.showString(message);\n})\n*/"]]}]}]},{"timestamp":1761793869463,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":50213,"length1":175,"diffs":[[1,"    const ROOM_ELEMENT_IMAGE_CODE_UNKNOWN = 'UNKNOWN';\n    const ROOM_ELEMENT_IMAGE_FILENAME_UNKNOWN = 'unknown';\n    const ROOM_ELEMENT_IMAGE_CODE_BOX = 'BOX';\n    const ROOM_ELEMENT_IMAGE_FILENAME_BOX = 'box';\n    const ROOM_ELEMENT_IMAGE_CODE_LIGHTS = 'LIGHTS';\n    const ROOM_ELEMENT_IMAGE_FILENAME_LIGHTS = 'lights';\n"]]},{"start1":50970,"length1":54,"diffs":[[1,"            switch (code.toUpperCase()) {\n                case ROOM_ELEMENT_IMAGE_CODE_BOX:\n                    this._filename = ROOM_ELEMENT_IMAGE_FILENAME_BOX;\n                    break;\n                case ROOM_ELEMENT_IMAGE_CODE_LIGHTS:\n                    this._filename = ROOM_ELEMENT_IMAGE_FILENAME_LIGHTS;\n                    break;\n                case ROOM_ELEMENT_IMAGE_CODE_UNKNOWN:\n                default:\n                    this._filename = ROOM_ELEMENT_IMAGE_FILENAME_UNKNOWN;\n            }\n"]]}]}]},{"timestamp":1761801175938,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":58463,"diffs":[[1,"    // --------------------------------------\n    // Code from DFRobot lcdDisplay extension\n    // --------------------------------------\n    // Original code has MIT license and copyright (c) 2021 TgJe.\n    // Available at: https://github.com/DFRobot/pxt-DFRobot_lcdDisplay\n    // Modified to hide blocks that access display directly.\n\n    const enum LCDWidgetCategoryOne {\n        Slider = 1,\n        Bar = 2,\n        Compass = 3,\n        Gauge = 4,\n        LineMeter = 5,\n    }\n\n    const enum LCDWidgetCategoryTwo {\n        Slider = 1,\n        Bar = 2,\n        Compass = 3,\n        Gauge = 4,\n        LineMeter = 5,\n        Chart = 6,\n        Text = 7,\n        Line = 8,\n        Rectangle = 9,\n        Circle = 10,\n        Triangle = 11,\n        Icon = 12,\n        Gif = 13,\n    }\n\n    enum FontSize {\n        Large = 1,\n        Small = 2,\n    }\n\n    enum RectangleRound {\n        IsRound = 1,\n        NoneRound = 2,\n    }\n\n    enum ChartStyles {\n        LineChart = 3,\n        BarChart = 2,\n        ShadingLineChart = 1,\n    }\n\n    enum DrawType {\n        Fill = 1,\n        NotFill = 2,\n    }\n\n    enum Protocol {\n        IIC = 1,\n        Serial = 2,\n    }\n\n    const IIC_MAX_TRANSFER_SIZE = 32;\n\n    // cmd len\n    const CMDLEN_OF_HEAD_LEN = 3;\n    const CMD_DELETE_OBJ_LEN = 0x06;\n    const CMD_SET_TOP_OBJ_LEN = 0x06;\n    const CMD_SET_COMPASS_VALUE_LEN = 0x07;\n    const CMD_SET_LEN = 0x07;\n    const CMD_SET_GAUGE_VALUE_LEN = 0x07;\n    const CMD_SET_LINE_METER_VALUE_LEN = 0x07;\n    const CMD_SET_BAR_VALUE_LEN = 0x07;\n    const CMD_SET_SLIDER_VALUE_LEN = 0x07;\n    const CMD_SET_ANGLE_OBJ_LEN = 0x08;\n    const CMD_DRAW_COMPASS_LEN = 0x0B;\n    const CMD_DRAW_CHART_LEN = 0x09;\n    const CMD_DRAW_SERIE_LEN = 0x09;\n    const CMD_OF_DRAW_ICON_INTERNAL_LEN = 0x0D;\n    const CMD_OF_DRAW_GIF_INTERNAL_LEN = 0x0D;\n    const CMD_OF_DRAW_BAR_LEN = 0x10;\n    const CMD_OF_DRAW_SLIDER_LEN = 0x10;\n    const CMD_DRAW_PIXEL_LEN = 0x11;\n    const CMD_DRAW_LINE_LEN = 0x11;\n    const CMD_OF_DRAW_CIRCLE_LEN = 0x13;\n    const CMD_OF_DRAW_GAUGE_LEN = 0x15;\n    const CMD_OF_DRAW_LINE_METER_LEN = 0x15;\n    const CMD_OF_DRAW_RECT_LEN = 0x16;\n    const CMD_OF_DRAW_TRIANGLE_LEN = 0x19;\n\n    // cmd\n    const CMD_SET_BACKGROUND_COLOR = 0x19;\n    const CMD_SET_BACKGROUND_IMG = 0x1A;\n    const CMD_OF_DRAW_PIXEL = 0x02;\n    const CMD_OF_DRAW_LINE = 0x03;\n    const CMD_OF_DRAW_RECT = 0x04;\n    const CMD_OF_DRAW_CIRCLE = 0x06;\n    const CMD_OF_DRAW_TRIANGLE = 0x07;\n    const CMD_OF_DRAW_ICON_INTERNAL = 0x08;\n    const CMD_OF_DRAW_ICON_EXTERNAL = 0x09;\n    const CMD_OF_DRAW_BAR = 0x0A;\n    const CMD_OF_DRAW_BAR_VALUE = 0x0B;\n    const CMD_OF_DRAW_SLIDER = 0x0C;\n    const CMD_OF_DRAW_SLIDER_VALUE = 0x0D;\n    const CMD_OF_DRAW_LINE_METER = 0x10;\n    const CMD_OF_DRAW_LINE_METER_VALUE = 0x11;\n    const CMD_OF_DRAW_COMPASS = 0x0E;\n    const CMD_OF_DRAW_COMPASS_VALUE = 0x0F;\n    const CMD_OF_DRAW_GAUGE = 0x12;\n    const CMD_OF_DRAW_GAUGE_VALUE = 0x13;\n    const CMD_OF_DRAW_LINE_CHART = 0x14;\n    const CMD_OF_DRAW_LINE_CHART_TEXT = 0x15;\n    const CMD_OF_DRAW_SERIE = 0x16;\n    const CMD_OF_DRAW_SERIE_DATA = 0x17;\n    const CMD_OF_DRAW_TEXT = 0x18;\n    const CMD_DELETE_OBJ = 0x1B;\n    const CMD_SET_TOP_OBJ = 0x1C;\n    const CMD_SET_ANGLE_OBJ = 0x1E;\n    const CMD_OF_DRAW_GIF_INTERNAL = 0x1F;\n    const CMD_OF_DRAW_GIF_EXTERNAL = 0x20;\n\n    const CMD_HEADER_HIGH = 0x55;\n    const CMD_HEADER_LOW = 0xaa;\n\n    let address = 0x2c;\n    class GenericNode {\n        id: number\n        next: GenericNode\n        constructor(id: number) {\n            this.id = id;\n            this.next = null;\n        }\n    }\n\n    class LinkedList {\n        head: GenericNode\n        size: number\n        id: number\n        constructor() {\n            this.head = null;\n            this.size = 0;\n            this.id = 1;\n        }\n\n        // adds a node to the end of the linked list\n        append() {\n            const newNode = new GenericNode(this.id);\n            if (this.head == null) {\n                this.head = newNode;\n            } else {\n                let current = this.head;\n                while (current.next != null) {\n                    current = current.next;\n                }\n                current.next = newNode;\n            }\n            this.size++;\n            this.id++;\n        }\n        // insert a node at a specific location\n        insert(index: number, id: number): boolean {\n            if (index < 0 || index > this.size) {\n                return false;\n            }\n            const newNode = new GenericNode(id);\n            if (index == 0) {\n                newNode.next = this.head;\n                this.head = newNode;\n            } else {\n                let current = this.head;\n                let previous = null;\n                let i = 0;\n                while (i < index) {\n                    previous = current;\n                    current = current.next;\n                    i++;\n                }\n                newNode.next = current;\n                previous.next = newNode;\n            }\n            this.size++;\n            return true;\n        }\n        // removes a node at a specific location\n        removeAt(index: number): boolean {\n            if (index < 0 || index >= this.size || this.head == null) {\n                return false;\n            }\n            let current = this.head;\n            if (index == 0) {\n                this.head = current.next;\n            } else {\n                let previous = null;\n                let i = 0;\n                while (i < index) {\n                    previous = current;\n                    current = current.next;\n                    i++;\n                }\n                previous.next = current.next;\n            }\n            this.size--;\n            return true;\n        }\n\n        // example Remove a node with a specific id\n        removeId(id: number): boolean {\n            if (this.head == null) {\n                return false;\n            }\n            let current = this.head;\n            if (current.id == id) {\n                this.head = current.next;\n            } else {\n                let previous = null;\n                while (current.id != id) {\n                    previous = current;\n                    current = current.next;\n                }\n                previous.next = current.next;\n            }\n            this.size--;\n            return true;\n        }\n    }\n\n    type GenericList = {\n        lineChartHead: LinkedList | null,\n        seriesHead: LinkedList | null,\n        compassHead: LinkedList | null,\n        textHead: LinkedList | null,\n        gaugeHead: LinkedList | null,\n        lineHead: LinkedList | null,\n        rectHead: LinkedList | null,\n        circleHead: LinkedList | null,\n        triangleHead: LinkedList | null,\n        lineMeterHead: LinkedList | null,\n        barHead: LinkedList | null,\n        sliderHead: LinkedList | null,\n        iconHead: LinkedList | null,\n        gifHead: LinkedList | null,\n    }\n\n    let list: GenericList = {\n        lineChartHead: null,\n        seriesHead: null,\n        compassHead: null,\n        textHead: null,\n        gaugeHead: null,\n        lineHead: null,\n        rectHead: null,\n        circleHead: null,\n        triangleHead: null,\n        lineMeterHead: null,\n        barHead: null,\n        sliderHead: null,\n        iconHead: null,\n        gifHead: null,\n    }\n    let protocol: Protocol = Protocol.IIC;\n    let chartID = 0;\n    let axisListX: string[] = [];\n    let axisListY: string[] = [];\n    let axisYData: number[] = [];\n    let seriesData: any = {};\n    let dataFactor = 1; // \"data coordinate conversion factors\n\n    /**\n     * Original block \"ColorScreen I2C initialization\"\n     */\n    function lcdInitIIC() {\n        creatList();\n        protocol = Protocol.IIC;\n        basic.pause(1000);\n    }\n\n    /**\n     * Original block \"clear the screen\"\n     */\n    function lcdClearAll() {\n        cleanScreen();\n    }\n\n    /**\n     * Original block \"set the background color %color\"\n     * @param color to color ,eg: 0xFF0000\n     */\n    function lcdSetBgcolor(color: number) {\n        setBackgroundColor(colorToCustom(color));\n    }\n\n    /**\n     * Original block \"red %red green %green blue %blue\"\n     * Convert red, green and blue channels into a RGB color\n     * @param red to red ,eg: 255 (min 0, max 255, default 255)\n     * @param green to green ,eg: 255 (min 0, max 255, default 255)\n     * @param blue to blue ,eg: 255 (min 0, max 255, default 255)\n     */\n    function lcdGetRgbColor(red: number, green: number, blue: number): number {\n        return (red << 16) + (green << 8) + (blue);\n    }\n\n    /**\n     * Original block \"set the background picture %picture\"\n     * @param picture to picture ,eg: \"fruit.png\"\n     */\n    function lcdSetBgIamge(picture: string) {\n        //setBackgroundImg(0, picture); // Internal storage of pictures\n        setBackgroundImg(1, picture); // Usb flash drive to store pictures\n    }\n\n    /**\n     * Original block \"display text %text number %num position x: %x y: %y size %size color %color\"\n     * @param text to text ,eg: \"hello\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 120 (min 0, max 320, default 120)\n     * @param y to y ,eg: 120 (min 0, max 240, default 120)\n     * @param size to size ,eg: FontSize.Large\n     * @param color to color ,eg: 0xFF0000\n     */\n    function lcdDisplayText(text: string, num: number, x: number, y: number, size: FontSize, color: number) {\n        updateString(num, x, y, text, size, color);\n    }\n\n    /**\n     * Original block \"display time number %num time %time position x: %x y: %y size %size color %color\"\n     * Was marked as deprecated.\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param time to time ,eg: \"12:40:30\"\n     * @param x to x ,eg: 120 (min 0, max 320, default 120)\n     * @param y to y ,eg: 120 (min 0, max 320, default 120)\n     * @param size to size ,eg: FontSize.Large\n     * @param color to color ,eg: 0xFF0000\n     */\n    function lcdDisplayTime(num: number, time: string, x: number, y: number, size: FontSize, color: number) {\n        updateString(num, x, y, time, size, color);\n    }\n\n    /**\n     * Original block \"hour %hour minutes %min second %sec\"\n     * @param hour to hour ,eg: 12 (min 0, max 23, default 12)\n     * @param min to min ,eg: 40 (min 0, max 59, default 40)\n     * @param sec to sec ,eg: 30 (min 0, max 59, default 30)\n     */\n    function lcdGetTime(hour: number, min: number, sec: number): string {\n        return `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`\n    }\n\n    /**\n     * Original block \"display image number %num name %name position x: %x y: %y size %size\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param name to name ,eg: \"/expression icon/happy.png\"\n     * @param x to x ,eg: 120 (min 0, max 320, default 120)\n     * @param y to y ,eg: 120 (min 0, max 320, default 120)\n     * @param size to size ,eg: FontSize.Large\n     */\n    function lcdDisplayImage(num: number, name: string, x: number, y: number, size: number) {\n        updateIcon(num, x, y, name, size);\n    }\n\n    /**\n     * Original block \"rotate image number %num angle %angle\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param angle to angle ,eg: 180 (min 0, max 360, default 180)\n     */\n    function lcdRotateIamge(num: number, angle: number) {\n        setAngleIcon(num, angle * 10);\n    }\n\n    /**\n     * Original block \"display gif number %num name %name position x: %x y: %y size %size\"\n     * @param num to num ,eg: 1\n     * @param name to name ,eg: \"Snowy.gif\"\n     * @param x to x ,eg: 120 (min 0, max 320, default 120)\n     * @param y to y ,eg: 120 (min 0, max 320, default 120)\n     * @param size to size ,eg: FontSize.Large\n     */\n    function lcdDisplayGif(num: number, name: string, x: number, y: number, size: number) {\n        updateGif(num, x, y, name, size);\n    }\n\n    /**\n     * Original block \"draw line number %num start x1: %x1 y1: %y1 end x2: %x2 y2: %y2 width %width color %color\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x1 to x1 ,eg: 40 (min 0, max 320, default 40)\n     * @param y1 to y1 ,eg: 120 (min 0, max 240, default 120)\n     * @param x2 to x2 ,eg: 300 (min 0, max 320, default 300)\n     * @param y2 to y2 ,eg: 120 (min 0, max 240, default 120)\n     * @param width to width ,eg: 20\n     * @param color to color ,eg: 0x007FFF\n     */\n    function lcdDrawLine(num: number, x1: number, y1: number, x2: number, y2: number, width: number, color: number) {\n        updateLine(num, x1, y1, x2, y2, width, color);\n    }\n\n    /**\n     * Original block \"draw rectangle number %num start x: %x y: %y width %w height %h line width %width Border color %bocolor %fill color %fcolor %round\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 0 (min 0, max 320, default 0)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param w to w ,eg: 300 (min 0, max 320, default 300)\n     * @param h to h ,eg: 200 (min 0, max 240, default 200)\n     * @param width to width ,eg: 5\n     * @param bocolor to bocolor ,eg: 0xFF0000\n     * @param fill to fill ,eg: DrawType.Fill\n     * @param fcolor to fcolor ,eg: 0xFFFFFF\n     * @param round to round ,eg: lcdDisplay.RectangleRound.NoneRound\n     */\n    function lcdDrawRectangle(num: number, x: number, y: number, w: number, h: number, width: number, bocolor: number, fill: DrawType, fcolor: number, round: RectangleRound) {\n        updateRect(num, x, y, w, h, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor, round === RectangleRound.IsRound ? 1 : 0);\n    }\n\n    /**\n     * Original block \"draw circle number %num center x: %x y: %y radius %r line width %width Border color %bocolor %fill color %fcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 160 (min 0, max 320, default 160)\n     * @param y to y ,eg: 120 (min 0, max 240, default 120)\n     * @param r to r ,eg: 120 (min 0, max 120, default 120)\n     * @param width to width ,eg: 5\n     * @param bocolor to bocolor ,eg: 0xFF0000\n     * @param fill to fill ,eg: DrawType.Fill\n     * @param fcolor to fcolor ,eg: 0xFFFFFF\n     */\n    function lcdDrawCircle(num: number, x: number, y: number, r: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n        updateCircle(num, x, y, r, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n    }\n\n    /**\n     * Original block \"draw triangle number %num x1: %x1 y1: %y1 x2: %x2 y2: %y2 x3: %x3 y3: %y3 line width %width Border color %bocolor %fill color %fcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x1 to x1 ,eg: 160 (min 0, max 320, default 160)\n     * @param y1 to y1 ,eg: 0 (min 0, max 240, default 0)\n     * @param x2 to x2 ,eg: 0 (min 0, max 320, default 0)\n     * @param y2 to y2 ,eg: 240 (min 0, max 240, default 240)\n     * @param x3 to x3 ,eg: 320 (min 0, max 320, default 320)\n     * @param y3 to y3 ,eg: 240 (min 0, max 240, default 240)\n     * @param width to width ,eg: 5\n     * @param bocolor to bocolor ,eg: 0xFF0000\n     * @param fill to fill ,eg: DrawType.Fill\n     * @param fcolor to fcolor ,eg: 0xFFFFFF\n     */\n    function lcdDrawTriangle(num: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n        updateTriangle(num, x1, y1, x2, y2, x3, y3, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n    }\n\n    /**\n     * Original block \"draw slider number %num position x: %x y: %y width %w height %h color %color\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 80 (min 0, max 320, default 80)\n     * @param y to y ,eg: 120 (min 0, max 240, default 120)\n     * @param w to w ,eg: 200 (min 0, max 320, default 200)\n     * @param h to h ,eg: 20 (min 0, max 240, default 20)\n     * @param color to color ,eg: 0x007FFF\n     */\n    function lcdDrawSlider(num: number, x: number, y: number, w: number, h: number, color: number) {\n        updateSlider(num, x, y, w, h, color);\n    }\n\n    /**\n     * Original block \"draw bar number %num position x: %x y: %y width %w height %h color %color\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 80 (min 0, max 320, default 80)\n     * @param y to y ,eg: 120 (min 0, max 240, default 120)\n     * @param w to w ,eg: 200 (min 0, max 320, default 200)\n     * @param h to h ,eg: 20 (min 0, max 240, default 20)\n     * @param color to color ,eg: 0x007FFF\n     */\n    function lcdDrawBar(num: number, x: number, y: number, w: number, h: number, color: number) {\n        updateBar(num, x, y, w, h, color);\n    }\n\n    /**\n     * Original block \"draw compass number %num position x: %x y: %y radius %r\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 50 (min 0, max 320, default 50)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     */\n    function lcdDrawCompass(num: number, x: number, y: number, r: number) {\n        updateCompass(num, x, y, r);\n    }\n\n    /**\n     * Original block \"draw gauge number %num position x: %x y: %y radius %r start of scale %start End of scale %end Pointer color %color Dial color %dcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 50 (min 0, max 320, default 50)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     * @param start to start ,eg: 0 (min 0, max 360, default 0)\n     * @param end to end ,eg: 360 (min 0, max 360, default 360)\n     * @param color to color ,eg: 0x000000\n     * @param dcolor to dcolor ,eg: 0xFFFFFF\n     */\n    function lcdDrawGauge(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n        updateGauge(num, x, y, r, start, end, color, dcolor);\n    }\n\n    /**\n     * Original block \"draw lineMeter number %num position x: %x y: %y radius %r start of scale %start End of scale %end Data color %color Dial color %dcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 0 (min 0, max 320, default 0)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     * @param start to start ,eg: 0 (min 0, max 360, default 0)\n     * @param end to end ,eg: 100 (min 0, max 360, default 100)\n     * @param color to color ,eg: 0x000000\n     * @param dcolor to dcolor ,eg: 0xFFFFFF\n     */\n    function lcdDrawLineMeter(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n        updateLineMeter(num, x, y, r, start, end, color, dcolor);\n    }\n\n    /**\n     * Original block \"set %type=LCDWidgetCategoryOne_conv widget number %num data %data\"\n     * @param type to type ,eg: LCDWidgetCategoryOne.Slider\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param data to data ,eg: 80\n     */\n    function lcdSetWidgetData(type: number, num: number, data: number) {\n        switch (type) {\n            case LCDWidgetCategoryOne.Slider:\n                setSliderValue(num, data);\n                break;\n            case LCDWidgetCategoryOne.Bar:\n                setBarValue(num, data);\n                break;\n            case LCDWidgetCategoryOne.Compass:\n                setCompassScale(num, (data / 360) * 3600);\n                break;\n            case LCDWidgetCategoryOne.Gauge:\n                setGaugeValue(num, data);\n                break;\n            case LCDWidgetCategoryOne.LineMeter:\n                setMeterValue(num, data);\n                break;\n            default:\n                break;\n        }\n    }\n\n    /**\n     * Original block \"draw chart number %num X-axis %xaxis Y-axis %yaxis background color %color styles %styles\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param xaxis to xaxis ,eg: \"Jan Feb Mar Apr May Jun\"\n     * @param yaxis to yaxis ,eg: \"100 80 60 40 20 0\"\n     * @param color to color ,eg: 0xFFFFFF\n     * @param styles to styles ,eg: ChartStyles.LineChart\n     */\n    function lcdDrawChart(num: number, xaxis: string, yaxis: string, color: number, styles: ChartStyles) {\n        chartID = num;\n        axisListX = xaxis.split(\" \");\n        axisListY = yaxis.split(\" \");\n        axisListX.forEach((value, index) => { axisYData.push(0) });\n        dataFactor = Math.abs((parseInt(axisListY[0]) - parseInt(axisListY[axisListY.length - 1])) / 100);\n        updateChart(chartID, color, styles);\n        basic.pause(100);\n        setChartAxisTexts(chartID, 0, axisListX);\n        basic.pause(100);\n        setChartAxisTexts(chartID, 1, axisListY);\n    }\n\n    /**\n     * Original block \"Set chart data number %num color %color\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param color to color ,eg: 0xFF0000\n     */\n    function lcdAddChartData(num: number, color: number) {\n        seriesData[num] = axisYData;\n        updateChartSeries(chartID, num, color);\n        addChartSeriesData(chartID, num, seriesData[num], axisListX.length)\n    }\n\n    /**\n     * Original block \"set chart data number %num X-axis %xaxis data %data\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param xaxis to xaxis ,eg: \"Jan\"\n     * @param data to data ,eg: 80\n     */\n    function lcdSetChartData(num: number, xaxis: string, data: number) {\n        let index = axisListX.indexOf(xaxis);\n        if (data < parseInt(axisListY[axisListY.length - 1]) || data > parseInt(axisListY[0]))\n            return\n        if (index !== -1) {\n            updateChartPoint(chartID, num, index, Math.round((data - parseInt(axisListY[axisListY.length - 1])) / dataFactor));\n            // seriesData[num][index] = Math.round(data / 10);\n        }\n    }\n\n    /**\n     * Original block \"update chart number %num background color %color styles %styles\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param color to color ,eg: 0x007FFF\n     * @param styles to styles ,eg: lcdDisplay.ChartStyles.BarChart\n     */\n    function lcdUpdateChart(num: number, color: number, styles: ChartStyles) {\n        updateChart(num, color, styles);\n    }\n\n    /**\n     * Original block \"delete %type=LCDWidgetCategoryTwo_conv number %num\"\n     * @param type to type ,eg: LCDWidgetCategoryTwo.Text\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     */\n    function lcdDeleteWidget(type: number, num: number) {\n        switch (type) {\n            case LCDWidgetCategoryTwo.Slider:\n                deleteSlider(num);\n                break;\n            case LCDWidgetCategoryTwo.Bar:\n                deleteBar(num);\n                break;\n            case LCDWidgetCategoryTwo.Compass:\n                deleteCompass(num);\n                break;\n            case LCDWidgetCategoryTwo.Gauge:\n                deleteGauge(num);\n                break;\n            case LCDWidgetCategoryTwo.LineMeter:\n                deleteLineMeter(num);\n                break;\n            case LCDWidgetCategoryTwo.Chart:\n                deleteChart(num);\n                break;\n            case LCDWidgetCategoryTwo.Text:\n                deleteString(num);\n                break;\n            case LCDWidgetCategoryTwo.Line:\n                deleteLine(num);\n                break;\n            case LCDWidgetCategoryTwo.Rectangle:\n                deleteRect(num);\n                break;\n            case LCDWidgetCategoryTwo.Circle:\n                deleteCircle(num);\n                break;\n            case LCDWidgetCategoryTwo.Triangle:\n                deleteTriangle(num);\n                break;\n            case LCDWidgetCategoryTwo.Icon:\n                deleteIcon(num);\n                break;\n            case LCDWidgetCategoryTwo.Gif:\n                deleteGif(num);\n            default:\n                break;\n        }\n    }\n\n    /**\n     * Original blockId \"LCDWidgetCategoryOne_conv\" and block \"%item\"\n     * return the corresponding LCDWidgetCategoryOne number\n     */\n    function getWidgetCategoryOne(item: LCDWidgetCategoryOne): number {\n        return item as number;\n    }\n\n    /**\n     * Original blockId \"LCDWidgetCategoryTwo_conv\" and block \"%item\"\n     * return the corresponding LCDWidgetCategoryTwo number\n     */\n    function getLCDWidgetCategoryTwo(item: LCDWidgetCategoryTwo): number {\n        return item as number;\n    }\n\n    function cleanScreen() {\n        let cmd = creatCommand(0x1D, 0x04);\n        writeCommand(cmd, 4);\n        basic.pause(1500);\n    }\n\n    function setBackgroundColor(color: number) {\n        let cmd = creatCommand(CMD_SET_BACKGROUND_COLOR, CMD_SET_LEN);\n        cmd = cmd.concat(data24Tobyte(color));\n        writeCommand(cmd, CMD_SET_LEN);\n        basic.pause(300);\n    }\n\n    function setBackgroundImg(location: number, str: string) {\n        let len = str.length;\n        let cmd = creatCommand(CMD_SET_BACKGROUND_IMG, len + 5);\n        cmd = cmd.concat([location]);\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 5);\n    }\n\n    function drawString(x: number, y: number, str: string, fontSize: number, color: number) {\n        let len = str.length > 242 ? 242 : str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_TEXT), fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 13);\n    }\n\n    function updateString(id: number, x: number, y: number, str: string, fontSize: number, color: number) {\n        let len = str.length > 242 ? 242 : str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n        cmd = cmd.concat([id, fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 13);\n    }\n\n    function deleteString(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_TEXT, id])\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.textHead, id);\n    }\n\n    function drawLcdTime(x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n        drawString(x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n    }\n\n    function updateLcdTime(id: number, x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n        updateString(id, x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n    }\n\n    function drawIcon(x: number, y: number, str: string, zoom: number) {\n        let len = str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_ICON_INTERNAL)]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 11);\n    }\n\n    function setAngleIcon(id: number, angle: number) {\n        let cmd = creatCommand(CMD_SET_ANGLE_OBJ, CMD_SET_ANGLE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]).concat(data16Tobyte(angle));\n        writeCommand(cmd, CMD_SET_ANGLE_OBJ_LEN);\n    }\n\n    function updateIcon(id: number, x: number, y: number, str: string, zoom: number) {\n        let len = str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n        cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 11);\n    }\n\n    function deleteIcon(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.iconHead, id);\n    }\n\n    function drawGif(x: number, y: number, str: string, zoom: number): number {\n        let len = str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n        let id = getID(CMD_OF_DRAW_GIF_EXTERNAL);\n        cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 11);\n        return id;\n    }\n\n    function updateGif(id: number, x: number, y: number, str: string, zoom: number) {\n        let len = str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n        cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 11);\n    }\n\n    function deleteGif(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_GIF_INTERNAL, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.gifHead, id);\n    }\n\n    function drawLine(x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_LINE), width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n        writeCommand(cmd, CMD_DRAW_LINE_LEN);\n    }\n\n    function updateLine(id: number, x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n        cmd = cmd.concat([id, width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n        writeCommand(cmd, CMD_DRAW_LINE_LEN);\n        basic.pause(10);\n    }\n\n    function deleteLine(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.lineHead, id);\n    }\n\n    function drawRect(x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_RECT), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n    }\n\n    function updateRect(id: number, x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n        cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n    }\n\n    function deleteRect(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_RECT, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.rectHead, id);\n    }\n\n    function drawCircle(x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_CIRCLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n    }\n\n    function updateCircle(id: number, x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n        cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n    }\n\n    function deleteCircle(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_CIRCLE, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.circleHead, id);\n    }\n\n    function drawTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_TRIANGLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n        writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n    }\n\n    function updateTriangle(id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n        cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n        writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n    }\n\n    function deleteTriangle(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_TRIANGLE, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.triangleHead, id);\n    }\n\n    function creatSlider(x: number, y: number, w: number, h: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_SLIDER)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n    }\n\n    function updateSlider(id: number, x: number, y: number, w: number, h: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n        cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n    }\n\n    function setSliderValue(id: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SLIDER_VALUE, CMD_SET_SLIDER_VALUE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(value));\n        writeCommand(cmd, CMD_SET_SLIDER_VALUE_LEN);\n    }\n\n    function deleteSlider(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_SLIDER, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.sliderHead, id);\n    }\n\n    function creatBar(x: number, y: number, w: number, h: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_BAR)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n    }\n\n    function updateBar(id: number, x: number, y: number, w: number, h: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n        cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n    }\n\n    function setBarValue(id: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_BAR_VALUE, CMD_SET_BAR_VALUE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(value));\n        writeCommand(cmd, CMD_SET_BAR_VALUE_LEN);\n    }\n\n    function deleteBar(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_BAR, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.barHead, id);\n    }\n\n    function creatCompass(x: number, y: number, diameter: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_COMPASS)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n    }\n\n    function updateCompass(id: number, x: number, y: number, diameter: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n    }\n\n    function setCompassScale(id: number, scale: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_COMPASS_VALUE, CMD_SET_COMPASS_VALUE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(scale));\n        writeCommand(cmd, CMD_SET_COMPASS_VALUE_LEN);\n    }\n\n    function deleteCompass(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_COMPASS, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.compassHead, id);\n    }\n\n    function creatGauge(x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_GAUGE)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n    }\n\n    function updateGauge(id: number, x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n    }\n\n    function setGaugeValue(id: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_GAUGE_VALUE, CMD_SET_GAUGE_VALUE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(value));\n        writeCommand(cmd, CMD_SET_GAUGE_VALUE_LEN);\n    }\n\n    function deleteGauge(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_GAUGE, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.gaugeHead, id);\n    }\n\n    function creatLineMeter(x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_LINE_METER)]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n    }\n\n    function updateLineMeter(id: number, x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n    }\n\n    function setTopLineMeter(id: number) {\n        let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    }\n\n    function deleteLineMeter(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.lineMeterHead, id);\n    }\n\n    function creatChart(strX: string[], strY: string[], bgColor: number, type: number): number {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n        let id = getID(CMD_OF_DRAW_LINE_CHART);\n        cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n        writeCommand(cmd, CMD_DRAW_CHART_LEN);\n        basic.pause(100);\n        setChartAxisTexts(id, 0, strX);\n        basic.pause(100);\n        setChartAxisTexts(id, 1, strY);\n        return id;\n    }\n\n    function updateChart(id: number, bgColor: number, type: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n        cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n        writeCommand(cmd, CMD_DRAW_CHART_LEN);\n    }\n\n    function creatChartSeries(chartId: number, color: number): number {\n        let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n        let serieId = getID(CMD_OF_DRAW_SERIE);\n        cmd = cmd.concat([serieId, chartId]).concat(data24Tobyte(color));\n        writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n        return serieId;\n    }\n\n    function updateChartSeries(chartId: number, seriesId: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n        cmd = cmd.concat([seriesId, chartId]).concat(data24Tobyte(color));\n        writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n    }\n\n    function setChartAxisTexts(chartId: number, axis: number, text: string[]) {\n        let len = text.length - 1;\n        text.forEach((value, index) => { len = len + value.length });\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART_TEXT, len + 6);\n        cmd = cmd.concat([chartId, axis]);\n        for (let i = 0; i < text.length; i++) {\n            text[i].split(\"\").forEach((value, index) => {\n                cmd.push(value.charCodeAt(0))\n            })\n            if (i != text.length - 1) {\n                cmd.push(0x0A); // \"\\n\"\n            }\n        }\n        writeCommand(cmd, len + 6);\n    }\n\n    function updateChartPoint(chartId: number, seriesId: number, pointNum: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, 10);\n        cmd = cmd.concat([chartId, seriesId, 1, pointNum]).concat(data16Tobyte(value));\n        writeCommand(cmd, 10);\n    }\n\n    function addChartSeriesData(chartId: number, seriesId: number, point: number[], len: number): number {\n        let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, len * 2 + 8);\n        cmd = cmd.concat([chartId, seriesId, 0, 0]);\n        point.forEach((value, index) => { cmd = cmd.concat(data16Tobyte(value)) });\n        writeCommand(cmd, len * 2 + 8);\n        return 1;\n    }\n\n    function setTopChart(id: number) {\n        let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n        writeCommand(cmd, CMD_SET_TOP_OBJ_LEN);\n    }\n\n    function deleteChart(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.lineChartHead, id);\n    }\n\n    function setMeterValue(lineMeterId: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_METER_VALUE, CMD_SET_LINE_METER_VALUE_LEN);\n        cmd = cmd.concat([lineMeterId]).concat(data16Tobyte(value));\n        writeCommand(cmd, CMD_SET_LINE_METER_VALUE_LEN);\n    }\n\n    /********************************************************************************************************************/\n    function creatList() {\n        list.lineChartHead = new LinkedList();\n        list.seriesHead = new LinkedList();\n        list.compassHead = new LinkedList();\n        list.textHead = new LinkedList();\n        list.gaugeHead = new LinkedList();\n        list.lineHead = new LinkedList();\n        list.rectHead = new LinkedList();\n        list.circleHead = new LinkedList();\n        list.triangleHead = new LinkedList();\n        list.lineMeterHead = new LinkedList();\n        list.barHead = new LinkedList();\n        list.sliderHead = new LinkedList();\n        list.iconHead = new LinkedList();\n        list.gifHead = new LinkedList();\n    }\n\n    function getID(type: number): number {\n        let id = 0;\n        switch (type) {\n            case CMD_OF_DRAW_LINE_CHART:\n                id = getNewID(list.lineChartHead);\n                break;\n            case CMD_OF_DRAW_SERIE:\n                id = getNewID(list.seriesHead);\n                break;\n            case CMD_OF_DRAW_COMPASS:\n                id = getNewID(list.compassHead);\n                break;\n            case CMD_OF_DRAW_TEXT:\n                id = getNewID(list.textHead);\n                break;\n            case CMD_OF_DRAW_GAUGE:\n                id = getNewID(list.gaugeHead);\n                break;\n            case CMD_OF_DRAW_LINE:\n                id = getNewID(list.lineHead);\n                break;\n            case CMD_OF_DRAW_RECT:\n                id = getNewID(list.rectHead);\n                break;\n            case CMD_OF_DRAW_TRIANGLE:\n                id = getNewID(list.triangleHead);\n                break;\n            case CMD_OF_DRAW_CIRCLE:\n                id = getNewID(list.circleHead);\n                break;\n            case CMD_OF_DRAW_LINE_METER:\n                id = getNewID(list.lineMeterHead);\n                break;\n            case CMD_OF_DRAW_BAR:\n                id = getNewID(list.barHead);\n                break;\n            case CMD_OF_DRAW_SLIDER:\n                id = getNewID(list.sliderHead);\n                break;\n            case CMD_OF_DRAW_ICON_INTERNAL:\n                id = getNewID(list.iconHead);\n                break;\n            case CMD_OF_DRAW_GIF_INTERNAL:\n                id = getNewID(list.gifHead);\n                break;\n            default:\n                break;\n        }\n        return id;\n    }\n\n    function getNewID(linkList: LinkedList): number {\n        linkList.append();\n        return linkList.head.id;\n    }\n\n    function deleteNodeByID(linkList: LinkedList, id: number) {\n        linkList.removeId(id);\n    }\n\n    function data16Tobyte(data: number): number[] {\n        return [(data >> 8) & 0xFF, data & 0xFF];\n    }\n\n    function data24Tobyte(data: number): number[] {\n        return [(data >> 16) & 0xFF, (data >> 8) & 0xFF, data & 0xFF];\n    }\n\n    function colorToCustom(color: number): number {\n        switch (color) {\n            case 0x999999:\n                return 0x696969;\n            case 0x7f00ff:\n                return 0x800080;\n            default:\n                return color;\n        }\n    }\n\n    function creatCommand(cmd: number, len: number): number[] {\n        return [CMD_HEADER_HIGH, CMD_HEADER_LOW, len - CMDLEN_OF_HEAD_LEN, cmd];\n    }\n\n    function writeCommand(data: number[], len: number) {\n        // serial.writeNumbers(data);\n        if (protocol == Protocol.IIC) {\n            let remain = len;\n            let i = 0;\n            while (remain > 0) {\n                let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? 32 : remain;\n                if (remain > IIC_MAX_TRANSFER_SIZE) {\n                    pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), true);\n                } else {\n                    pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), false);\n                }\n                remain = remain - currentTransferSize;\n                i = i + 1;\n            }\n        } else {\n        }\n    }\n\n    function readACK(length: number): Buffer {\n        if (protocol == Protocol.IIC) {\n            let remain = length;\n            let buf: Buffer = pins.createBuffer(0);\n            while (remain) {\n                let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? IIC_MAX_TRANSFER_SIZE : remain;\n                buf = buf.concat(pins.i2cReadBuffer(address, currentTransferSize));\n                remain = remain - currentTransferSize;\n            }\n            return buf;\n        } else {\n            let buf: Buffer = pins.createBuffer(0);\n            return buf;\n        }\n    }\n\n    // --------------------------------------\n    // End of code from DFRobot lcdDisplay extension\n    // --------------------------------------\n\n\n//% blockNamespace=storybrain\nclass StoryMessage {\n    _sender: string;\n    _message: string;\n\n    constructor(sender: string, message: string) {\n        this._sender = sender;\n        this._message = message;\n    }\n\n    //% blockCombine\n    get text() { return this._message }\n\n    //% blockCombine\n    get sender() { return this._sender }\n}\n\n//% color=\"#AA278D\"\nnamespace storybrain {\n\n    const ROOM_ELEMENT_IMAGE_CODE_UNKNOWN: string = 'DEF';\n    const ROOM_ELEMENT_IMAGE_CODE_BOX: string = 'BOX';\n    const ROOM_ELEMENT_IMAGE_CODE_LIGHTS: string = 'LIGHTS';\n\n    /**\n     * Information about an image for an escape room element.\n     */\n    class RoomElementImage {\n        code: string;\n        private _filename: string;\n\n        /**\n         * Constructs the image using \n         */\n        constructor(code: string = null) {\n            if (code === null) {\n                this.code = ROOM_ELEMENT_IMAGE_CODE_UNKNOWN;\n            } else {\n                this.code = code;\n            }\n            this._filename = this.code.toLowerCase();\n        }\n\n        public getFilePath(stale: boolean = false) {\n            if (stale) {\n                return \"/escape room icon/\" + this._filename + \"_dark.png\";\n            } else {\n                return \"/escape room icon/\" + this._filename + \"_mid.png\";\n            }\n\n        }\n    }\n\n    class RoomElement {\n        name: string;\n        lastCheckInTime: number;  // Millis since power on.\n        image: RoomElementImage;\n\n        constructor(name: string, imageCode: string = null) {\n            this.name = name;\n            this.lastCheckInTime = control.millis();\n            this.image = new RoomElementImage(imageCode);\n        }\n\n        updateCheckInTime() {\n            this.lastCheckInTime = control.millis();\n        }\n\n        isStale(): boolean {\n            if (control.millis() - this.lastCheckInTime > 8000) {\n                return true;\n            }\n            return false;\n        }\n    }\n\n    function getIconXPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2;\n            case 2: return 2;\n            case 3: return 2;\n            case 4: return 2;\n            case 5: return 2 + 45 * 1;\n            case 6: return 2 + 45 * 2;\n            case 7: return 2 + 45 * 3;\n            case 8: return 2 + 45 * 4;\n            case 9: return 2 + 45 * 5;\n            case 10: return 2 + 45 * 6;\n            case 11: return 2 + 45 * 6;\n            case 12: return 2 + 45 * 6;\n            case 13: return 2 + 45 * 6;\n            case 14: return 2 + 45 * 6;\n            case 15: return 2 + 45 * 5;\n            case 16: return 2 + 45 * 4;\n            case 17: return 2 + 45 * 3;\n            case 18: return 2 + 45 * 2;\n            case 19: return 2 + 45 * 1;\n            default: return 0;\n        }\n    }\n\n    function getIconYPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2 + 47;\n            case 2: return 2 + 47 * 2;\n            case 3: return 2 + 47 * 3;\n            case 4: return 2 + 47 * 4;\n            case 5: return 2 + 47 * 4;\n            case 6: return 2 + 47 * 4;\n            case 7: return 2 + 47 * 4;\n            case 8: return 2 + 47 * 4;\n            case 9: return 2 + 47 * 4;\n            case 10: return 2 + 47 * 4;\n            case 11: return 2 + 47 * 3;\n            case 12: return 2 + 47 * 2;\n            case 13: return 2 + 47 * 1;\n            case 14: return 2 + 47;\n            case 15: return 2 + 47;\n            case 16: return 2 + 47;\n            case 17: return 2 + 47;\n            case 18: return 2 + 47;\n            case 19: return 2 + 47;\n            default: return 0;\n        }\n    }\n\n    let roomName: string = 'UNNAMED'\n    let brainInitialized: boolean = false;\n    const registeredElements: RoomElement[] = [];\n    const uncheckedStoryMessages: StoryMessage[] = [];\n\n    /**\n     * Set up the story brain for the escape room.\n     * @param room the unique name for the room (use a maximum of 4 regular letters)\n     * @param radioGroup the radio group for the room, unique in the vicinity\n    */\n    //% block=\"initialise brain with room name $room and radio group $radioGroup\"\n    //% weight=100\n    //% room.defl=\"room\"\n    //% radioGroup.min=0 radioGroup.max=255 radioGroup.defl=20\n    export function initialiseBrain(room: string, radioGroup: number) {\n        initialise(room, radioGroup);\n    }\n\n    /**\n     * Returns true if there any unchecked messages available to grab.\n    */\n    //% block=\"unchecked messages available\"\n    //% weight=52\n    export function uncheckedMessagesAvailable(): boolean {\n        return (uncheckedStoryMessages.length > 0);\n    }\n\n    /**\n     * Grab the next unchecked message, removing it from the inbox.\n    */\n    //% block=\"grab next unchecked message\"\n    //% weight=51\n    //% blockSetVariable=storymessage\n    export function grabNextUncheckedMessage(): StoryMessage {\n        if (uncheckedStoryMessages.length > 0) {\n            return uncheckedStoryMessages.pop();\n        }\n        return new StoryMessage('no message', 'no message');\n    }\n\n    // Ensures that an element is kept up to date in the registeredElements array.\n    function registerElement(name: string, imageCode: string = null) {\n        for (let element of registeredElements) {\n            if (element.name.toUpperCase() === name) {\n                element.updateCheckInTime();\n                return;\n            }\n        }\n        registeredElements.push(new RoomElement(name, imageCode));\n    }\n\n    // Capture and process all radio messages coming in as strings.\n    /*\n    / Check-in messages are formatted as follows:   [room name]*[element name]\n    / Check-in messages can also be formatted to give an image:   [room name]*[element name]*I*[image code]\n    / Trigger messages are formatted as follows:   [room name]*[element name]*[message]\n    /\n    / room name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all escape rooms in the vicinity.\n    / element name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all elements in this escape room.\n    / message is a string of no more than 9 characters. Asterisk not allowed.\n    /\n    / Case is always ignored when comparing, so names and IDs must be unique ignoring case.\n    */\n    radio.onReceivedString(function (receivedString: string) {\n        if (!brainInitialized) {\n            return;\n        }\n\n        let messageParts: string[] = receivedString.split('*');\n\n        // If the received string could not be split, ignore it.\n        if (messageParts.length <= 1) {\n            return;\n        }\n        // If the room name doesn't match, ignore it.\n        if (messageParts[0].toUpperCase() != roomName.toUpperCase()) {\n            return;\n        }\n        // Process a basic check-in string.\n        if (messageParts.length == 2) {\n            registerElement(messageParts[1]);\n            return;\n        }\n        // Process an advanced check-in string.\n        if (messageParts.length == 4) {\n            registerElement(messageParts[1], messageParts[3]);\n            return;\n        }\n        registerElement(messageParts[1]);\n        // Process a true story message, but ignore if there is already an unchecked message from that element.\n        for (let message of uncheckedStoryMessages) {\n            if (message.sender.toUpperCase() == messageParts[1].toUpperCase()) {\n                return;\n            }\n        }\n        uncheckedStoryMessages.unshift(new StoryMessage(messageParts[1], messageParts[2]));\n    });\n\n    // Sets up the story brain with a room name and radio group unique in the vicinity.\n    // Must be called before other functions will work.\n    function initialise(room: string, radioGroup: number) {\n        roomName = room;\n        radio.setGroup(radioGroup);\n        lcdInitIIC();\n        lcdClearAll();\n        lcdSetBgcolor(lcdGetRgbColor(0, 0, 0));\n        lcdDisplayImage(250, '/escape room icon/story_brain.png', 123, 71, 255);\n        lcdDisplayText(roomName, 251, 123, 143, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n        brainInitialized = true;\n    }\n\n    registerElement('box1', 'BOX');\n    registerElement('box2', 'BOX');\n    registerElement('box3', 'BOX');\n    uncheckedStoryMessages.unshift(new StoryMessage('box1', 'hello'));\n    uncheckedStoryMessages.unshift(new StoryMessage('box2', 'yo'));\n    uncheckedStoryMessages.unshift(new StoryMessage('box3', 'hi!'));\n\n    basic.forever(function () {\n        basic.pause(100);\n\n        // Update elements on screen.\n        for (let i = 0; i < registeredElements.length; i++) {\n            let widgetOrder = (i + 1) * 3;\n            let path = registeredElements[i].image.getFilePath(false);\n            let textColour = lcdGetRgbColor(255, 255, 255)\n            if (registeredElements[i].isStale()) {\n                path = registeredElements[i].image.getFilePath(true);\n                textColour = lcdGetRgbColor(128, 128, 128)\n            }\n            lcdDisplayImage(widgetOrder + 1, path, getIconXPlacement(i), getIconYPlacement(i), 255);\n            lcdDisplayText(registeredElements[i].name, widgetOrder + 2, getIconXPlacement(i) + 6, getIconYPlacement(i) + 46 - 2 - 18, FontSize.Small, textColour);\n            // TODO: Draw a line if there is an unchecked message from that element.\n            //lcdDrawLine(widgetOrder, getIconXPlacement(i) + 23, getIconYPlacement(i) + 23, 159, 119, 5, lcdGetRgbColor(0, 255, 0));\n        }\n    })\n\n}\n\n// Test everything.\nstorybrain.initialiseBrain('Mars', 10);\n\nbasic.forever(function () {\n    if (storybrain.uncheckedMessagesAvailable()) {\n        let myMessage: StoryMessage = storybrain.grabNextUncheckedMessage();\n        basic.showString(myMessage.text);\n    }\n})\n"]]}]}]},{"timestamp":1762068747794,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":54859,"length1":11,"diffs":[[1,"\n"]]}]}]},{"timestamp":1762068749188,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":54859,"length1":24,"diffs":[[1,"    /** */\n"]]},{"start1":54972,"length1":0,"diffs":[[1,"    registerElement('tes1');\n"]]},{"start1":55680,"length1":7,"diffs":[[1,""]]},{"start1":58078,"length1":40,"diffs":[[1,"storybrain.initialiseBrain('Mars', 10);\n"]]}]}]},{"timestamp":1762069311377,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":58463,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1762116757678,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":223,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1761689974631,"editorVersion":"8.0.18","text":{"main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"story brain experiments\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1761695433825,"editorVersion":"8.0.18","text":{"main.ts":"// --------------------------------------\n// Code from DFRobot lcdDisplay extension\n// --------------------------------------\n// Original code has MIT license and copyright (c) 2021 TgJe.\n// Available at: https://github.com/DFRobot/pxt-DFRobot_lcdDisplay\n// Modified to hide blocks that access display directly.\n\nconst enum LCDWidgetCategoryOne {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n}\n\nconst enum LCDWidgetCategoryTwo {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n    Chart = 6,\n    Text = 7,\n    Line = 8,\n    Rectangle = 9,\n    Circle = 10,\n    Triangle = 11,\n    Icon = 12,\n    Gif = 13,\n}\n\nenum FontSize {\n    Large = 1,\n    Small = 2,\n}\n\nenum RectangleRound {\n    IsRound = 1,\n    NoneRound = 2,\n}\n\nenum ChartStyles {\n    LineChart = 3,\n    BarChart = 2,\n    ShadingLineChart = 1,\n}\n\nenum DrawType {\n    Fill = 1,\n    NotFill = 2,\n}\n\nenum Protocol {\n    IIC = 1,\n    Serial = 2,\n}\n\nconst IIC_MAX_TRANSFER_SIZE = 32;\n\n// cmd len\nconst CMDLEN_OF_HEAD_LEN = 3;\nconst CMD_DELETE_OBJ_LEN = 0x06;\nconst CMD_SET_TOP_OBJ_LEN = 0x06;\nconst CMD_SET_COMPASS_VALUE_LEN = 0x07;\nconst CMD_SET_LEN = 0x07;\nconst CMD_SET_GAUGE_VALUE_LEN = 0x07;\nconst CMD_SET_LINE_METER_VALUE_LEN = 0x07;\nconst CMD_SET_BAR_VALUE_LEN = 0x07;\nconst CMD_SET_SLIDER_VALUE_LEN = 0x07;\nconst CMD_SET_ANGLE_OBJ_LEN = 0x08;\nconst CMD_DRAW_COMPASS_LEN = 0x0B;\nconst CMD_DRAW_CHART_LEN = 0x09;\nconst CMD_DRAW_SERIE_LEN = 0x09;\nconst CMD_OF_DRAW_ICON_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_GIF_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_BAR_LEN = 0x10;\nconst CMD_OF_DRAW_SLIDER_LEN = 0x10;\nconst CMD_DRAW_PIXEL_LEN = 0x11;\nconst CMD_DRAW_LINE_LEN = 0x11;\nconst CMD_OF_DRAW_CIRCLE_LEN = 0x13;\nconst CMD_OF_DRAW_GAUGE_LEN = 0x15;\nconst CMD_OF_DRAW_LINE_METER_LEN = 0x15;\nconst CMD_OF_DRAW_RECT_LEN = 0x16;\nconst CMD_OF_DRAW_TRIANGLE_LEN = 0x19;\n\n// cmd\nconst CMD_SET_BACKGROUND_COLOR = 0x19;\nconst CMD_SET_BACKGROUND_IMG = 0x1A;\nconst CMD_OF_DRAW_PIXEL = 0x02;\nconst CMD_OF_DRAW_LINE = 0x03;\nconst CMD_OF_DRAW_RECT = 0x04;\nconst CMD_OF_DRAW_CIRCLE = 0x06;\nconst CMD_OF_DRAW_TRIANGLE = 0x07;\nconst CMD_OF_DRAW_ICON_INTERNAL = 0x08;\nconst CMD_OF_DRAW_ICON_EXTERNAL = 0x09;\nconst CMD_OF_DRAW_BAR = 0x0A;\nconst CMD_OF_DRAW_BAR_VALUE = 0x0B;\nconst CMD_OF_DRAW_SLIDER = 0x0C;\nconst CMD_OF_DRAW_SLIDER_VALUE = 0x0D;\nconst CMD_OF_DRAW_LINE_METER = 0x10;\nconst CMD_OF_DRAW_LINE_METER_VALUE = 0x11;\nconst CMD_OF_DRAW_COMPASS = 0x0E;\nconst CMD_OF_DRAW_COMPASS_VALUE = 0x0F;\nconst CMD_OF_DRAW_GAUGE = 0x12;\nconst CMD_OF_DRAW_GAUGE_VALUE = 0x13;\nconst CMD_OF_DRAW_LINE_CHART = 0x14;\nconst CMD_OF_DRAW_LINE_CHART_TEXT = 0x15;\nconst CMD_OF_DRAW_SERIE = 0x16;\nconst CMD_OF_DRAW_SERIE_DATA = 0x17;\nconst CMD_OF_DRAW_TEXT = 0x18;\nconst CMD_DELETE_OBJ = 0x1B;\nconst CMD_SET_TOP_OBJ = 0x1C;\nconst CMD_SET_ANGLE_OBJ = 0x1E;\nconst CMD_OF_DRAW_GIF_INTERNAL = 0x1F;\nconst CMD_OF_DRAW_GIF_EXTERNAL = 0x20;\n\nconst CMD_HEADER_HIGH = 0x55;\nconst CMD_HEADER_LOW = 0xaa;\n\nlet address = 0x2c;\nclass GenericNode {\n    id: number\n    next: GenericNode\n    constructor(id: number) {\n        this.id = id;\n        this.next = null;\n    }\n}\n\nclass LinkedList {\n    head: GenericNode\n    size: number\n    id: number\n    constructor() {\n        this.head = null;\n        this.size = 0;\n        this.id = 1;\n    }\n\n    // adds a node to the end of the linked list\n    append() {\n        const newNode = new GenericNode(this.id);\n        if (this.head == null) {\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        this.size++;\n        this.id++;\n    }\n    // insert a node at a specific location\n    insert(index: number, id: number): boolean {\n        if (index < 0 || index > this.size) {\n            return false;\n        }\n        const newNode = new GenericNode(id);\n        if (index == 0) {\n            newNode.next = this.head;\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            newNode.next = current;\n            previous.next = newNode;\n        }\n        this.size++;\n        return true;\n    }\n    // removes a node at a specific location\n    removeAt(index: number): boolean {\n        if (index < 0 || index >= this.size || this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (index == 0) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n\n    // example Remove a node with a specific id\n    removeId(id: number): boolean {\n        if (this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (current.id == id) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            while (current.id != id) {\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n}\n\ntype GenericList = {\n    lineChartHead: LinkedList | null,\n    seriesHead: LinkedList | null,\n    compassHead: LinkedList | null,\n    textHead: LinkedList | null,\n    gaugeHead: LinkedList | null,\n    lineHead: LinkedList | null,\n    rectHead: LinkedList | null,\n    circleHead: LinkedList | null,\n    triangleHead: LinkedList | null,\n    lineMeterHead: LinkedList | null,\n    barHead: LinkedList | null,\n    sliderHead: LinkedList | null,\n    iconHead: LinkedList | null,\n    gifHead: LinkedList | null,\n}\n\nlet list: GenericList = {\n    lineChartHead: null,\n    seriesHead: null,\n    compassHead: null,\n    textHead: null,\n    gaugeHead: null,\n    lineHead: null,\n    rectHead: null,\n    circleHead: null,\n    triangleHead: null,\n    lineMeterHead: null,\n    barHead: null,\n    sliderHead: null,\n    iconHead: null,\n    gifHead: null,\n}\nlet protocol: Protocol = Protocol.IIC;\nlet chartID = 0;\nlet axisListX: string[] = [];\nlet axisListY: string[] = [];\nlet axisYData: number[] = [];\nlet seriesData: any = {};\nlet dataFactor = 1; // \"data coordinate conversion factors\n\n/**\n * Original block \"ColorScreen I2C initialization\"\n */\nfunction lcdInitIIC() {\n    creatList();\n    protocol = Protocol.IIC;\n    basic.pause(1000);\n}\n \n/**\n * Original block \"clear the screen\"\n */\nfunction lcdClearAll() {\n    cleanScreen();\n}\n\n/**\n * Original block \"set the background color %color\"\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdSetBgcolor(color: number) {\n    setBackgroundColor(colorToCustom(color));\n}\n\n/**\n * Original block \"red %red green %green blue %blue\"\n * Convert red, green and blue channels into a RGB color\n * @param red to red ,eg: 255 (min 0, max 255, default 255)\n * @param green to green ,eg: 255 (min 0, max 255, default 255)\n * @param blue to blue ,eg: 255 (min 0, max 255, default 255)\n */\nfunction lcdGetRgbColor(red: number, green: number, blue: number): number {\n    return (red << 16) + (green << 8) + (blue);\n}\n\n/**\n * Original block \"set the background picture %picture\"\n * @param picture to picture ,eg: \"fruit.png\"\n */\nfunction lcdSetBgIamge(picture: string) {\n    //setBackgroundImg(0, picture); // Internal storage of pictures\n    setBackgroundImg(1, picture); // Usb flash drive to store pictures\n}\n\n/**\n * Original block \"display text %text number %num position x: %x y: %y size %size color %color\"\n * @param text to text ,eg: \"hello\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayText(text: string, num: number, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, text, size, color);\n}\n\n/**\n * Original block \"display time number %num time %time position x: %x y: %y size %size color %color\"\n * Was marked as deprecated.\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param time to time ,eg: \"12:40:30\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayTime(num: number, time: string, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, time, size, color);\n}\n\n/**\n * Original block \"hour %hour minutes %min second %sec\"\n * @param hour to hour ,eg: 12 (min 0, max 23, default 12)\n * @param min to min ,eg: 40 (min 0, max 59, default 40)\n * @param sec to sec ,eg: 30 (min 0, max 59, default 30)\n */\nfunction lcdGetTime(hour: number, min: number, sec: number): string {\n    return `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`\n}\n\n/**\n * Original block \"display image number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param name to name ,eg: \"/expression icon/happy.png\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayIamge(num: number, name: string, x: number, y: number, size: number) {\n    updateIcon(num, x, y, name, size);\n}\n\n/**\n * Original block \"rotate image number %num angle %angle\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param angle to angle ,eg: 180 (min 0, max 360, default 180)\n */\nfunction lcdRotateIamge(num: number, angle: number) {\n    setAngleIcon(num, angle * 10);\n}\n\n/**\n * Original block \"display gif number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1\n * @param name to name ,eg: \"Snowy.gif\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayGif(num: number, name: string, x: number, y: number, size: number) {\n    updateGif(num, x, y, name, size);\n}\n\n/**\n * Original block \"draw line number %num start x1: %x1 y1: %y1 end x2: %x2 y2: %y2 width %width color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 40 (min 0, max 320, default 40)\n * @param y1 to y1 ,eg: 120 (min 0, max 240, default 120)\n * @param x2 to x2 ,eg: 300 (min 0, max 320, default 300)\n * @param y2 to y2 ,eg: 120 (min 0, max 240, default 120)\n * @param width to width ,eg: 20\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawLine(num: number, x1: number, y1: number, x2: number, y2: number, width: number, color: number) {\n    updateLine(num, x1, y1, x2, y2, width, color);\n}\n\n/**\n * Original block \"draw rectangle number %num start x: %x y: %y width %w height %h line width %width Border color %bocolor %fill color %fcolor %round\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param w to w ,eg: 300 (min 0, max 320, default 300)\n * @param h to h ,eg: 200 (min 0, max 240, default 200)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n * @param round to round ,eg: lcdDisplay.RectangleRound.NoneRound\n */\nfunction lcdDrawRectangle(num: number, x: number, y: number, w: number, h: number, width: number, bocolor: number, fill: DrawType, fcolor: number, round: RectangleRound) {\n    updateRect(num, x, y, w, h, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor, round === RectangleRound.IsRound ? 1 : 0);\n}\n\n/**\n * Original block \"draw circle number %num center x: %x y: %y radius %r line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 160 (min 0, max 320, default 160)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param r to r ,eg: 120 (min 0, max 120, default 120)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawCircle(num: number, x: number, y: number, r: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateCircle(num, x, y, r, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw triangle number %num x1: %x1 y1: %y1 x2: %x2 y2: %y2 x3: %x3 y3: %y3 line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 160 (min 0, max 320, default 160)\n * @param y1 to y1 ,eg: 0 (min 0, max 240, default 0)\n * @param x2 to x2 ,eg: 0 (min 0, max 320, default 0)\n * @param y2 to y2 ,eg: 240 (min 0, max 240, default 240)\n * @param x3 to x3 ,eg: 320 (min 0, max 320, default 320)\n * @param y3 to y3 ,eg: 240 (min 0, max 240, default 240)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawTriangle(num: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateTriangle(num, x1, y1, x2, y2, x3, y3, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw slider number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawSlider(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateSlider(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw bar number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawBar(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateBar(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw compass number %num position x: %x y: %y radius %r\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n */\nfunction lcdDrawCompass(num: number, x: number, y: number, r: number) {\n    updateCompass(num, x, y, r);\n}\n\n/**\n * Original block \"draw gauge number %num position x: %x y: %y radius %r start of scale %start End of scale %end Pointer color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 360 (min 0, max 360, default 360)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawGauge(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateGauge(num, x, y, r, start, end, color, dcolor);\n}\n\n    /**\n     * Original block \"draw lineMeter number %num position x: %x y: %y radius %r start of scale %start End of scale %end Data color %color Dial color %dcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 0 (min 0, max 320, default 0)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     * @param start to start ,eg: 0 (min 0, max 360, default 0)\n     * @param end to end ,eg: 100 (min 0, max 360, default 100)\n     * @param color to color ,eg: 0x000000\n     * @param dcolor to dcolor ,eg: 0xFFFFFF\n     */\nfunction lcdDrawLineMeter(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateLineMeter(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"set %type=LCDWidgetCategoryOne_conv widget number %num data %data\"\n * @param type to type ,eg: LCDWidgetCategoryOne.Slider\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param data to data ,eg: 80\n */\nfunction lcdSetWidgetData(type: number, num: number, data: number) {\n    switch (type) {\n        case LCDWidgetCategoryOne.Slider:\n            setSliderValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Bar:\n            setBarValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Compass:\n            setCompassScale(num, (data / 360) * 3600);\n            break;\n        case LCDWidgetCategoryOne.Gauge:\n            setGaugeValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.LineMeter:\n            setMeterValue(num, data);\n            break;\n        default:\n            break;\n    }\n}\n\n/**\n * Original block \"draw chart number %num X-axis %xaxis Y-axis %yaxis background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan Feb Mar Apr May Jun\"\n * @param yaxis to yaxis ,eg: \"100 80 60 40 20 0\"\n * @param color to color ,eg: 0xFFFFFF\n * @param styles to styles ,eg: ChartStyles.LineChart\n */\nfunction lcdDrawChart(num: number, xaxis: string, yaxis: string, color: number, styles: ChartStyles) {\n    chartID = num;\n    axisListX = xaxis.split(\" \");\n    axisListY = yaxis.split(\" \");\n    axisListX.forEach((value, index) => { axisYData.push(0) });\n    dataFactor = Math.abs((parseInt(axisListY[0]) - parseInt(axisListY[axisListY.length - 1])) / 100);\n    updateChart(chartID, color, styles);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 0, axisListX);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 1, axisListY);\n}\n\n/**\n * Original block \"Set chart data number %num color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdAddChartData(num: number, color: number) {\n    seriesData[num] = axisYData;\n    updateChartSeries(chartID, num, color);\n    addChartSeriesData(chartID, num, seriesData[num], axisListX.length)\n}\n\n/**\n * Original block \"set chart data number %num X-axis %xaxis data %data\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan\"\n * @param data to data ,eg: 80\n */\nfunction lcdSetChartData(num: number, xaxis: string, data: number) {\n    let index = axisListX.indexOf(xaxis);\n    if (data < parseInt(axisListY[axisListY.length - 1]) || data > parseInt(axisListY[0]))\n        return\n    if (index !== -1) {\n        updateChartPoint(chartID, num, index, Math.round((data - parseInt(axisListY[axisListY.length - 1])) / dataFactor));\n        // seriesData[num][index] = Math.round(data / 10);\n    }\n}\n\n/**\n * Original block \"update chart number %num background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0x007FFF\n * @param styles to styles ,eg: lcdDisplay.ChartStyles.BarChart\n */\nfunction lcdUpdateChart(num: number, color: number, styles: ChartStyles) {\n    updateChart(num, color, styles);\n}\n\n/**\n * Original block \"delete %type=LCDWidgetCategoryTwo_conv number %num\"\n * @param type to type ,eg: LCDWidgetCategoryTwo.Text\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n */\nfunction lcdDeleteWidget(type: number, num: number) {\n    switch (type) {\n        case LCDWidgetCategoryTwo.Slider:\n            deleteSlider(num);\n            break;\n        case LCDWidgetCategoryTwo.Bar:\n            deleteBar(num);\n            break;\n        case LCDWidgetCategoryTwo.Compass:\n            deleteCompass(num);\n            break;\n        case LCDWidgetCategoryTwo.Gauge:\n            deleteGauge(num);\n            break;\n        case LCDWidgetCategoryTwo.LineMeter:\n            deleteLineMeter(num);\n            break;\n        case LCDWidgetCategoryTwo.Chart:\n            deleteChart(num);\n            break;\n        case LCDWidgetCategoryTwo.Text:\n            deleteString(num);\n            break;\n        case LCDWidgetCategoryTwo.Line:\n            deleteLine(num);\n            break;\n        case LCDWidgetCategoryTwo.Rectangle:\n            deleteRect(num);\n            break;\n        case LCDWidgetCategoryTwo.Circle:\n            deleteCircle(num);\n            break;\n        case LCDWidgetCategoryTwo.Triangle:\n            deleteTriangle(num);\n            break;\n        case LCDWidgetCategoryTwo.Icon:\n            deleteIcon(num);\n            break;\n        case LCDWidgetCategoryTwo.Gif:\n            deleteGif(num);\n        default:\n            break;\n    }\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryOne_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryOne number\n */\nfunction getWidgetCategoryOne(item: LCDWidgetCategoryOne): number {\n    return item as number;\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryTwo_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryTwo number\n */\nfunction getLCDWidgetCategoryTwo(item: LCDWidgetCategoryTwo): number {\n    return item as number;\n}\n\nfunction cleanScreen() {\n    let cmd = creatCommand(0x1D, 0x04);\n    writeCommand(cmd, 4);\n    basic.pause(1500);\n}\n\nfunction setBackgroundColor(color: number) {\n    let cmd = creatCommand(CMD_SET_BACKGROUND_COLOR, CMD_SET_LEN);\n    cmd = cmd.concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_SET_LEN);\n    basic.pause(300);\n}\n\nfunction setBackgroundImg(location: number, str: string) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_SET_BACKGROUND_IMG, len + 5);\n    cmd = cmd.concat([location]);\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 5);\n}\n\nfunction drawString(x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TEXT), fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction updateString(id: number, x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([id, fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction deleteString(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TEXT, id])\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.textHead, id);\n}\n\nfunction drawLcdTime(x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    drawString(x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction updateLcdTime(id: number, x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    updateString(id, x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction drawIcon(x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_ICON_INTERNAL)]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction setAngleIcon(id: number, angle: number) {\n    let cmd = creatCommand(CMD_SET_ANGLE_OBJ, CMD_SET_ANGLE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]).concat(data16Tobyte(angle));\n    writeCommand(cmd, CMD_SET_ANGLE_OBJ_LEN);\n}\n\nfunction updateIcon(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteIcon(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.iconHead, id);\n}\n\nfunction drawGif(x: number, y: number, str: string, zoom: number): number {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    let id = getID(CMD_OF_DRAW_GIF_EXTERNAL);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n    return id;\n}\n\nfunction updateGif(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteGif(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GIF_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gifHead, id);\n}\n\nfunction drawLine(x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE), width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n}\n\nfunction updateLine(id: number, x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([id, width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n    basic.pause(10);\n}\n\nfunction deleteLine(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineHead, id);\n}\n\nfunction drawRect(x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_RECT), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction updateRect(id: number, x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction deleteRect(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_RECT, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.rectHead, id);\n}\n\nfunction drawCircle(x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_CIRCLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction updateCircle(id: number, x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction deleteCircle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_CIRCLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.circleHead, id);\n}\n\nfunction drawTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TRIANGLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction updateTriangle(id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction deleteTriangle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TRIANGLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.triangleHead, id);\n}\n\nfunction creatSlider(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_SLIDER)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction updateSlider(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction setSliderValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER_VALUE, CMD_SET_SLIDER_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_SLIDER_VALUE_LEN);\n}\n\nfunction deleteSlider(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_SLIDER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.sliderHead, id);\n}\n\nfunction creatBar(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_BAR)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction updateBar(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction setBarValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR_VALUE, CMD_SET_BAR_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_BAR_VALUE_LEN);\n}\n\nfunction deleteBar(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_BAR, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.barHead, id);\n}\n\nfunction creatCompass(x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_COMPASS)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction updateCompass(id: number, x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction setCompassScale(id: number, scale: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS_VALUE, CMD_SET_COMPASS_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(scale));\n    writeCommand(cmd, CMD_SET_COMPASS_VALUE_LEN);\n}\n\nfunction deleteCompass(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_COMPASS, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.compassHead, id);\n}\n\nfunction creatGauge(x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_GAUGE)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction updateGauge(id: number, x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction setGaugeValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE_VALUE, CMD_SET_GAUGE_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_GAUGE_VALUE_LEN);\n}\n\nfunction deleteGauge(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GAUGE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gaugeHead, id);\n}\n\nfunction creatLineMeter(x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE_METER)]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction updateLineMeter(id: number, x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction setTopLineMeter(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n}\n\nfunction deleteLineMeter(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineMeterHead, id);\n}\n\nfunction creatChart(strX: string[], strY: string[], bgColor: number, type: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    let id = getID(CMD_OF_DRAW_LINE_CHART);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n    basic.pause(100);\n    setChartAxisTexts(id, 0, strX);\n    basic.pause(100);\n    setChartAxisTexts(id, 1, strY);\n    return id;\n}\n\nfunction updateChart(id: number, bgColor: number, type: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n}\n\nfunction creatChartSeries(chartId: number, color: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    let serieId = getID(CMD_OF_DRAW_SERIE);\n    cmd = cmd.concat([serieId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n    return serieId;\n}\n\nfunction updateChartSeries(chartId: number, seriesId: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    cmd = cmd.concat([seriesId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n}\n\nfunction setChartAxisTexts(chartId: number, axis: number, text: string[]) {\n    let len = text.length - 1;\n    text.forEach((value, index) => { len = len + value.length });\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART_TEXT, len + 6);\n    cmd = cmd.concat([chartId, axis]);\n    for (let i = 0; i < text.length; i++) {\n        text[i].split(\"\").forEach((value, index) => {\n            cmd.push(value.charCodeAt(0))\n        })\n        if (i != text.length - 1) {\n            cmd.push(0x0A); // \"\\n\"\n        }\n    }\n    writeCommand(cmd, len + 6);\n}\n\nfunction updateChartPoint(chartId: number, seriesId: number, pointNum: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, 10);\n    cmd = cmd.concat([chartId, seriesId, 1, pointNum]).concat(data16Tobyte(value));\n    writeCommand(cmd, 10);\n}\n\nfunction addChartSeriesData(chartId: number, seriesId: number, point: number[], len: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, len * 2 + 8);\n    cmd = cmd.concat([chartId, seriesId, 0, 0]);\n    point.forEach((value, index) => { cmd = cmd.concat(data16Tobyte(value)) });\n    writeCommand(cmd, len * 2 + 8);\n    return 1;\n}\n\nfunction setTopChart(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_SET_TOP_OBJ_LEN);\n}\n\nfunction deleteChart(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineChartHead, id);\n}\n\nfunction setMeterValue(lineMeterId: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER_VALUE, CMD_SET_LINE_METER_VALUE_LEN);\n    cmd = cmd.concat([lineMeterId]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_LINE_METER_VALUE_LEN);\n}\n\n/********************************************************************************************************************/\nfunction creatList() {\n    list.lineChartHead = new LinkedList();\n    list.seriesHead = new LinkedList();\n    list.compassHead = new LinkedList();\n    list.textHead = new LinkedList();\n    list.gaugeHead = new LinkedList();\n    list.lineHead = new LinkedList();\n    list.rectHead = new LinkedList();\n    list.circleHead = new LinkedList();\n    list.triangleHead = new LinkedList();\n    list.lineMeterHead = new LinkedList();\n    list.barHead = new LinkedList();\n    list.sliderHead = new LinkedList();\n    list.iconHead = new LinkedList();\n    list.gifHead = new LinkedList();\n}\n\nfunction getID(type: number): number {\n    let id = 0;\n    switch (type) {\n        case CMD_OF_DRAW_LINE_CHART:\n            id = getNewID(list.lineChartHead);\n            break;\n        case CMD_OF_DRAW_SERIE:\n            id = getNewID(list.seriesHead);\n            break;\n        case CMD_OF_DRAW_COMPASS:\n            id = getNewID(list.compassHead);\n            break;\n        case CMD_OF_DRAW_TEXT:\n            id = getNewID(list.textHead);\n            break;\n        case CMD_OF_DRAW_GAUGE:\n            id = getNewID(list.gaugeHead);\n            break;\n        case CMD_OF_DRAW_LINE:\n            id = getNewID(list.lineHead);\n            break;\n        case CMD_OF_DRAW_RECT:\n            id = getNewID(list.rectHead);\n            break;\n        case CMD_OF_DRAW_TRIANGLE:\n            id = getNewID(list.triangleHead);\n            break;\n        case CMD_OF_DRAW_CIRCLE:\n            id = getNewID(list.circleHead);\n            break;\n        case CMD_OF_DRAW_LINE_METER:\n            id = getNewID(list.lineMeterHead);\n            break;\n        case CMD_OF_DRAW_BAR:\n            id = getNewID(list.barHead);\n            break;\n        case CMD_OF_DRAW_SLIDER:\n            id = getNewID(list.sliderHead);\n            break;\n        case CMD_OF_DRAW_ICON_INTERNAL:\n            id = getNewID(list.iconHead);\n            break;\n        case CMD_OF_DRAW_GIF_INTERNAL:\n            id = getNewID(list.gifHead);\n            break;\n        default:\n            break;\n    }\n    return id;\n}\n\nfunction getNewID(linkList: LinkedList): number {\n    linkList.append();\n    return linkList.head.id;\n}\n\nfunction deleteNodeByID(linkList: LinkedList, id: number) {\n    linkList.removeId(id);\n}\n\nfunction data16Tobyte(data: number): number[] {\n    return [(data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction data24Tobyte(data: number): number[] {\n    return [(data >> 16) & 0xFF, (data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction colorToCustom(color: number): number {\n    switch (color) {\n        case 0x999999:\n            return 0x696969;\n        case 0x7f00ff:\n            return 0x800080;\n        default:\n            return color;\n    }\n}\n\nfunction creatCommand(cmd: number, len: number): number[] {\n    return [CMD_HEADER_HIGH, CMD_HEADER_LOW, len - CMDLEN_OF_HEAD_LEN, cmd];\n}\n\nfunction writeCommand(data: number[], len: number) {\n    // serial.writeNumbers(data);\n    if (protocol == Protocol.IIC) {\n        let remain = len;\n        let i = 0;\n        while (remain > 0) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? 32 : remain;\n            if (remain > IIC_MAX_TRANSFER_SIZE) {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), true);\n            } else {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), false);\n            }\n            remain = remain - currentTransferSize;\n            i = i + 1;\n        }\n    } else {\n     }\n}\n\nfunction readACK(length: number): Buffer {\n    if (protocol == Protocol.IIC) {\n        let remain = length;\n        let buf: Buffer = pins.createBuffer(0);\n        while (remain) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? IIC_MAX_TRANSFER_SIZE : remain;\n            buf = buf.concat(pins.i2cReadBuffer(address, currentTransferSize));\n            remain = remain - currentTransferSize;\n        }\n        return buf;\n    } else {\n        let buf: Buffer = pins.createBuffer(0);\n        return buf;\n    }\n}\n\n// --------------------------------------\n// End of code from DFRobot lcdDisplay extension\n// --------------------------------------\n\n\n/*\n/ Check-in messages are done as follows:   [room name]*[element name]\n/ Trigger messages are done as follows:   [room name]*[element name]*[message]\n/\n/ room name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all escape rooms in the vicinity.\n/ element ID is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all elements in this escape room.\n/ message is a string of no more than 9 characters. Asterisk not allowed.\n*/\n\nlet roomName: string = 'UNNAMED'\nlet brainInitialized: boolean = false;\nlet uncheckedMessages: string[] = [];\nlet uncheckedMessagesSender: string[] = [];\n\n// A block that sets up the story brain with a room name and radio group unique in the vicinity.\nfunction initializeBrain(room: string, radioGroup: number) {\n    roomName = room;\n    radio.setGroup(radioGroup);\n    brainInitialized = true;\n}\n\n// \nradio.onReceivedString(function(receivedString: string) {\n    if \n    uncheckedMessages.push(new StoryMessage(string));\n});\n\n\n\n// Test display.\nlcdInitIIC();\nlcdSetBgcolor(lcdGetRgbColor(0,0,127));\nlcdDisplayText(latestMessage, 1, 120, 120, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n","README.md":"","pxt.json":"{\n    \"name\": \"story brain experiments\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1761774267367,"editorVersion":"8.0.18","text":{"main.ts":"// --------------------------------------\n// Code from DFRobot lcdDisplay extension\n// --------------------------------------\n// Original code has MIT license and copyright (c) 2021 TgJe.\n// Available at: https://github.com/DFRobot/pxt-DFRobot_lcdDisplay\n// Modified to hide blocks that access display directly.\n\nconst enum LCDWidgetCategoryOne {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n}\n\nconst enum LCDWidgetCategoryTwo {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n    Chart = 6,\n    Text = 7,\n    Line = 8,\n    Rectangle = 9,\n    Circle = 10,\n    Triangle = 11,\n    Icon = 12,\n    Gif = 13,\n}\n\nenum FontSize {\n    Large = 1,\n    Small = 2,\n}\n\nenum RectangleRound {\n    IsRound = 1,\n    NoneRound = 2,\n}\n\nenum ChartStyles {\n    LineChart = 3,\n    BarChart = 2,\n    ShadingLineChart = 1,\n}\n\nenum DrawType {\n    Fill = 1,\n    NotFill = 2,\n}\n\nenum Protocol {\n    IIC = 1,\n    Serial = 2,\n}\n\nconst IIC_MAX_TRANSFER_SIZE = 32;\n\n// cmd len\nconst CMDLEN_OF_HEAD_LEN = 3;\nconst CMD_DELETE_OBJ_LEN = 0x06;\nconst CMD_SET_TOP_OBJ_LEN = 0x06;\nconst CMD_SET_COMPASS_VALUE_LEN = 0x07;\nconst CMD_SET_LEN = 0x07;\nconst CMD_SET_GAUGE_VALUE_LEN = 0x07;\nconst CMD_SET_LINE_METER_VALUE_LEN = 0x07;\nconst CMD_SET_BAR_VALUE_LEN = 0x07;\nconst CMD_SET_SLIDER_VALUE_LEN = 0x07;\nconst CMD_SET_ANGLE_OBJ_LEN = 0x08;\nconst CMD_DRAW_COMPASS_LEN = 0x0B;\nconst CMD_DRAW_CHART_LEN = 0x09;\nconst CMD_DRAW_SERIE_LEN = 0x09;\nconst CMD_OF_DRAW_ICON_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_GIF_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_BAR_LEN = 0x10;\nconst CMD_OF_DRAW_SLIDER_LEN = 0x10;\nconst CMD_DRAW_PIXEL_LEN = 0x11;\nconst CMD_DRAW_LINE_LEN = 0x11;\nconst CMD_OF_DRAW_CIRCLE_LEN = 0x13;\nconst CMD_OF_DRAW_GAUGE_LEN = 0x15;\nconst CMD_OF_DRAW_LINE_METER_LEN = 0x15;\nconst CMD_OF_DRAW_RECT_LEN = 0x16;\nconst CMD_OF_DRAW_TRIANGLE_LEN = 0x19;\n\n// cmd\nconst CMD_SET_BACKGROUND_COLOR = 0x19;\nconst CMD_SET_BACKGROUND_IMG = 0x1A;\nconst CMD_OF_DRAW_PIXEL = 0x02;\nconst CMD_OF_DRAW_LINE = 0x03;\nconst CMD_OF_DRAW_RECT = 0x04;\nconst CMD_OF_DRAW_CIRCLE = 0x06;\nconst CMD_OF_DRAW_TRIANGLE = 0x07;\nconst CMD_OF_DRAW_ICON_INTERNAL = 0x08;\nconst CMD_OF_DRAW_ICON_EXTERNAL = 0x09;\nconst CMD_OF_DRAW_BAR = 0x0A;\nconst CMD_OF_DRAW_BAR_VALUE = 0x0B;\nconst CMD_OF_DRAW_SLIDER = 0x0C;\nconst CMD_OF_DRAW_SLIDER_VALUE = 0x0D;\nconst CMD_OF_DRAW_LINE_METER = 0x10;\nconst CMD_OF_DRAW_LINE_METER_VALUE = 0x11;\nconst CMD_OF_DRAW_COMPASS = 0x0E;\nconst CMD_OF_DRAW_COMPASS_VALUE = 0x0F;\nconst CMD_OF_DRAW_GAUGE = 0x12;\nconst CMD_OF_DRAW_GAUGE_VALUE = 0x13;\nconst CMD_OF_DRAW_LINE_CHART = 0x14;\nconst CMD_OF_DRAW_LINE_CHART_TEXT = 0x15;\nconst CMD_OF_DRAW_SERIE = 0x16;\nconst CMD_OF_DRAW_SERIE_DATA = 0x17;\nconst CMD_OF_DRAW_TEXT = 0x18;\nconst CMD_DELETE_OBJ = 0x1B;\nconst CMD_SET_TOP_OBJ = 0x1C;\nconst CMD_SET_ANGLE_OBJ = 0x1E;\nconst CMD_OF_DRAW_GIF_INTERNAL = 0x1F;\nconst CMD_OF_DRAW_GIF_EXTERNAL = 0x20;\n\nconst CMD_HEADER_HIGH = 0x55;\nconst CMD_HEADER_LOW = 0xaa;\n\nlet address = 0x2c;\nclass GenericNode {\n    id: number\n    next: GenericNode\n    constructor(id: number) {\n        this.id = id;\n        this.next = null;\n    }\n}\n\nclass LinkedList {\n    head: GenericNode\n    size: number\n    id: number\n    constructor() {\n        this.head = null;\n        this.size = 0;\n        this.id = 1;\n    }\n\n    // adds a node to the end of the linked list\n    append() {\n        const newNode = new GenericNode(this.id);\n        if (this.head == null) {\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        this.size++;\n        this.id++;\n    }\n    // insert a node at a specific location\n    insert(index: number, id: number): boolean {\n        if (index < 0 || index > this.size) {\n            return false;\n        }\n        const newNode = new GenericNode(id);\n        if (index == 0) {\n            newNode.next = this.head;\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            newNode.next = current;\n            previous.next = newNode;\n        }\n        this.size++;\n        return true;\n    }\n    // removes a node at a specific location\n    removeAt(index: number): boolean {\n        if (index < 0 || index >= this.size || this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (index == 0) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n\n    // example Remove a node with a specific id\n    removeId(id: number): boolean {\n        if (this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (current.id == id) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            while (current.id != id) {\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n}\n\ntype GenericList = {\n    lineChartHead: LinkedList | null,\n    seriesHead: LinkedList | null,\n    compassHead: LinkedList | null,\n    textHead: LinkedList | null,\n    gaugeHead: LinkedList | null,\n    lineHead: LinkedList | null,\n    rectHead: LinkedList | null,\n    circleHead: LinkedList | null,\n    triangleHead: LinkedList | null,\n    lineMeterHead: LinkedList | null,\n    barHead: LinkedList | null,\n    sliderHead: LinkedList | null,\n    iconHead: LinkedList | null,\n    gifHead: LinkedList | null,\n}\n\nlet list: GenericList = {\n    lineChartHead: null,\n    seriesHead: null,\n    compassHead: null,\n    textHead: null,\n    gaugeHead: null,\n    lineHead: null,\n    rectHead: null,\n    circleHead: null,\n    triangleHead: null,\n    lineMeterHead: null,\n    barHead: null,\n    sliderHead: null,\n    iconHead: null,\n    gifHead: null,\n}\nlet protocol: Protocol = Protocol.IIC;\nlet chartID = 0;\nlet axisListX: string[] = [];\nlet axisListY: string[] = [];\nlet axisYData: number[] = [];\nlet seriesData: any = {};\nlet dataFactor = 1; // \"data coordinate conversion factors\n\n/**\n * Original block \"ColorScreen I2C initialization\"\n */\nfunction lcdInitIIC() {\n    creatList();\n    protocol = Protocol.IIC;\n    basic.pause(1000);\n}\n \n/**\n * Original block \"clear the screen\"\n */\nfunction lcdClearAll() {\n    cleanScreen();\n}\n\n/**\n * Original block \"set the background color %color\"\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdSetBgcolor(color: number) {\n    setBackgroundColor(colorToCustom(color));\n}\n\n/**\n * Original block \"red %red green %green blue %blue\"\n * Convert red, green and blue channels into a RGB color\n * @param red to red ,eg: 255 (min 0, max 255, default 255)\n * @param green to green ,eg: 255 (min 0, max 255, default 255)\n * @param blue to blue ,eg: 255 (min 0, max 255, default 255)\n */\nfunction lcdGetRgbColor(red: number, green: number, blue: number): number {\n    return (red << 16) + (green << 8) + (blue);\n}\n\n/**\n * Original block \"set the background picture %picture\"\n * @param picture to picture ,eg: \"fruit.png\"\n */\nfunction lcdSetBgIamge(picture: string) {\n    //setBackgroundImg(0, picture); // Internal storage of pictures\n    setBackgroundImg(1, picture); // Usb flash drive to store pictures\n}\n\n/**\n * Original block \"display text %text number %num position x: %x y: %y size %size color %color\"\n * @param text to text ,eg: \"hello\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayText(text: string, num: number, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, text, size, color);\n}\n\n/**\n * Original block \"display time number %num time %time position x: %x y: %y size %size color %color\"\n * Was marked as deprecated.\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param time to time ,eg: \"12:40:30\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayTime(num: number, time: string, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, time, size, color);\n}\n\n/**\n * Original block \"hour %hour minutes %min second %sec\"\n * @param hour to hour ,eg: 12 (min 0, max 23, default 12)\n * @param min to min ,eg: 40 (min 0, max 59, default 40)\n * @param sec to sec ,eg: 30 (min 0, max 59, default 30)\n */\nfunction lcdGetTime(hour: number, min: number, sec: number): string {\n    return `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`\n}\n\n/**\n * Original block \"display image number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param name to name ,eg: \"/expression icon/happy.png\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayImage(num: number, name: string, x: number, y: number, size: number) {\n    updateIcon(num, x, y, name, size);\n}\n\n/**\n * Original block \"rotate image number %num angle %angle\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param angle to angle ,eg: 180 (min 0, max 360, default 180)\n */\nfunction lcdRotateIamge(num: number, angle: number) {\n    setAngleIcon(num, angle * 10);\n}\n\n/**\n * Original block \"display gif number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1\n * @param name to name ,eg: \"Snowy.gif\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayGif(num: number, name: string, x: number, y: number, size: number) {\n    updateGif(num, x, y, name, size);\n}\n\n/**\n * Original block \"draw line number %num start x1: %x1 y1: %y1 end x2: %x2 y2: %y2 width %width color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 40 (min 0, max 320, default 40)\n * @param y1 to y1 ,eg: 120 (min 0, max 240, default 120)\n * @param x2 to x2 ,eg: 300 (min 0, max 320, default 300)\n * @param y2 to y2 ,eg: 120 (min 0, max 240, default 120)\n * @param width to width ,eg: 20\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawLine(num: number, x1: number, y1: number, x2: number, y2: number, width: number, color: number) {\n    updateLine(num, x1, y1, x2, y2, width, color);\n}\n\n/**\n * Original block \"draw rectangle number %num start x: %x y: %y width %w height %h line width %width Border color %bocolor %fill color %fcolor %round\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param w to w ,eg: 300 (min 0, max 320, default 300)\n * @param h to h ,eg: 200 (min 0, max 240, default 200)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n * @param round to round ,eg: lcdDisplay.RectangleRound.NoneRound\n */\nfunction lcdDrawRectangle(num: number, x: number, y: number, w: number, h: number, width: number, bocolor: number, fill: DrawType, fcolor: number, round: RectangleRound) {\n    updateRect(num, x, y, w, h, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor, round === RectangleRound.IsRound ? 1 : 0);\n}\n\n/**\n * Original block \"draw circle number %num center x: %x y: %y radius %r line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 160 (min 0, max 320, default 160)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param r to r ,eg: 120 (min 0, max 120, default 120)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawCircle(num: number, x: number, y: number, r: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateCircle(num, x, y, r, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw triangle number %num x1: %x1 y1: %y1 x2: %x2 y2: %y2 x3: %x3 y3: %y3 line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 160 (min 0, max 320, default 160)\n * @param y1 to y1 ,eg: 0 (min 0, max 240, default 0)\n * @param x2 to x2 ,eg: 0 (min 0, max 320, default 0)\n * @param y2 to y2 ,eg: 240 (min 0, max 240, default 240)\n * @param x3 to x3 ,eg: 320 (min 0, max 320, default 320)\n * @param y3 to y3 ,eg: 240 (min 0, max 240, default 240)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawTriangle(num: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateTriangle(num, x1, y1, x2, y2, x3, y3, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw slider number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawSlider(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateSlider(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw bar number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawBar(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateBar(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw compass number %num position x: %x y: %y radius %r\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n */\nfunction lcdDrawCompass(num: number, x: number, y: number, r: number) {\n    updateCompass(num, x, y, r);\n}\n\n/**\n * Original block \"draw gauge number %num position x: %x y: %y radius %r start of scale %start End of scale %end Pointer color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 360 (min 0, max 360, default 360)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawGauge(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateGauge(num, x, y, r, start, end, color, dcolor);\n}\n\n    /**\n     * Original block \"draw lineMeter number %num position x: %x y: %y radius %r start of scale %start End of scale %end Data color %color Dial color %dcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 0 (min 0, max 320, default 0)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     * @param start to start ,eg: 0 (min 0, max 360, default 0)\n     * @param end to end ,eg: 100 (min 0, max 360, default 100)\n     * @param color to color ,eg: 0x000000\n     * @param dcolor to dcolor ,eg: 0xFFFFFF\n     */\nfunction lcdDrawLineMeter(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateLineMeter(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"set %type=LCDWidgetCategoryOne_conv widget number %num data %data\"\n * @param type to type ,eg: LCDWidgetCategoryOne.Slider\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param data to data ,eg: 80\n */\nfunction lcdSetWidgetData(type: number, num: number, data: number) {\n    switch (type) {\n        case LCDWidgetCategoryOne.Slider:\n            setSliderValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Bar:\n            setBarValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Compass:\n            setCompassScale(num, (data / 360) * 3600);\n            break;\n        case LCDWidgetCategoryOne.Gauge:\n            setGaugeValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.LineMeter:\n            setMeterValue(num, data);\n            break;\n        default:\n            break;\n    }\n}\n\n/**\n * Original block \"draw chart number %num X-axis %xaxis Y-axis %yaxis background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan Feb Mar Apr May Jun\"\n * @param yaxis to yaxis ,eg: \"100 80 60 40 20 0\"\n * @param color to color ,eg: 0xFFFFFF\n * @param styles to styles ,eg: ChartStyles.LineChart\n */\nfunction lcdDrawChart(num: number, xaxis: string, yaxis: string, color: number, styles: ChartStyles) {\n    chartID = num;\n    axisListX = xaxis.split(\" \");\n    axisListY = yaxis.split(\" \");\n    axisListX.forEach((value, index) => { axisYData.push(0) });\n    dataFactor = Math.abs((parseInt(axisListY[0]) - parseInt(axisListY[axisListY.length - 1])) / 100);\n    updateChart(chartID, color, styles);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 0, axisListX);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 1, axisListY);\n}\n\n/**\n * Original block \"Set chart data number %num color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdAddChartData(num: number, color: number) {\n    seriesData[num] = axisYData;\n    updateChartSeries(chartID, num, color);\n    addChartSeriesData(chartID, num, seriesData[num], axisListX.length)\n}\n\n/**\n * Original block \"set chart data number %num X-axis %xaxis data %data\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan\"\n * @param data to data ,eg: 80\n */\nfunction lcdSetChartData(num: number, xaxis: string, data: number) {\n    let index = axisListX.indexOf(xaxis);\n    if (data < parseInt(axisListY[axisListY.length - 1]) || data > parseInt(axisListY[0]))\n        return\n    if (index !== -1) {\n        updateChartPoint(chartID, num, index, Math.round((data - parseInt(axisListY[axisListY.length - 1])) / dataFactor));\n        // seriesData[num][index] = Math.round(data / 10);\n    }\n}\n\n/**\n * Original block \"update chart number %num background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0x007FFF\n * @param styles to styles ,eg: lcdDisplay.ChartStyles.BarChart\n */\nfunction lcdUpdateChart(num: number, color: number, styles: ChartStyles) {\n    updateChart(num, color, styles);\n}\n\n/**\n * Original block \"delete %type=LCDWidgetCategoryTwo_conv number %num\"\n * @param type to type ,eg: LCDWidgetCategoryTwo.Text\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n */\nfunction lcdDeleteWidget(type: number, num: number) {\n    switch (type) {\n        case LCDWidgetCategoryTwo.Slider:\n            deleteSlider(num);\n            break;\n        case LCDWidgetCategoryTwo.Bar:\n            deleteBar(num);\n            break;\n        case LCDWidgetCategoryTwo.Compass:\n            deleteCompass(num);\n            break;\n        case LCDWidgetCategoryTwo.Gauge:\n            deleteGauge(num);\n            break;\n        case LCDWidgetCategoryTwo.LineMeter:\n            deleteLineMeter(num);\n            break;\n        case LCDWidgetCategoryTwo.Chart:\n            deleteChart(num);\n            break;\n        case LCDWidgetCategoryTwo.Text:\n            deleteString(num);\n            break;\n        case LCDWidgetCategoryTwo.Line:\n            deleteLine(num);\n            break;\n        case LCDWidgetCategoryTwo.Rectangle:\n            deleteRect(num);\n            break;\n        case LCDWidgetCategoryTwo.Circle:\n            deleteCircle(num);\n            break;\n        case LCDWidgetCategoryTwo.Triangle:\n            deleteTriangle(num);\n            break;\n        case LCDWidgetCategoryTwo.Icon:\n            deleteIcon(num);\n            break;\n        case LCDWidgetCategoryTwo.Gif:\n            deleteGif(num);\n        default:\n            break;\n    }\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryOne_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryOne number\n */\nfunction getWidgetCategoryOne(item: LCDWidgetCategoryOne): number {\n    return item as number;\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryTwo_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryTwo number\n */\nfunction getLCDWidgetCategoryTwo(item: LCDWidgetCategoryTwo): number {\n    return item as number;\n}\n\nfunction cleanScreen() {\n    let cmd = creatCommand(0x1D, 0x04);\n    writeCommand(cmd, 4);\n    basic.pause(1500);\n}\n\nfunction setBackgroundColor(color: number) {\n    let cmd = creatCommand(CMD_SET_BACKGROUND_COLOR, CMD_SET_LEN);\n    cmd = cmd.concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_SET_LEN);\n    basic.pause(300);\n}\n\nfunction setBackgroundImg(location: number, str: string) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_SET_BACKGROUND_IMG, len + 5);\n    cmd = cmd.concat([location]);\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 5);\n}\n\nfunction drawString(x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TEXT), fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction updateString(id: number, x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([id, fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction deleteString(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TEXT, id])\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.textHead, id);\n}\n\nfunction drawLcdTime(x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    drawString(x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction updateLcdTime(id: number, x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    updateString(id, x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction drawIcon(x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_ICON_INTERNAL)]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction setAngleIcon(id: number, angle: number) {\n    let cmd = creatCommand(CMD_SET_ANGLE_OBJ, CMD_SET_ANGLE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]).concat(data16Tobyte(angle));\n    writeCommand(cmd, CMD_SET_ANGLE_OBJ_LEN);\n}\n\nfunction updateIcon(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteIcon(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.iconHead, id);\n}\n\nfunction drawGif(x: number, y: number, str: string, zoom: number): number {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    let id = getID(CMD_OF_DRAW_GIF_EXTERNAL);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n    return id;\n}\n\nfunction updateGif(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteGif(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GIF_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gifHead, id);\n}\n\nfunction drawLine(x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE), width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n}\n\nfunction updateLine(id: number, x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([id, width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n    basic.pause(10);\n}\n\nfunction deleteLine(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineHead, id);\n}\n\nfunction drawRect(x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_RECT), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction updateRect(id: number, x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction deleteRect(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_RECT, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.rectHead, id);\n}\n\nfunction drawCircle(x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_CIRCLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction updateCircle(id: number, x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction deleteCircle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_CIRCLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.circleHead, id);\n}\n\nfunction drawTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TRIANGLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction updateTriangle(id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction deleteTriangle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TRIANGLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.triangleHead, id);\n}\n\nfunction creatSlider(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_SLIDER)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction updateSlider(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction setSliderValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER_VALUE, CMD_SET_SLIDER_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_SLIDER_VALUE_LEN);\n}\n\nfunction deleteSlider(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_SLIDER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.sliderHead, id);\n}\n\nfunction creatBar(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_BAR)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction updateBar(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction setBarValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR_VALUE, CMD_SET_BAR_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_BAR_VALUE_LEN);\n}\n\nfunction deleteBar(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_BAR, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.barHead, id);\n}\n\nfunction creatCompass(x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_COMPASS)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction updateCompass(id: number, x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction setCompassScale(id: number, scale: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS_VALUE, CMD_SET_COMPASS_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(scale));\n    writeCommand(cmd, CMD_SET_COMPASS_VALUE_LEN);\n}\n\nfunction deleteCompass(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_COMPASS, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.compassHead, id);\n}\n\nfunction creatGauge(x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_GAUGE)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction updateGauge(id: number, x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction setGaugeValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE_VALUE, CMD_SET_GAUGE_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_GAUGE_VALUE_LEN);\n}\n\nfunction deleteGauge(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GAUGE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gaugeHead, id);\n}\n\nfunction creatLineMeter(x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE_METER)]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction updateLineMeter(id: number, x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction setTopLineMeter(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n}\n\nfunction deleteLineMeter(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineMeterHead, id);\n}\n\nfunction creatChart(strX: string[], strY: string[], bgColor: number, type: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    let id = getID(CMD_OF_DRAW_LINE_CHART);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n    basic.pause(100);\n    setChartAxisTexts(id, 0, strX);\n    basic.pause(100);\n    setChartAxisTexts(id, 1, strY);\n    return id;\n}\n\nfunction updateChart(id: number, bgColor: number, type: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n}\n\nfunction creatChartSeries(chartId: number, color: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    let serieId = getID(CMD_OF_DRAW_SERIE);\n    cmd = cmd.concat([serieId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n    return serieId;\n}\n\nfunction updateChartSeries(chartId: number, seriesId: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    cmd = cmd.concat([seriesId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n}\n\nfunction setChartAxisTexts(chartId: number, axis: number, text: string[]) {\n    let len = text.length - 1;\n    text.forEach((value, index) => { len = len + value.length });\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART_TEXT, len + 6);\n    cmd = cmd.concat([chartId, axis]);\n    for (let i = 0; i < text.length; i++) {\n        text[i].split(\"\").forEach((value, index) => {\n            cmd.push(value.charCodeAt(0))\n        })\n        if (i != text.length - 1) {\n            cmd.push(0x0A); // \"\\n\"\n        }\n    }\n    writeCommand(cmd, len + 6);\n}\n\nfunction updateChartPoint(chartId: number, seriesId: number, pointNum: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, 10);\n    cmd = cmd.concat([chartId, seriesId, 1, pointNum]).concat(data16Tobyte(value));\n    writeCommand(cmd, 10);\n}\n\nfunction addChartSeriesData(chartId: number, seriesId: number, point: number[], len: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, len * 2 + 8);\n    cmd = cmd.concat([chartId, seriesId, 0, 0]);\n    point.forEach((value, index) => { cmd = cmd.concat(data16Tobyte(value)) });\n    writeCommand(cmd, len * 2 + 8);\n    return 1;\n}\n\nfunction setTopChart(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_SET_TOP_OBJ_LEN);\n}\n\nfunction deleteChart(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineChartHead, id);\n}\n\nfunction setMeterValue(lineMeterId: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER_VALUE, CMD_SET_LINE_METER_VALUE_LEN);\n    cmd = cmd.concat([lineMeterId]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_LINE_METER_VALUE_LEN);\n}\n\n/********************************************************************************************************************/\nfunction creatList() {\n    list.lineChartHead = new LinkedList();\n    list.seriesHead = new LinkedList();\n    list.compassHead = new LinkedList();\n    list.textHead = new LinkedList();\n    list.gaugeHead = new LinkedList();\n    list.lineHead = new LinkedList();\n    list.rectHead = new LinkedList();\n    list.circleHead = new LinkedList();\n    list.triangleHead = new LinkedList();\n    list.lineMeterHead = new LinkedList();\n    list.barHead = new LinkedList();\n    list.sliderHead = new LinkedList();\n    list.iconHead = new LinkedList();\n    list.gifHead = new LinkedList();\n}\n\nfunction getID(type: number): number {\n    let id = 0;\n    switch (type) {\n        case CMD_OF_DRAW_LINE_CHART:\n            id = getNewID(list.lineChartHead);\n            break;\n        case CMD_OF_DRAW_SERIE:\n            id = getNewID(list.seriesHead);\n            break;\n        case CMD_OF_DRAW_COMPASS:\n            id = getNewID(list.compassHead);\n            break;\n        case CMD_OF_DRAW_TEXT:\n            id = getNewID(list.textHead);\n            break;\n        case CMD_OF_DRAW_GAUGE:\n            id = getNewID(list.gaugeHead);\n            break;\n        case CMD_OF_DRAW_LINE:\n            id = getNewID(list.lineHead);\n            break;\n        case CMD_OF_DRAW_RECT:\n            id = getNewID(list.rectHead);\n            break;\n        case CMD_OF_DRAW_TRIANGLE:\n            id = getNewID(list.triangleHead);\n            break;\n        case CMD_OF_DRAW_CIRCLE:\n            id = getNewID(list.circleHead);\n            break;\n        case CMD_OF_DRAW_LINE_METER:\n            id = getNewID(list.lineMeterHead);\n            break;\n        case CMD_OF_DRAW_BAR:\n            id = getNewID(list.barHead);\n            break;\n        case CMD_OF_DRAW_SLIDER:\n            id = getNewID(list.sliderHead);\n            break;\n        case CMD_OF_DRAW_ICON_INTERNAL:\n            id = getNewID(list.iconHead);\n            break;\n        case CMD_OF_DRAW_GIF_INTERNAL:\n            id = getNewID(list.gifHead);\n            break;\n        default:\n            break;\n    }\n    return id;\n}\n\nfunction getNewID(linkList: LinkedList): number {\n    linkList.append();\n    return linkList.head.id;\n}\n\nfunction deleteNodeByID(linkList: LinkedList, id: number) {\n    linkList.removeId(id);\n}\n\nfunction data16Tobyte(data: number): number[] {\n    return [(data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction data24Tobyte(data: number): number[] {\n    return [(data >> 16) & 0xFF, (data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction colorToCustom(color: number): number {\n    switch (color) {\n        case 0x999999:\n            return 0x696969;\n        case 0x7f00ff:\n            return 0x800080;\n        default:\n            return color;\n    }\n}\n\nfunction creatCommand(cmd: number, len: number): number[] {\n    return [CMD_HEADER_HIGH, CMD_HEADER_LOW, len - CMDLEN_OF_HEAD_LEN, cmd];\n}\n\nfunction writeCommand(data: number[], len: number) {\n    // serial.writeNumbers(data);\n    if (protocol == Protocol.IIC) {\n        let remain = len;\n        let i = 0;\n        while (remain > 0) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? 32 : remain;\n            if (remain > IIC_MAX_TRANSFER_SIZE) {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), true);\n            } else {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), false);\n            }\n            remain = remain - currentTransferSize;\n            i = i + 1;\n        }\n    } else {\n     }\n}\n\nfunction readACK(length: number): Buffer {\n    if (protocol == Protocol.IIC) {\n        let remain = length;\n        let buf: Buffer = pins.createBuffer(0);\n        while (remain) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? IIC_MAX_TRANSFER_SIZE : remain;\n            buf = buf.concat(pins.i2cReadBuffer(address, currentTransferSize));\n            remain = remain - currentTransferSize;\n        }\n        return buf;\n    } else {\n        let buf: Buffer = pins.createBuffer(0);\n        return buf;\n    }\n}\n\n// --------------------------------------\n// End of code from DFRobot lcdDisplay extension\n// --------------------------------------\n\n\n\nconst ROOM_ELEMENT_IMAGE_CODE_UNKNOWN = 'UNKNOWN';\nconst ROOM_ELEMENT_IMAGE_FILENAME_UNKNOWN = 'unknown';\nconst ROOM_ELEMENT_IMAGE_CODE_BOX = 'BOX';\nconst ROOM_ELEMENT_IMAGE_FILENAME_BOX = 'box';\nconst ROOM_ELEMENT_IMAGE_CODE_LIGHTS = 'LIGHTS';\nconst ROOM_ELEMENT_IMAGE_FILENAME_LIGHTS = 'lights';\n\n/**\n * Information about an image for an escape room element.\n */\nclass RoomElementImage {\n    code: string;\n    private _filename: string;\n\n    /**\n     * Constructs the image using \n     */\n    constructor(code: string = null) {\n        if (code === null) {\n            this.code = ROOM_ELEMENT_IMAGE_CODE_UNKNOWN;\n        } else {\n            this.code = code;\n        }\n        switch(code.toUpperCase()) {\n            case ROOM_ELEMENT_IMAGE_CODE_BOX:\n                this._filename = ROOM_ELEMENT_IMAGE_FILENAME_BOX;\n                break;\n            case ROOM_ELEMENT_IMAGE_CODE_LIGHTS:\n                this._filename = ROOM_ELEMENT_IMAGE_FILENAME_LIGHTS;\n                break;\n            case ROOM_ELEMENT_IMAGE_CODE_UNKNOWN:\n            default:\n                this._filename = ROOM_ELEMENT_IMAGE_FILENAME_UNKNOWN;\n        }\n    }\n\n    public getFilePath(stale: boolean = false) {\n        if (stale) {\n            return \"/escape room icon/\" + this._filename + \"_dark.png\";\n        } else {\n            return \"/escape room icon/\" + this._filename + \"_mid.png\";\n        }\n        \n    }\n}\n\nclass RoomElement {\n    name: string;\n    lastCheckInTime: number;  // Millis since power on.\n    image: RoomElementImage;\n\n    constructor(name: string, imageCode: string = null) {\n        this.name = name;\n        this.lastCheckInTime = control.millis();\n        this.image = new RoomElementImage(imageCode);\n    }\n\n    updateCheckInTime() {\n        this.lastCheckInTime = control.millis();\n    }\n\n    isStale(): boolean {\n        if (control.millis() - this.lastCheckInTime > 8000) {\n            return true;\n        }\n        return false;\n    }\n}\n\nfunction getIconXPlacement(elementOrder: number) {\n    switch(elementOrder) {\n        case 0: return 2;           \n        case 1: return 2;\n        case 2: return 2;\n        case 3: return 2;\n        case 4: return 2;\n        case 5: return 2 + 45 * 1;\n        case 6: return 2 + 45 * 2;\n        case 7: return 2 + 45 * 3;\n        case 8: return 2 + 45 * 4;\n        case 9: return 2 + 45 * 5;\n        case 10: return 2 + 45 * 6;\n        case 11: return 2 + 45 * 6;\n        case 12: return 2 + 45 * 6;\n        case 13: return 2 + 45 * 6;\n        case 14: return 2 + 45 * 6;\n        case 15: return 2 + 45 * 5;\n        case 16: return 2 + 45 * 4;\n        case 17: return 2 + 45 * 3;\n        case 18: return 2 + 45 * 2;\n        case 19: return 2 + 45 * 1;\n        default: return 0;\n    }\n}\n\nfunction getIconYPlacement(elementOrder: number) {\n    switch (elementOrder) {\n        case 0: return 2;\n        case 1: return 2 + 47;\n        case 2: return 2 + 47 * 2;\n        case 3: return 2 + 47 * 3;\n        case 4: return 2 + 47 * 4;\n        case 5: return 2 + 47 * 4;\n        case 6: return 2 + 47 * 4;\n        case 7: return 2 + 47 * 4;\n        case 8: return 2 + 47 * 4;\n        case 9: return 2 + 47 * 4;\n        case 10: return 2 + 47 * 4;\n        case 11: return 2 + 47 * 3;\n        case 12: return 2 + 47 * 2;\n        case 13: return 2 + 47 * 1;\n        case 14: return 2 + 47;\n        case 15: return 2 + 47;\n        case 16: return 2 + 47;\n        case 17: return 2 + 47;\n        case 18: return 2 + 47;\n        case 19: return 2 + 47;\n        default: return 0;\n    }\n}\n\nclass StoryMessage {\n    sender: string;\n    message: string; \n\n    constructor(sender: string, message: string) {\n        this.sender = sender;\n        this.message = message;\n    }\n}\n\n\nlet roomName: string = 'UNNAMED'\nlet brainInitialized: boolean = false;\nconst registeredElements: RoomElement[] = [];\nconst uncheckedStoryMessages: StoryMessage[] = [];\nlet storyMessageReceivedHandler: (sender: string, message: string) => void;\n\n// A block that sets up the story brain with a room name and radio group unique in the vicinity.\n/*export*/ function initialiseBrain(room: string, radioGroup: number) {\n    initialise(room, radioGroup);\n}\n\n//% block=\"On Story Message Received\"\n//% draggableParameters=\"reporter\"\n// NOTE TO SELF: This is supposed to set up the event block for when a new processed message is available to the user.\n/*export*/ function onStoryMessageReceived(handler: (sender: string, message: string) => void) {\n    storyMessageReceivedHandler = handler;\n}\n\n// Ensures that an element is kept up to date in the registeredElements array.\nfunction registerElement(name: string, imageCode: string = null) {\n    for (let element of registeredElements) {\n        if (element.name.toUpperCase() === name) {\n            element.updateCheckInTime();\n            return;\n        }\n    }\n    registeredElements.push(new RoomElement(name, imageCode));\n}\n\n// Capture and process all radio messages coming in as strings.\n/*\n/ Check-in messages are formatted as follows:   [room name]*[element name]\n/ Check-in messages can also be formatted to give an image:   [room name]*[element name]*I*[image code]\n/ Trigger messages are formatted as follows:   [room name]*[element name]*[message]\n/\n/ room name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all escape rooms in the vicinity.\n/ element name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all elements in this escape room.\n/ message is a string of no more than 9 characters. Asterisk not allowed.\n/\n/ Case is always ignored when comparing, so names and IDs must be unique ignoring case.\n*/\nradio.onReceivedString(function(receivedString: string) {\n    if (!brainInitialized) {\n        return;\n    }    \n    \n    let messageParts: string[] = receivedString.split('*');\n    \n    // If the received string could not be split, ignore it.\n    if (messageParts.length <= 1) {\n        return;\n    }\n    // If the room name doesn't match, ignore it.\n    if (messageParts[0].toUpperCase() != roomName.toUpperCase()) {\n        return;\n    }\n    // Process a basic check-in string.\n    if (messageParts.length == 2) {\n        registerElement(messageParts[1]);\n        return;\n    }\n    // Process an advanced check-in string.\n    if (messageParts.length == 4) {\n        registerElement(messageParts[1], messageParts[3]);\n        return;\n    }\n    registerElement(messageParts[1]);\n    // Process a true story message, but ignore if there is already an unchecked message from that element.\n    for (let message of uncheckedStoryMessages) {\n        if (message.sender.toUpperCase() == messageParts[1].toUpperCase()) {\n            return;\n        }\n    }\n    uncheckedStoryMessages.unshift(new StoryMessage(messageParts[1], messageParts[2]));\n});\n\n// Sets up the story brain with a room name and radio group unique in the vicinity.\n// Must be called before other functions will work.\nfunction initialise(room: string, radioGroup: number) {\n    roomName = room;\n    radio.setGroup(radioGroup);\n    lcdInitIIC();\n    lcdClearAll();\n    lcdSetBgcolor(lcdGetRgbColor(0, 0, 0));\n    lcdDisplayImage(250, '/escape room icon/story_brain.png', 123, 71, 255);\n    lcdDisplayText(roomName, 251, 123, 143, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n    brainInitialized = true;\n}\n\n// Test everything.\ninitialise('Mars', 10);\nregisterElement('box1', 'BOX');\nregisterElement('box2', 'BOX');\nregisterElement('box3', 'BOX');\nuncheckedStoryMessages.unshift(new StoryMessage('box1', 'hello'));\nuncheckedStoryMessages.unshift(new StoryMessage('box2', 'yo'));\nuncheckedStoryMessages.unshift(new StoryMessage('box3', 'hi!'));\n\nwhile(true) {\n    basic.pause(100);\n    \n    // If there are new story messages, fire the event with the oldest unchecked message popped.\n    if (uncheckedStoryMessages.length > 0) {\n        // NOTE TO SELF: For some reason, we have to check that the handler is not null before firing it. Right now, it never gets fired...\n        if (storyMessageReceivedHandler != null) {\n            let nextUncheckedMessage = uncheckedStoryMessages.pop();\n            storyMessageReceivedHandler(nextUncheckedMessage.sender, nextUncheckedMessage.message);\n        }\n    }    \n\n    // Update elements on screen.\n    for (let i = 0; i < registeredElements.length; i++) {\n        let widgetOrder = (i + 1) * 3;        \n        let path = registeredElements[i].image.getFilePath(false);\n        let textColour = lcdGetRgbColor(255, 255, 255)\n        if (registeredElements[i].isStale()) {\n            path = registeredElements[i].image.getFilePath(true);\n            textColour = lcdGetRgbColor(128, 128, 128)\n        }\n        lcdDisplayImage(widgetOrder + 1, path, getIconXPlacement(i), getIconYPlacement(i), 255);\n        lcdDisplayText(registeredElements[i].name, widgetOrder + 2, getIconXPlacement(i) + 6, getIconYPlacement(i) + 46 - 2 - 18, FontSize.Small, textColour);\n        // TODO: Draw a line if there is an unchecked message from that element.\n        //lcdDrawLine(widgetOrder, getIconXPlacement(i) + 23, getIconYPlacement(i) + 23, 159, 119, 5, lcdGetRgbColor(0, 255, 0));\n    }\n}\n\n// NOTE TO SELF: This is just testing the function/block made above. This wouldn't be included in the extension.\nonStoryMessageReceived(function(sender, message) {\n    basic.showString(message);\n})","README.md":"","pxt.json":"{\n    \"name\": \"story brain experiments\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1761866871466,"editorVersion":"8.0.18","text":{"main.ts":"    // --------------------------------------\n    // Code from DFRobot lcdDisplay extension\n    // --------------------------------------\n    // Original code has MIT license and copyright (c) 2021 TgJe.\n    // Available at: https://github.com/DFRobot/pxt-DFRobot_lcdDisplay\n    // Modified to hide blocks that access display directly.\n\n    const enum LCDWidgetCategoryOne {\n        Slider = 1,\n        Bar = 2,\n        Compass = 3,\n        Gauge = 4,\n        LineMeter = 5,\n    }\n\n    const enum LCDWidgetCategoryTwo {\n        Slider = 1,\n        Bar = 2,\n        Compass = 3,\n        Gauge = 4,\n        LineMeter = 5,\n        Chart = 6,\n        Text = 7,\n        Line = 8,\n        Rectangle = 9,\n        Circle = 10,\n        Triangle = 11,\n        Icon = 12,\n        Gif = 13,\n    }\n\n    enum FontSize {\n        Large = 1,\n        Small = 2,\n    }\n\n    enum RectangleRound {\n        IsRound = 1,\n        NoneRound = 2,\n    }\n\n    enum ChartStyles {\n        LineChart = 3,\n        BarChart = 2,\n        ShadingLineChart = 1,\n    }\n\n    enum DrawType {\n        Fill = 1,\n        NotFill = 2,\n    }\n\n    enum Protocol {\n        IIC = 1,\n        Serial = 2,\n    }\n\n    const IIC_MAX_TRANSFER_SIZE = 32;\n\n    // cmd len\n    const CMDLEN_OF_HEAD_LEN = 3;\n    const CMD_DELETE_OBJ_LEN = 0x06;\n    const CMD_SET_TOP_OBJ_LEN = 0x06;\n    const CMD_SET_COMPASS_VALUE_LEN = 0x07;\n    const CMD_SET_LEN = 0x07;\n    const CMD_SET_GAUGE_VALUE_LEN = 0x07;\n    const CMD_SET_LINE_METER_VALUE_LEN = 0x07;\n    const CMD_SET_BAR_VALUE_LEN = 0x07;\n    const CMD_SET_SLIDER_VALUE_LEN = 0x07;\n    const CMD_SET_ANGLE_OBJ_LEN = 0x08;\n    const CMD_DRAW_COMPASS_LEN = 0x0B;\n    const CMD_DRAW_CHART_LEN = 0x09;\n    const CMD_DRAW_SERIE_LEN = 0x09;\n    const CMD_OF_DRAW_ICON_INTERNAL_LEN = 0x0D;\n    const CMD_OF_DRAW_GIF_INTERNAL_LEN = 0x0D;\n    const CMD_OF_DRAW_BAR_LEN = 0x10;\n    const CMD_OF_DRAW_SLIDER_LEN = 0x10;\n    const CMD_DRAW_PIXEL_LEN = 0x11;\n    const CMD_DRAW_LINE_LEN = 0x11;\n    const CMD_OF_DRAW_CIRCLE_LEN = 0x13;\n    const CMD_OF_DRAW_GAUGE_LEN = 0x15;\n    const CMD_OF_DRAW_LINE_METER_LEN = 0x15;\n    const CMD_OF_DRAW_RECT_LEN = 0x16;\n    const CMD_OF_DRAW_TRIANGLE_LEN = 0x19;\n\n    // cmd\n    const CMD_SET_BACKGROUND_COLOR = 0x19;\n    const CMD_SET_BACKGROUND_IMG = 0x1A;\n    const CMD_OF_DRAW_PIXEL = 0x02;\n    const CMD_OF_DRAW_LINE = 0x03;\n    const CMD_OF_DRAW_RECT = 0x04;\n    const CMD_OF_DRAW_CIRCLE = 0x06;\n    const CMD_OF_DRAW_TRIANGLE = 0x07;\n    const CMD_OF_DRAW_ICON_INTERNAL = 0x08;\n    const CMD_OF_DRAW_ICON_EXTERNAL = 0x09;\n    const CMD_OF_DRAW_BAR = 0x0A;\n    const CMD_OF_DRAW_BAR_VALUE = 0x0B;\n    const CMD_OF_DRAW_SLIDER = 0x0C;\n    const CMD_OF_DRAW_SLIDER_VALUE = 0x0D;\n    const CMD_OF_DRAW_LINE_METER = 0x10;\n    const CMD_OF_DRAW_LINE_METER_VALUE = 0x11;\n    const CMD_OF_DRAW_COMPASS = 0x0E;\n    const CMD_OF_DRAW_COMPASS_VALUE = 0x0F;\n    const CMD_OF_DRAW_GAUGE = 0x12;\n    const CMD_OF_DRAW_GAUGE_VALUE = 0x13;\n    const CMD_OF_DRAW_LINE_CHART = 0x14;\n    const CMD_OF_DRAW_LINE_CHART_TEXT = 0x15;\n    const CMD_OF_DRAW_SERIE = 0x16;\n    const CMD_OF_DRAW_SERIE_DATA = 0x17;\n    const CMD_OF_DRAW_TEXT = 0x18;\n    const CMD_DELETE_OBJ = 0x1B;\n    const CMD_SET_TOP_OBJ = 0x1C;\n    const CMD_SET_ANGLE_OBJ = 0x1E;\n    const CMD_OF_DRAW_GIF_INTERNAL = 0x1F;\n    const CMD_OF_DRAW_GIF_EXTERNAL = 0x20;\n\n    const CMD_HEADER_HIGH = 0x55;\n    const CMD_HEADER_LOW = 0xaa;\n\n    let address = 0x2c;\n    class GenericNode {\n        id: number\n        next: GenericNode\n        constructor(id: number) {\n            this.id = id;\n            this.next = null;\n        }\n    }\n\n    class LinkedList {\n        head: GenericNode\n        size: number\n        id: number\n        constructor() {\n            this.head = null;\n            this.size = 0;\n            this.id = 1;\n        }\n\n        // adds a node to the end of the linked list\n        append() {\n            const newNode = new GenericNode(this.id);\n            if (this.head == null) {\n                this.head = newNode;\n            } else {\n                let current = this.head;\n                while (current.next != null) {\n                    current = current.next;\n                }\n                current.next = newNode;\n            }\n            this.size++;\n            this.id++;\n        }\n        // insert a node at a specific location\n        insert(index: number, id: number): boolean {\n            if (index < 0 || index > this.size) {\n                return false;\n            }\n            const newNode = new GenericNode(id);\n            if (index == 0) {\n                newNode.next = this.head;\n                this.head = newNode;\n            } else {\n                let current = this.head;\n                let previous = null;\n                let i = 0;\n                while (i < index) {\n                    previous = current;\n                    current = current.next;\n                    i++;\n                }\n                newNode.next = current;\n                previous.next = newNode;\n            }\n            this.size++;\n            return true;\n        }\n        // removes a node at a specific location\n        removeAt(index: number): boolean {\n            if (index < 0 || index >= this.size || this.head == null) {\n                return false;\n            }\n            let current = this.head;\n            if (index == 0) {\n                this.head = current.next;\n            } else {\n                let previous = null;\n                let i = 0;\n                while (i < index) {\n                    previous = current;\n                    current = current.next;\n                    i++;\n                }\n                previous.next = current.next;\n            }\n            this.size--;\n            return true;\n        }\n\n        // example Remove a node with a specific id\n        removeId(id: number): boolean {\n            if (this.head == null) {\n                return false;\n            }\n            let current = this.head;\n            if (current.id == id) {\n                this.head = current.next;\n            } else {\n                let previous = null;\n                while (current.id != id) {\n                    previous = current;\n                    current = current.next;\n                }\n                previous.next = current.next;\n            }\n            this.size--;\n            return true;\n        }\n    }\n\n    type GenericList = {\n        lineChartHead: LinkedList | null,\n        seriesHead: LinkedList | null,\n        compassHead: LinkedList | null,\n        textHead: LinkedList | null,\n        gaugeHead: LinkedList | null,\n        lineHead: LinkedList | null,\n        rectHead: LinkedList | null,\n        circleHead: LinkedList | null,\n        triangleHead: LinkedList | null,\n        lineMeterHead: LinkedList | null,\n        barHead: LinkedList | null,\n        sliderHead: LinkedList | null,\n        iconHead: LinkedList | null,\n        gifHead: LinkedList | null,\n    }\n\n    let list: GenericList = {\n        lineChartHead: null,\n        seriesHead: null,\n        compassHead: null,\n        textHead: null,\n        gaugeHead: null,\n        lineHead: null,\n        rectHead: null,\n        circleHead: null,\n        triangleHead: null,\n        lineMeterHead: null,\n        barHead: null,\n        sliderHead: null,\n        iconHead: null,\n        gifHead: null,\n    }\n    let protocol: Protocol = Protocol.IIC;\n    let chartID = 0;\n    let axisListX: string[] = [];\n    let axisListY: string[] = [];\n    let axisYData: number[] = [];\n    let seriesData: any = {};\n    let dataFactor = 1; // \"data coordinate conversion factors\n\n    /**\n     * Original block \"ColorScreen I2C initialization\"\n     */\n    function lcdInitIIC() {\n        creatList();\n        protocol = Protocol.IIC;\n        basic.pause(1000);\n    }\n\n    /**\n     * Original block \"clear the screen\"\n     */\n    function lcdClearAll() {\n        cleanScreen();\n    }\n\n    /**\n     * Original block \"set the background color %color\"\n     * @param color to color ,eg: 0xFF0000\n     */\n    function lcdSetBgcolor(color: number) {\n        setBackgroundColor(colorToCustom(color));\n    }\n\n    /**\n     * Original block \"red %red green %green blue %blue\"\n     * Convert red, green and blue channels into a RGB color\n     * @param red to red ,eg: 255 (min 0, max 255, default 255)\n     * @param green to green ,eg: 255 (min 0, max 255, default 255)\n     * @param blue to blue ,eg: 255 (min 0, max 255, default 255)\n     */\n    function lcdGetRgbColor(red: number, green: number, blue: number): number {\n        return (red << 16) + (green << 8) + (blue);\n    }\n\n    /**\n     * Original block \"set the background picture %picture\"\n     * @param picture to picture ,eg: \"fruit.png\"\n     */\n    function lcdSetBgIamge(picture: string) {\n        //setBackgroundImg(0, picture); // Internal storage of pictures\n        setBackgroundImg(1, picture); // Usb flash drive to store pictures\n    }\n\n    /**\n     * Original block \"display text %text number %num position x: %x y: %y size %size color %color\"\n     * @param text to text ,eg: \"hello\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 120 (min 0, max 320, default 120)\n     * @param y to y ,eg: 120 (min 0, max 240, default 120)\n     * @param size to size ,eg: FontSize.Large\n     * @param color to color ,eg: 0xFF0000\n     */\n    function lcdDisplayText(text: string, num: number, x: number, y: number, size: FontSize, color: number) {\n        updateString(num, x, y, text, size, color);\n    }\n\n    /**\n     * Original block \"display time number %num time %time position x: %x y: %y size %size color %color\"\n     * Was marked as deprecated.\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param time to time ,eg: \"12:40:30\"\n     * @param x to x ,eg: 120 (min 0, max 320, default 120)\n     * @param y to y ,eg: 120 (min 0, max 320, default 120)\n     * @param size to size ,eg: FontSize.Large\n     * @param color to color ,eg: 0xFF0000\n     */\n    function lcdDisplayTime(num: number, time: string, x: number, y: number, size: FontSize, color: number) {\n        updateString(num, x, y, time, size, color);\n    }\n\n    /**\n     * Original block \"hour %hour minutes %min second %sec\"\n     * @param hour to hour ,eg: 12 (min 0, max 23, default 12)\n     * @param min to min ,eg: 40 (min 0, max 59, default 40)\n     * @param sec to sec ,eg: 30 (min 0, max 59, default 30)\n     */\n    function lcdGetTime(hour: number, min: number, sec: number): string {\n        return `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`\n    }\n\n    /**\n     * Original block \"display image number %num name %name position x: %x y: %y size %size\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param name to name ,eg: \"/expression icon/happy.png\"\n     * @param x to x ,eg: 120 (min 0, max 320, default 120)\n     * @param y to y ,eg: 120 (min 0, max 320, default 120)\n     * @param size to size ,eg: FontSize.Large\n     */\n    function lcdDisplayImage(num: number, name: string, x: number, y: number, size: number) {\n        updateIcon(num, x, y, name, size);\n    }\n\n    /**\n     * Original block \"rotate image number %num angle %angle\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param angle to angle ,eg: 180 (min 0, max 360, default 180)\n     */\n    function lcdRotateIamge(num: number, angle: number) {\n        setAngleIcon(num, angle * 10);\n    }\n\n    /**\n     * Original block \"display gif number %num name %name position x: %x y: %y size %size\"\n     * @param num to num ,eg: 1\n     * @param name to name ,eg: \"Snowy.gif\"\n     * @param x to x ,eg: 120 (min 0, max 320, default 120)\n     * @param y to y ,eg: 120 (min 0, max 320, default 120)\n     * @param size to size ,eg: FontSize.Large\n     */\n    function lcdDisplayGif(num: number, name: string, x: number, y: number, size: number) {\n        updateGif(num, x, y, name, size);\n    }\n\n    /**\n     * Original block \"draw line number %num start x1: %x1 y1: %y1 end x2: %x2 y2: %y2 width %width color %color\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x1 to x1 ,eg: 40 (min 0, max 320, default 40)\n     * @param y1 to y1 ,eg: 120 (min 0, max 240, default 120)\n     * @param x2 to x2 ,eg: 300 (min 0, max 320, default 300)\n     * @param y2 to y2 ,eg: 120 (min 0, max 240, default 120)\n     * @param width to width ,eg: 20\n     * @param color to color ,eg: 0x007FFF\n     */\n    function lcdDrawLine(num: number, x1: number, y1: number, x2: number, y2: number, width: number, color: number) {\n        updateLine(num, x1, y1, x2, y2, width, color);\n    }\n\n    /**\n     * Original block \"draw rectangle number %num start x: %x y: %y width %w height %h line width %width Border color %bocolor %fill color %fcolor %round\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 0 (min 0, max 320, default 0)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param w to w ,eg: 300 (min 0, max 320, default 300)\n     * @param h to h ,eg: 200 (min 0, max 240, default 200)\n     * @param width to width ,eg: 5\n     * @param bocolor to bocolor ,eg: 0xFF0000\n     * @param fill to fill ,eg: DrawType.Fill\n     * @param fcolor to fcolor ,eg: 0xFFFFFF\n     * @param round to round ,eg: lcdDisplay.RectangleRound.NoneRound\n     */\n    function lcdDrawRectangle(num: number, x: number, y: number, w: number, h: number, width: number, bocolor: number, fill: DrawType, fcolor: number, round: RectangleRound) {\n        updateRect(num, x, y, w, h, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor, round === RectangleRound.IsRound ? 1 : 0);\n    }\n\n    /**\n     * Original block \"draw circle number %num center x: %x y: %y radius %r line width %width Border color %bocolor %fill color %fcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 160 (min 0, max 320, default 160)\n     * @param y to y ,eg: 120 (min 0, max 240, default 120)\n     * @param r to r ,eg: 120 (min 0, max 120, default 120)\n     * @param width to width ,eg: 5\n     * @param bocolor to bocolor ,eg: 0xFF0000\n     * @param fill to fill ,eg: DrawType.Fill\n     * @param fcolor to fcolor ,eg: 0xFFFFFF\n     */\n    function lcdDrawCircle(num: number, x: number, y: number, r: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n        updateCircle(num, x, y, r, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n    }\n\n    /**\n     * Original block \"draw triangle number %num x1: %x1 y1: %y1 x2: %x2 y2: %y2 x3: %x3 y3: %y3 line width %width Border color %bocolor %fill color %fcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x1 to x1 ,eg: 160 (min 0, max 320, default 160)\n     * @param y1 to y1 ,eg: 0 (min 0, max 240, default 0)\n     * @param x2 to x2 ,eg: 0 (min 0, max 320, default 0)\n     * @param y2 to y2 ,eg: 240 (min 0, max 240, default 240)\n     * @param x3 to x3 ,eg: 320 (min 0, max 320, default 320)\n     * @param y3 to y3 ,eg: 240 (min 0, max 240, default 240)\n     * @param width to width ,eg: 5\n     * @param bocolor to bocolor ,eg: 0xFF0000\n     * @param fill to fill ,eg: DrawType.Fill\n     * @param fcolor to fcolor ,eg: 0xFFFFFF\n     */\n    function lcdDrawTriangle(num: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n        updateTriangle(num, x1, y1, x2, y2, x3, y3, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n    }\n\n    /**\n     * Original block \"draw slider number %num position x: %x y: %y width %w height %h color %color\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 80 (min 0, max 320, default 80)\n     * @param y to y ,eg: 120 (min 0, max 240, default 120)\n     * @param w to w ,eg: 200 (min 0, max 320, default 200)\n     * @param h to h ,eg: 20 (min 0, max 240, default 20)\n     * @param color to color ,eg: 0x007FFF\n     */\n    function lcdDrawSlider(num: number, x: number, y: number, w: number, h: number, color: number) {\n        updateSlider(num, x, y, w, h, color);\n    }\n\n    /**\n     * Original block \"draw bar number %num position x: %x y: %y width %w height %h color %color\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 80 (min 0, max 320, default 80)\n     * @param y to y ,eg: 120 (min 0, max 240, default 120)\n     * @param w to w ,eg: 200 (min 0, max 320, default 200)\n     * @param h to h ,eg: 20 (min 0, max 240, default 20)\n     * @param color to color ,eg: 0x007FFF\n     */\n    function lcdDrawBar(num: number, x: number, y: number, w: number, h: number, color: number) {\n        updateBar(num, x, y, w, h, color);\n    }\n\n    /**\n     * Original block \"draw compass number %num position x: %x y: %y radius %r\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 50 (min 0, max 320, default 50)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     */\n    function lcdDrawCompass(num: number, x: number, y: number, r: number) {\n        updateCompass(num, x, y, r);\n    }\n\n    /**\n     * Original block \"draw gauge number %num position x: %x y: %y radius %r start of scale %start End of scale %end Pointer color %color Dial color %dcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 50 (min 0, max 320, default 50)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     * @param start to start ,eg: 0 (min 0, max 360, default 0)\n     * @param end to end ,eg: 360 (min 0, max 360, default 360)\n     * @param color to color ,eg: 0x000000\n     * @param dcolor to dcolor ,eg: 0xFFFFFF\n     */\n    function lcdDrawGauge(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n        updateGauge(num, x, y, r, start, end, color, dcolor);\n    }\n\n    /**\n     * Original block \"draw lineMeter number %num position x: %x y: %y radius %r start of scale %start End of scale %end Data color %color Dial color %dcolor\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param x to x ,eg: 0 (min 0, max 320, default 0)\n     * @param y to y ,eg: 0 (min 0, max 240, default 0)\n     * @param r to r ,eg: 240 (min 0, max 320, default 240)\n     * @param start to start ,eg: 0 (min 0, max 360, default 0)\n     * @param end to end ,eg: 100 (min 0, max 360, default 100)\n     * @param color to color ,eg: 0x000000\n     * @param dcolor to dcolor ,eg: 0xFFFFFF\n     */\n    function lcdDrawLineMeter(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n        updateLineMeter(num, x, y, r, start, end, color, dcolor);\n    }\n\n    /**\n     * Original block \"set %type=LCDWidgetCategoryOne_conv widget number %num data %data\"\n     * @param type to type ,eg: LCDWidgetCategoryOne.Slider\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param data to data ,eg: 80\n     */\n    function lcdSetWidgetData(type: number, num: number, data: number) {\n        switch (type) {\n            case LCDWidgetCategoryOne.Slider:\n                setSliderValue(num, data);\n                break;\n            case LCDWidgetCategoryOne.Bar:\n                setBarValue(num, data);\n                break;\n            case LCDWidgetCategoryOne.Compass:\n                setCompassScale(num, (data / 360) * 3600);\n                break;\n            case LCDWidgetCategoryOne.Gauge:\n                setGaugeValue(num, data);\n                break;\n            case LCDWidgetCategoryOne.LineMeter:\n                setMeterValue(num, data);\n                break;\n            default:\n                break;\n        }\n    }\n\n    /**\n     * Original block \"draw chart number %num X-axis %xaxis Y-axis %yaxis background color %color styles %styles\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param xaxis to xaxis ,eg: \"Jan Feb Mar Apr May Jun\"\n     * @param yaxis to yaxis ,eg: \"100 80 60 40 20 0\"\n     * @param color to color ,eg: 0xFFFFFF\n     * @param styles to styles ,eg: ChartStyles.LineChart\n     */\n    function lcdDrawChart(num: number, xaxis: string, yaxis: string, color: number, styles: ChartStyles) {\n        chartID = num;\n        axisListX = xaxis.split(\" \");\n        axisListY = yaxis.split(\" \");\n        axisListX.forEach((value, index) => { axisYData.push(0) });\n        dataFactor = Math.abs((parseInt(axisListY[0]) - parseInt(axisListY[axisListY.length - 1])) / 100);\n        updateChart(chartID, color, styles);\n        basic.pause(100);\n        setChartAxisTexts(chartID, 0, axisListX);\n        basic.pause(100);\n        setChartAxisTexts(chartID, 1, axisListY);\n    }\n\n    /**\n     * Original block \"Set chart data number %num color %color\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param color to color ,eg: 0xFF0000\n     */\n    function lcdAddChartData(num: number, color: number) {\n        seriesData[num] = axisYData;\n        updateChartSeries(chartID, num, color);\n        addChartSeriesData(chartID, num, seriesData[num], axisListX.length)\n    }\n\n    /**\n     * Original block \"set chart data number %num X-axis %xaxis data %data\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param xaxis to xaxis ,eg: \"Jan\"\n     * @param data to data ,eg: 80\n     */\n    function lcdSetChartData(num: number, xaxis: string, data: number) {\n        let index = axisListX.indexOf(xaxis);\n        if (data < parseInt(axisListY[axisListY.length - 1]) || data > parseInt(axisListY[0]))\n            return\n        if (index !== -1) {\n            updateChartPoint(chartID, num, index, Math.round((data - parseInt(axisListY[axisListY.length - 1])) / dataFactor));\n            // seriesData[num][index] = Math.round(data / 10);\n        }\n    }\n\n    /**\n     * Original block \"update chart number %num background color %color styles %styles\"\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     * @param color to color ,eg: 0x007FFF\n     * @param styles to styles ,eg: lcdDisplay.ChartStyles.BarChart\n     */\n    function lcdUpdateChart(num: number, color: number, styles: ChartStyles) {\n        updateChart(num, color, styles);\n    }\n\n    /**\n     * Original block \"delete %type=LCDWidgetCategoryTwo_conv number %num\"\n     * @param type to type ,eg: LCDWidgetCategoryTwo.Text\n     * @param num to num ,eg: 1 (min 1, max 255, default 1)\n     */\n    function lcdDeleteWidget(type: number, num: number) {\n        switch (type) {\n            case LCDWidgetCategoryTwo.Slider:\n                deleteSlider(num);\n                break;\n            case LCDWidgetCategoryTwo.Bar:\n                deleteBar(num);\n                break;\n            case LCDWidgetCategoryTwo.Compass:\n                deleteCompass(num);\n                break;\n            case LCDWidgetCategoryTwo.Gauge:\n                deleteGauge(num);\n                break;\n            case LCDWidgetCategoryTwo.LineMeter:\n                deleteLineMeter(num);\n                break;\n            case LCDWidgetCategoryTwo.Chart:\n                deleteChart(num);\n                break;\n            case LCDWidgetCategoryTwo.Text:\n                deleteString(num);\n                break;\n            case LCDWidgetCategoryTwo.Line:\n                deleteLine(num);\n                break;\n            case LCDWidgetCategoryTwo.Rectangle:\n                deleteRect(num);\n                break;\n            case LCDWidgetCategoryTwo.Circle:\n                deleteCircle(num);\n                break;\n            case LCDWidgetCategoryTwo.Triangle:\n                deleteTriangle(num);\n                break;\n            case LCDWidgetCategoryTwo.Icon:\n                deleteIcon(num);\n                break;\n            case LCDWidgetCategoryTwo.Gif:\n                deleteGif(num);\n            default:\n                break;\n        }\n    }\n\n    /**\n     * Original blockId \"LCDWidgetCategoryOne_conv\" and block \"%item\"\n     * return the corresponding LCDWidgetCategoryOne number\n     */\n    function getWidgetCategoryOne(item: LCDWidgetCategoryOne): number {\n        return item as number;\n    }\n\n    /**\n     * Original blockId \"LCDWidgetCategoryTwo_conv\" and block \"%item\"\n     * return the corresponding LCDWidgetCategoryTwo number\n     */\n    function getLCDWidgetCategoryTwo(item: LCDWidgetCategoryTwo): number {\n        return item as number;\n    }\n\n    function cleanScreen() {\n        let cmd = creatCommand(0x1D, 0x04);\n        writeCommand(cmd, 4);\n        basic.pause(1500);\n    }\n\n    function setBackgroundColor(color: number) {\n        let cmd = creatCommand(CMD_SET_BACKGROUND_COLOR, CMD_SET_LEN);\n        cmd = cmd.concat(data24Tobyte(color));\n        writeCommand(cmd, CMD_SET_LEN);\n        basic.pause(300);\n    }\n\n    function setBackgroundImg(location: number, str: string) {\n        let len = str.length;\n        let cmd = creatCommand(CMD_SET_BACKGROUND_IMG, len + 5);\n        cmd = cmd.concat([location]);\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 5);\n    }\n\n    function drawString(x: number, y: number, str: string, fontSize: number, color: number) {\n        let len = str.length > 242 ? 242 : str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_TEXT), fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 13);\n    }\n\n    function updateString(id: number, x: number, y: number, str: string, fontSize: number, color: number) {\n        let len = str.length > 242 ? 242 : str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n        cmd = cmd.concat([id, fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 13);\n    }\n\n    function deleteString(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_TEXT, id])\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.textHead, id);\n    }\n\n    function drawLcdTime(x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n        drawString(x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n    }\n\n    function updateLcdTime(id: number, x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n        updateString(id, x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n    }\n\n    function drawIcon(x: number, y: number, str: string, zoom: number) {\n        let len = str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_ICON_INTERNAL)]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 11);\n    }\n\n    function setAngleIcon(id: number, angle: number) {\n        let cmd = creatCommand(CMD_SET_ANGLE_OBJ, CMD_SET_ANGLE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]).concat(data16Tobyte(angle));\n        writeCommand(cmd, CMD_SET_ANGLE_OBJ_LEN);\n    }\n\n    function updateIcon(id: number, x: number, y: number, str: string, zoom: number) {\n        let len = str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n        cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 11);\n    }\n\n    function deleteIcon(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.iconHead, id);\n    }\n\n    function drawGif(x: number, y: number, str: string, zoom: number): number {\n        let len = str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n        let id = getID(CMD_OF_DRAW_GIF_EXTERNAL);\n        cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 11);\n        return id;\n    }\n\n    function updateGif(id: number, x: number, y: number, str: string, zoom: number) {\n        let len = str.length;\n        let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n        cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n        writeCommand(cmd, len + 11);\n    }\n\n    function deleteGif(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_GIF_INTERNAL, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.gifHead, id);\n    }\n\n    function drawLine(x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_LINE), width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n        writeCommand(cmd, CMD_DRAW_LINE_LEN);\n    }\n\n    function updateLine(id: number, x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n        cmd = cmd.concat([id, width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n        writeCommand(cmd, CMD_DRAW_LINE_LEN);\n        basic.pause(10);\n    }\n\n    function deleteLine(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.lineHead, id);\n    }\n\n    function drawRect(x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_RECT), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n    }\n\n    function updateRect(id: number, x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n        cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n    }\n\n    function deleteRect(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_RECT, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.rectHead, id);\n    }\n\n    function drawCircle(x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_CIRCLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n    }\n\n    function updateCircle(id: number, x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n        cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n    }\n\n    function deleteCircle(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_CIRCLE, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.circleHead, id);\n    }\n\n    function drawTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_TRIANGLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n        writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n    }\n\n    function updateTriangle(id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n        cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n        writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n    }\n\n    function deleteTriangle(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_TRIANGLE, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.triangleHead, id);\n    }\n\n    function creatSlider(x: number, y: number, w: number, h: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_SLIDER)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n    }\n\n    function updateSlider(id: number, x: number, y: number, w: number, h: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n        cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n    }\n\n    function setSliderValue(id: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SLIDER_VALUE, CMD_SET_SLIDER_VALUE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(value));\n        writeCommand(cmd, CMD_SET_SLIDER_VALUE_LEN);\n    }\n\n    function deleteSlider(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_SLIDER, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.sliderHead, id);\n    }\n\n    function creatBar(x: number, y: number, w: number, h: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_BAR)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n    }\n\n    function updateBar(id: number, x: number, y: number, w: number, h: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n        cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n        writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n    }\n\n    function setBarValue(id: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_BAR_VALUE, CMD_SET_BAR_VALUE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(value));\n        writeCommand(cmd, CMD_SET_BAR_VALUE_LEN);\n    }\n\n    function deleteBar(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_BAR, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.barHead, id);\n    }\n\n    function creatCompass(x: number, y: number, diameter: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_COMPASS)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n    }\n\n    function updateCompass(id: number, x: number, y: number, diameter: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n    }\n\n    function setCompassScale(id: number, scale: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_COMPASS_VALUE, CMD_SET_COMPASS_VALUE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(scale));\n        writeCommand(cmd, CMD_SET_COMPASS_VALUE_LEN);\n    }\n\n    function deleteCompass(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_COMPASS, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.compassHead, id);\n    }\n\n    function creatGauge(x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_GAUGE)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n    }\n\n    function updateGauge(id: number, x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n    }\n\n    function setGaugeValue(id: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_GAUGE_VALUE, CMD_SET_GAUGE_VALUE_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(value));\n        writeCommand(cmd, CMD_SET_GAUGE_VALUE_LEN);\n    }\n\n    function deleteGauge(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_GAUGE, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.gaugeHead, id);\n    }\n\n    function creatLineMeter(x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n        cmd = cmd.concat([getID(CMD_OF_DRAW_LINE_METER)]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n    }\n\n    function updateLineMeter(id: number, x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n        cmd = cmd.concat([id]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n        writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n    }\n\n    function setTopLineMeter(id: number) {\n        let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    }\n\n    function deleteLineMeter(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.lineMeterHead, id);\n    }\n\n    function creatChart(strX: string[], strY: string[], bgColor: number, type: number): number {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n        let id = getID(CMD_OF_DRAW_LINE_CHART);\n        cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n        writeCommand(cmd, CMD_DRAW_CHART_LEN);\n        basic.pause(100);\n        setChartAxisTexts(id, 0, strX);\n        basic.pause(100);\n        setChartAxisTexts(id, 1, strY);\n        return id;\n    }\n\n    function updateChart(id: number, bgColor: number, type: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n        cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n        writeCommand(cmd, CMD_DRAW_CHART_LEN);\n    }\n\n    function creatChartSeries(chartId: number, color: number): number {\n        let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n        let serieId = getID(CMD_OF_DRAW_SERIE);\n        cmd = cmd.concat([serieId, chartId]).concat(data24Tobyte(color));\n        writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n        return serieId;\n    }\n\n    function updateChartSeries(chartId: number, seriesId: number, color: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n        cmd = cmd.concat([seriesId, chartId]).concat(data24Tobyte(color));\n        writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n    }\n\n    function setChartAxisTexts(chartId: number, axis: number, text: string[]) {\n        let len = text.length - 1;\n        text.forEach((value, index) => { len = len + value.length });\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART_TEXT, len + 6);\n        cmd = cmd.concat([chartId, axis]);\n        for (let i = 0; i < text.length; i++) {\n            text[i].split(\"\").forEach((value, index) => {\n                cmd.push(value.charCodeAt(0))\n            })\n            if (i != text.length - 1) {\n                cmd.push(0x0A); // \"\\n\"\n            }\n        }\n        writeCommand(cmd, len + 6);\n    }\n\n    function updateChartPoint(chartId: number, seriesId: number, pointNum: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, 10);\n        cmd = cmd.concat([chartId, seriesId, 1, pointNum]).concat(data16Tobyte(value));\n        writeCommand(cmd, 10);\n    }\n\n    function addChartSeriesData(chartId: number, seriesId: number, point: number[], len: number): number {\n        let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, len * 2 + 8);\n        cmd = cmd.concat([chartId, seriesId, 0, 0]);\n        point.forEach((value, index) => { cmd = cmd.concat(data16Tobyte(value)) });\n        writeCommand(cmd, len * 2 + 8);\n        return 1;\n    }\n\n    function setTopChart(id: number) {\n        let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n        writeCommand(cmd, CMD_SET_TOP_OBJ_LEN);\n    }\n\n    function deleteChart(id: number) {\n        let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n        cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n        writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n        deleteNodeByID(list.lineChartHead, id);\n    }\n\n    function setMeterValue(lineMeterId: number, value: number) {\n        let cmd = creatCommand(CMD_OF_DRAW_LINE_METER_VALUE, CMD_SET_LINE_METER_VALUE_LEN);\n        cmd = cmd.concat([lineMeterId]).concat(data16Tobyte(value));\n        writeCommand(cmd, CMD_SET_LINE_METER_VALUE_LEN);\n    }\n\n    /********************************************************************************************************************/\n    function creatList() {\n        list.lineChartHead = new LinkedList();\n        list.seriesHead = new LinkedList();\n        list.compassHead = new LinkedList();\n        list.textHead = new LinkedList();\n        list.gaugeHead = new LinkedList();\n        list.lineHead = new LinkedList();\n        list.rectHead = new LinkedList();\n        list.circleHead = new LinkedList();\n        list.triangleHead = new LinkedList();\n        list.lineMeterHead = new LinkedList();\n        list.barHead = new LinkedList();\n        list.sliderHead = new LinkedList();\n        list.iconHead = new LinkedList();\n        list.gifHead = new LinkedList();\n    }\n\n    function getID(type: number): number {\n        let id = 0;\n        switch (type) {\n            case CMD_OF_DRAW_LINE_CHART:\n                id = getNewID(list.lineChartHead);\n                break;\n            case CMD_OF_DRAW_SERIE:\n                id = getNewID(list.seriesHead);\n                break;\n            case CMD_OF_DRAW_COMPASS:\n                id = getNewID(list.compassHead);\n                break;\n            case CMD_OF_DRAW_TEXT:\n                id = getNewID(list.textHead);\n                break;\n            case CMD_OF_DRAW_GAUGE:\n                id = getNewID(list.gaugeHead);\n                break;\n            case CMD_OF_DRAW_LINE:\n                id = getNewID(list.lineHead);\n                break;\n            case CMD_OF_DRAW_RECT:\n                id = getNewID(list.rectHead);\n                break;\n            case CMD_OF_DRAW_TRIANGLE:\n                id = getNewID(list.triangleHead);\n                break;\n            case CMD_OF_DRAW_CIRCLE:\n                id = getNewID(list.circleHead);\n                break;\n            case CMD_OF_DRAW_LINE_METER:\n                id = getNewID(list.lineMeterHead);\n                break;\n            case CMD_OF_DRAW_BAR:\n                id = getNewID(list.barHead);\n                break;\n            case CMD_OF_DRAW_SLIDER:\n                id = getNewID(list.sliderHead);\n                break;\n            case CMD_OF_DRAW_ICON_INTERNAL:\n                id = getNewID(list.iconHead);\n                break;\n            case CMD_OF_DRAW_GIF_INTERNAL:\n                id = getNewID(list.gifHead);\n                break;\n            default:\n                break;\n        }\n        return id;\n    }\n\n    function getNewID(linkList: LinkedList): number {\n        linkList.append();\n        return linkList.head.id;\n    }\n\n    function deleteNodeByID(linkList: LinkedList, id: number) {\n        linkList.removeId(id);\n    }\n\n    function data16Tobyte(data: number): number[] {\n        return [(data >> 8) & 0xFF, data & 0xFF];\n    }\n\n    function data24Tobyte(data: number): number[] {\n        return [(data >> 16) & 0xFF, (data >> 8) & 0xFF, data & 0xFF];\n    }\n\n    function colorToCustom(color: number): number {\n        switch (color) {\n            case 0x999999:\n                return 0x696969;\n            case 0x7f00ff:\n                return 0x800080;\n            default:\n                return color;\n        }\n    }\n\n    function creatCommand(cmd: number, len: number): number[] {\n        return [CMD_HEADER_HIGH, CMD_HEADER_LOW, len - CMDLEN_OF_HEAD_LEN, cmd];\n    }\n\n    function writeCommand(data: number[], len: number) {\n        // serial.writeNumbers(data);\n        if (protocol == Protocol.IIC) {\n            let remain = len;\n            let i = 0;\n            while (remain > 0) {\n                let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? 32 : remain;\n                if (remain > IIC_MAX_TRANSFER_SIZE) {\n                    pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), true);\n                } else {\n                    pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), false);\n                }\n                remain = remain - currentTransferSize;\n                i = i + 1;\n            }\n        } else {\n        }\n    }\n\n    function readACK(length: number): Buffer {\n        if (protocol == Protocol.IIC) {\n            let remain = length;\n            let buf: Buffer = pins.createBuffer(0);\n            while (remain) {\n                let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? IIC_MAX_TRANSFER_SIZE : remain;\n                buf = buf.concat(pins.i2cReadBuffer(address, currentTransferSize));\n                remain = remain - currentTransferSize;\n            }\n            return buf;\n        } else {\n            let buf: Buffer = pins.createBuffer(0);\n            return buf;\n        }\n    }\n\n    // --------------------------------------\n    // End of code from DFRobot lcdDisplay extension\n    // --------------------------------------\n\n\n//% blockNamespace=storybrain\nclass StoryMessage {\n    _sender: string;\n    _message: string;\n\n    constructor(sender: string, message: string) {\n        this._sender = sender;\n        this._message = message;\n    }\n\n    //% blockCombine\n    get text() { return this._message }\n\n    //% blockCombine\n    get sender() { return this._sender }\n}\n\n//% color=\"#AA278D\"\nnamespace storybrain {\n\n    const ROOM_ELEMENT_IMAGE_CODE_UNKNOWN: string = 'def';\n\n    /**\n     * Information about an image for an escape room element.\n     */\n    class RoomElementImage {\n        code: string;\n        private _filename: string;\n\n        /**\n         * Constructs the image using \n         */\n        constructor(code: string = null) {\n            if (code === null) {\n                this.code = ROOM_ELEMENT_IMAGE_CODE_UNKNOWN;\n            } else {\n                this.code = code;\n            }\n            this._filename = this.code.toLowerCase();\n        }\n\n        public getFilePath(fresh: boolean = true) {\n            if (fresh) {\n                return \"/escape room icon/\" + this._filename + \"_mid.png\";\n            } else {\n                return \"/escape room icon/\" + this._filename + \"_dark.png\";\n            }\n\n        }\n    }\n\n    class RoomElement {\n        name: string;\n        lastCheckInTime: number;  // Millis since power on.\n        image: RoomElementImage;\n        fresh: boolean;\n        changedState: boolean;\n\n        constructor(name: string, imageCode: string = null) {\n            this.name = name;\n            this.image = new RoomElementImage(imageCode);\n            this.fresh = true;\n            this.changedState = true;\n            this.checkIn();\n        }\n\n        checkIn() {\n            this.lastCheckInTime = control.millis();\n            if (!this.fresh) {\n                this.fresh = true;\n                this.changedState = true;\n            }\n        }\n\n        // Call after updating widget on screen.\n        update() {\n            this.changedState = false;\n            if (this.fresh) {\n                if (control.millis() - this.lastCheckInTime > 8000) {\n                    this.fresh = false;\n                    this.changedState = true;\n                }\n            }\n        }\n    }\n\n    function getIconXPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2;\n            case 2: return 2;\n            case 3: return 2;\n            case 4: return 2;\n            case 5: return 2 + 45 * 1;\n            case 6: return 2 + 45 * 2;\n            case 7: return 2 + 45 * 3;\n            case 8: return 2 + 45 * 4;\n            case 9: return 2 + 45 * 5;\n            case 10: return 2 + 45 * 6;\n            case 11: return 2 + 45 * 6;\n            case 12: return 2 + 45 * 6;\n            case 13: return 2 + 45 * 6;\n            case 14: return 2 + 45 * 6;\n            case 15: return 2 + 45 * 5;\n            case 16: return 2 + 45 * 4;\n            case 17: return 2 + 45 * 3;\n            case 18: return 2 + 45 * 2;\n            case 19: return 2 + 45 * 1;\n            default: return 0;\n        }\n    }\n\n    function getIconYPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2 + 47;\n            case 2: return 2 + 47 * 2;\n            case 3: return 2 + 47 * 3;\n            case 4: return 2 + 47 * 4;\n            case 5: return 2 + 47 * 4;\n            case 6: return 2 + 47 * 4;\n            case 7: return 2 + 47 * 4;\n            case 8: return 2 + 47 * 4;\n            case 9: return 2 + 47 * 4;\n            case 10: return 2 + 47 * 4;\n            case 11: return 2 + 47 * 3;\n            case 12: return 2 + 47 * 2;\n            case 13: return 2 + 47 * 1;\n            case 14: return 2 + 47;\n            case 15: return 2 + 47;\n            case 16: return 2 + 47;\n            case 17: return 2 + 47;\n            case 18: return 2 + 47;\n            case 19: return 2 + 47;\n            default: return 0;\n        }\n    }\n\n    let roomName: string = 'UNNAMED'\n    let brainInitialized: boolean = false;\n    let startInitializationTime: number;\n    const registeredElements: RoomElement[] = [];\n    const uncheckedStoryMessages: StoryMessage[] = [];\n\n    /**\n     * Set up the story brain for the escape room.\n     * @param room the unique name for the room (use a maximum of 4 regular letters)\n     * @param radioGroup the radio group for the room, unique in the vicinity\n    */\n    //% block=\"initialise brain with room name $room and radio group $radioGroup\"\n    //% weight=100\n    //% room.defl=\"room\"\n    //% radioGroup.min=0 radioGroup.max=255 radioGroup.defl=20\n    export function initialiseBrain(room: string, radioGroup: number) {\n        initialise(room, radioGroup);\n    }\n\n    /**\n     * Returns true if there any unchecked messages available to grab.\n    */\n    //% block=\"unchecked messages available\"\n    //% weight=52\n    export function uncheckedMessagesAvailable(): boolean {\n        return (uncheckedStoryMessages.length > 0);\n    }\n\n    /**\n     * Grab the next unchecked message, removing it from the inbox.\n    */\n    //% block=\"grab next unchecked message\"\n    //% weight=51\n    //% blockSetVariable=storymessage\n    export function grabNextUncheckedMessage(): StoryMessage {\n        if (uncheckedStoryMessages.length > 0) {\n            return uncheckedStoryMessages.pop();\n        }\n        return new StoryMessage('no message', 'no message');\n    }\n\n    // Ensures that an element is kept up to date in the registeredElements array.\n    function registerElement(name: string, imageCode: string = null) {\n        for (let element of registeredElements) {\n            if (element.name.toUpperCase() === name) {\n                element.checkIn();\n                return;\n            }\n        }\n        registeredElements.push(new RoomElement(name, imageCode));\n    }\n\n    // Capture and process all radio messages coming in as strings.\n    /*\n    / Check-in messages are formatted as follows:   [room name]*[element name]\n    / Check-in messages can also be formatted to give an image:   [room name]*[element name]*I*[image code]\n    / Trigger messages are formatted as follows:   [room name]*[element name]*[message]\n    /\n    / room name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all escape rooms in the vicinity.\n    / element name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all elements in this escape room.\n    / message is a string of no more than 9 characters. Asterisk not allowed.\n    /\n    / Case is always ignored when comparing, so names and IDs must be unique ignoring case.\n    */\n    radio.onReceivedString(function (receivedString: string) {\n        if (!brainInitialized) {\n            return;\n        }\n\n        let messageParts: string[] = receivedString.split('*');\n\n        // If the received string could not be split, ignore it.\n        if (messageParts.length <= 1) {\n            return;\n        }\n        // If the room name doesn't match, ignore it.\n        if (messageParts[0].toUpperCase() != roomName.toUpperCase()) {\n            return;\n        }\n        // Process a basic check-in string.\n        if (messageParts.length == 2) {\n            registerElement(messageParts[1]);\n            return;\n        }\n        // Process an advanced check-in string.\n        if (messageParts.length == 4) {\n            registerElement(messageParts[1], messageParts[3]);\n            return;\n        }\n        registerElement(messageParts[1]);\n        // Process a true story message, but ignore if there is already an unchecked message from that element.\n        for (let message of uncheckedStoryMessages) {\n            if (message.sender.toUpperCase() == messageParts[1].toUpperCase()) {\n                return;\n            }\n        }\n        uncheckedStoryMessages.unshift(new StoryMessage(messageParts[1], messageParts[2]));\n    });\n\n    // Sets up the story brain with a room name and radio group unique in the vicinity.\n    // Must be called before other functions will work.\n    function initialise(room: string, radioGroup: number) {\n        roomName = room;\n        radio.setGroup(radioGroup);\n        lcdInitIIC();\n        lcdClearAll();\n        lcdSetBgcolor(lcdGetRgbColor(0, 0, 0));\n        lcdDisplayImage(250, '/escape room icon/story_brain.png', 123, 71, 255);\n        lcdDisplayText(roomName, 251, 123, 143, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n        startInitializationTime = control.millis();\n    }\n\n    registerElement('box', 'box');\n    registerElement('btns', 'press');\n    registerElement('hmmm');\n    uncheckedStoryMessages.unshift(new StoryMessage('box1', 'hello'));\n    uncheckedStoryMessages.unshift(new StoryMessage('btns', 'yo'));\n    uncheckedStoryMessages.unshift(new StoryMessage('hmmm', 'hi!'));\n\n    basic.forever(function () {\n        basic.pause(100);\n\n        if (!brainInitialized) {\n            if (control.millis() - startInitializationTime > 2000) {\n                brainInitialized = true;\n            } else {\n                return;\n            }\n        }\n\n        // Update elements on screen.\n        for (let i = 0; i < registeredElements.length; i++) {\n            let widgetOrder = (i + 1) * 3;\n            if (registeredElements[i].changedState) {\n                let path;\n                let textColour;\n                if (registeredElements[i].fresh) {\n                    path = registeredElements[i].image.getFilePath();\n                    textColour = lcdGetRgbColor(255, 255, 255)\n                } else {\n                    path = registeredElements[i].image.getFilePath(false);\n                    textColour = lcdGetRgbColor(128, 128, 128)\n                }\n                lcdDisplayImage(widgetOrder + 1, path, getIconXPlacement(i), getIconYPlacement(i), 255);\n                lcdDisplayText(registeredElements[i].name, widgetOrder + 2, getIconXPlacement(i) + 6, getIconYPlacement(i) + 46 - 2 - 18, FontSize.Small, textColour);\n            }\n            // Draw a line if there is an unchecked message from that element.\n            if (uncheckedStoryMessages.length == 0) {\n                lcdDeleteWidget(LCDWidgetCategoryTwo.Line, widgetOrder);\n            } else {\n                for (let message of uncheckedStoryMessages) {\n                    if (message.sender.toUpperCase() == registeredElements[i].name.toUpperCase()) {\n                        lcdDrawLine(widgetOrder, getIconXPlacement(i) + 23, getIconYPlacement(i) + 23, 159, 119, 5, lcdGetRgbColor(0, 255, 0));\n                    } else {\n                        lcdDeleteWidget(LCDWidgetCategoryTwo.Line, widgetOrder);\n                    }\n                }\n            }\n            registeredElements[i].update();\n        }\n    })\n\n}\n\n// Test everything.\nstorybrain.initialiseBrain('Mars', 10);\n\nbasic.forever(function () {\n    if (storybrain.uncheckedMessagesAvailable()) {\n        let myMessage: StoryMessage = storybrain.grabNextUncheckedMessage();\n        basic.showString(myMessage.text);\n    }\n})\n","README.md":"","pxt.json":"{\n    \"name\": \"story brain experiments\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1761971583743,"editorVersion":"8.0.18","text":{"main.ts":"// --------------------------------------\n// Code from DFRobot lcdDisplay extension\n// --------------------------------------\n// Original code has MIT license and copyright (c) 2021 TgJe.\n// Available at: https://github.com/DFRobot/pxt-DFRobot_lcdDisplay\n// Modified to hide blocks that access display directly.\n\nconst enum LCDWidgetCategoryOne {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n}\n\nconst enum LCDWidgetCategoryTwo {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n    Chart = 6,\n    Text = 7,\n    Line = 8,\n    Rectangle = 9,\n    Circle = 10,\n    Triangle = 11,\n    Icon = 12,\n    Gif = 13,\n}\n\nenum FontSize {\n    Large = 1,\n    Small = 2,\n}\n\nenum RectangleRound {\n    IsRound = 1,\n    NoneRound = 2,\n}\n\nenum ChartStyles {\n    LineChart = 3,\n    BarChart = 2,\n    ShadingLineChart = 1,\n}\n\nenum DrawType {\n    Fill = 1,\n    NotFill = 2,\n}\n\nenum Protocol {\n    IIC = 1,\n    Serial = 2,\n}\n\nconst IIC_MAX_TRANSFER_SIZE = 32;\n\n// cmd len\nconst CMDLEN_OF_HEAD_LEN = 3;\nconst CMD_DELETE_OBJ_LEN = 0x06;\nconst CMD_SET_TOP_OBJ_LEN = 0x06;\nconst CMD_SET_COMPASS_VALUE_LEN = 0x07;\nconst CMD_SET_LEN = 0x07;\nconst CMD_SET_GAUGE_VALUE_LEN = 0x07;\nconst CMD_SET_LINE_METER_VALUE_LEN = 0x07;\nconst CMD_SET_BAR_VALUE_LEN = 0x07;\nconst CMD_SET_SLIDER_VALUE_LEN = 0x07;\nconst CMD_SET_ANGLE_OBJ_LEN = 0x08;\nconst CMD_DRAW_COMPASS_LEN = 0x0B;\nconst CMD_DRAW_CHART_LEN = 0x09;\nconst CMD_DRAW_SERIE_LEN = 0x09;\nconst CMD_OF_DRAW_ICON_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_GIF_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_BAR_LEN = 0x10;\nconst CMD_OF_DRAW_SLIDER_LEN = 0x10;\nconst CMD_DRAW_PIXEL_LEN = 0x11;\nconst CMD_DRAW_LINE_LEN = 0x11;\nconst CMD_OF_DRAW_CIRCLE_LEN = 0x13;\nconst CMD_OF_DRAW_GAUGE_LEN = 0x15;\nconst CMD_OF_DRAW_LINE_METER_LEN = 0x15;\nconst CMD_OF_DRAW_RECT_LEN = 0x16;\nconst CMD_OF_DRAW_TRIANGLE_LEN = 0x19;\n\n// cmd\nconst CMD_SET_BACKGROUND_COLOR = 0x19;\nconst CMD_SET_BACKGROUND_IMG = 0x1A;\nconst CMD_OF_DRAW_PIXEL = 0x02;\nconst CMD_OF_DRAW_LINE = 0x03;\nconst CMD_OF_DRAW_RECT = 0x04;\nconst CMD_OF_DRAW_CIRCLE = 0x06;\nconst CMD_OF_DRAW_TRIANGLE = 0x07;\nconst CMD_OF_DRAW_ICON_INTERNAL = 0x08;\nconst CMD_OF_DRAW_ICON_EXTERNAL = 0x09;\nconst CMD_OF_DRAW_BAR = 0x0A;\nconst CMD_OF_DRAW_BAR_VALUE = 0x0B;\nconst CMD_OF_DRAW_SLIDER = 0x0C;\nconst CMD_OF_DRAW_SLIDER_VALUE = 0x0D;\nconst CMD_OF_DRAW_LINE_METER = 0x10;\nconst CMD_OF_DRAW_LINE_METER_VALUE = 0x11;\nconst CMD_OF_DRAW_COMPASS = 0x0E;\nconst CMD_OF_DRAW_COMPASS_VALUE = 0x0F;\nconst CMD_OF_DRAW_GAUGE = 0x12;\nconst CMD_OF_DRAW_GAUGE_VALUE = 0x13;\nconst CMD_OF_DRAW_LINE_CHART = 0x14;\nconst CMD_OF_DRAW_LINE_CHART_TEXT = 0x15;\nconst CMD_OF_DRAW_SERIE = 0x16;\nconst CMD_OF_DRAW_SERIE_DATA = 0x17;\nconst CMD_OF_DRAW_TEXT = 0x18;\nconst CMD_DELETE_OBJ = 0x1B;\nconst CMD_SET_TOP_OBJ = 0x1C;\nconst CMD_SET_ANGLE_OBJ = 0x1E;\nconst CMD_OF_DRAW_GIF_INTERNAL = 0x1F;\nconst CMD_OF_DRAW_GIF_EXTERNAL = 0x20;\n\nconst CMD_HEADER_HIGH = 0x55;\nconst CMD_HEADER_LOW = 0xaa;\n\nlet address = 0x2c;\nclass GenericNode {\n    id: number\n    next: GenericNode\n    constructor(id: number) {\n        this.id = id;\n        this.next = null;\n    }\n}\n\nclass LinkedList {\n    head: GenericNode\n    size: number\n    id: number\n    constructor() {\n        this.head = null;\n        this.size = 0;\n        this.id = 1;\n    }\n\n    // adds a node to the end of the linked list\n    append() {\n        const newNode = new GenericNode(this.id);\n        if (this.head == null) {\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        this.size++;\n        this.id++;\n    }\n    // insert a node at a specific location\n    insert(index: number, id: number): boolean {\n        if (index < 0 || index > this.size) {\n            return false;\n        }\n        const newNode = new GenericNode(id);\n        if (index == 0) {\n            newNode.next = this.head;\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            newNode.next = current;\n            previous.next = newNode;\n        }\n        this.size++;\n        return true;\n    }\n    // removes a node at a specific location\n    removeAt(index: number): boolean {\n        if (index < 0 || index >= this.size || this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (index == 0) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n\n    // example Remove a node with a specific id\n    removeId(id: number): boolean {\n        if (this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (current.id == id) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            while (current.id != id) {\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n}\n\ntype GenericList = {\n    lineChartHead: LinkedList | null,\n    seriesHead: LinkedList | null,\n    compassHead: LinkedList | null,\n    textHead: LinkedList | null,\n    gaugeHead: LinkedList | null,\n    lineHead: LinkedList | null,\n    rectHead: LinkedList | null,\n    circleHead: LinkedList | null,\n    triangleHead: LinkedList | null,\n    lineMeterHead: LinkedList | null,\n    barHead: LinkedList | null,\n    sliderHead: LinkedList | null,\n    iconHead: LinkedList | null,\n    gifHead: LinkedList | null,\n}\n\nlet list: GenericList = {\n    lineChartHead: null,\n    seriesHead: null,\n    compassHead: null,\n    textHead: null,\n    gaugeHead: null,\n    lineHead: null,\n    rectHead: null,\n    circleHead: null,\n    triangleHead: null,\n    lineMeterHead: null,\n    barHead: null,\n    sliderHead: null,\n    iconHead: null,\n    gifHead: null,\n}\nlet protocol: Protocol = Protocol.IIC;\nlet chartID = 0;\nlet axisListX: string[] = [];\nlet axisListY: string[] = [];\nlet axisYData: number[] = [];\nlet seriesData: any = {};\nlet dataFactor = 1; // \"data coordinate conversion factors\n\n/**\n * Original block \"ColorScreen I2C initialization\"\n */\nfunction lcdInitIIC() {\n    creatList();\n    protocol = Protocol.IIC;\n    basic.pause(1000);\n}\n\n/**\n * Original block \"clear the screen\"\n */\nfunction lcdClearAll() {\n    cleanScreen();\n}\n\n/**\n * Original block \"set the background color %color\"\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdSetBgcolor(color: number) {\n    setBackgroundColor(colorToCustom(color));\n}\n\n/**\n * Original block \"red %red green %green blue %blue\"\n * Convert red, green and blue channels into a RGB color\n * @param red to red ,eg: 255 (min 0, max 255, default 255)\n * @param green to green ,eg: 255 (min 0, max 255, default 255)\n * @param blue to blue ,eg: 255 (min 0, max 255, default 255)\n */\nfunction lcdGetRgbColor(red: number, green: number, blue: number): number {\n    return (red << 16) + (green << 8) + (blue);\n}\n\n/**\n * Original block \"set the background picture %picture\"\n * @param picture to picture ,eg: \"fruit.png\"\n */\nfunction lcdSetBgIamge(picture: string) {\n    //setBackgroundImg(0, picture); // Internal storage of pictures\n    setBackgroundImg(1, picture); // Usb flash drive to store pictures\n}\n\n/**\n * Original block \"display text %text number %num position x: %x y: %y size %size color %color\"\n * @param text to text ,eg: \"hello\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayText(text: string, num: number, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, text, size, color);\n}\n\n/**\n * Original block \"display time number %num time %time position x: %x y: %y size %size color %color\"\n * Was marked as deprecated.\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param time to time ,eg: \"12:40:30\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayTime(num: number, time: string, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, time, size, color);\n}\n\n/**\n * Original block \"hour %hour minutes %min second %sec\"\n * @param hour to hour ,eg: 12 (min 0, max 23, default 12)\n * @param min to min ,eg: 40 (min 0, max 59, default 40)\n * @param sec to sec ,eg: 30 (min 0, max 59, default 30)\n */\nfunction lcdGetTime(hour: number, min: number, sec: number): string {\n    return `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`\n}\n\n/**\n * Original block \"display image number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param name to name ,eg: \"/expression icon/happy.png\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayImage(num: number, name: string, x: number, y: number, size: number) {\n    updateIcon(num, x, y, name, size);\n}\n\n/**\n * Original block \"rotate image number %num angle %angle\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param angle to angle ,eg: 180 (min 0, max 360, default 180)\n */\nfunction lcdRotateIamge(num: number, angle: number) {\n    setAngleIcon(num, angle * 10);\n}\n\n/**\n * Original block \"display gif number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1\n * @param name to name ,eg: \"Snowy.gif\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayGif(num: number, name: string, x: number, y: number, size: number) {\n    updateGif(num, x, y, name, size);\n}\n\n/**\n * Original block \"draw line number %num start x1: %x1 y1: %y1 end x2: %x2 y2: %y2 width %width color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 40 (min 0, max 320, default 40)\n * @param y1 to y1 ,eg: 120 (min 0, max 240, default 120)\n * @param x2 to x2 ,eg: 300 (min 0, max 320, default 300)\n * @param y2 to y2 ,eg: 120 (min 0, max 240, default 120)\n * @param width to width ,eg: 20\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawLine(num: number, x1: number, y1: number, x2: number, y2: number, width: number, color: number) {\n    updateLine(num, x1, y1, x2, y2, width, color);\n}\n\n/**\n * Original block \"draw rectangle number %num start x: %x y: %y width %w height %h line width %width Border color %bocolor %fill color %fcolor %round\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param w to w ,eg: 300 (min 0, max 320, default 300)\n * @param h to h ,eg: 200 (min 0, max 240, default 200)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n * @param round to round ,eg: lcdDisplay.RectangleRound.NoneRound\n */\nfunction lcdDrawRectangle(num: number, x: number, y: number, w: number, h: number, width: number, bocolor: number, fill: DrawType, fcolor: number, round: RectangleRound) {\n    updateRect(num, x, y, w, h, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor, round === RectangleRound.IsRound ? 1 : 0);\n}\n\n/**\n * Original block \"draw circle number %num center x: %x y: %y radius %r line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 160 (min 0, max 320, default 160)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param r to r ,eg: 120 (min 0, max 120, default 120)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawCircle(num: number, x: number, y: number, r: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateCircle(num, x, y, r, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw triangle number %num x1: %x1 y1: %y1 x2: %x2 y2: %y2 x3: %x3 y3: %y3 line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 160 (min 0, max 320, default 160)\n * @param y1 to y1 ,eg: 0 (min 0, max 240, default 0)\n * @param x2 to x2 ,eg: 0 (min 0, max 320, default 0)\n * @param y2 to y2 ,eg: 240 (min 0, max 240, default 240)\n * @param x3 to x3 ,eg: 320 (min 0, max 320, default 320)\n * @param y3 to y3 ,eg: 240 (min 0, max 240, default 240)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawTriangle(num: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateTriangle(num, x1, y1, x2, y2, x3, y3, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw slider number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawSlider(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateSlider(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw bar number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawBar(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateBar(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw compass number %num position x: %x y: %y radius %r\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n */\nfunction lcdDrawCompass(num: number, x: number, y: number, r: number) {\n    updateCompass(num, x, y, r);\n}\n\n/**\n * Original block \"draw gauge number %num position x: %x y: %y radius %r start of scale %start End of scale %end Pointer color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 360 (min 0, max 360, default 360)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawGauge(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateGauge(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"draw lineMeter number %num position x: %x y: %y radius %r start of scale %start End of scale %end Data color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 100 (min 0, max 360, default 100)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawLineMeter(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateLineMeter(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"set %type=LCDWidgetCategoryOne_conv widget number %num data %data\"\n * @param type to type ,eg: LCDWidgetCategoryOne.Slider\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param data to data ,eg: 80\n */\nfunction lcdSetWidgetData(type: number, num: number, data: number) {\n    switch (type) {\n        case LCDWidgetCategoryOne.Slider:\n            setSliderValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Bar:\n            setBarValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Compass:\n            setCompassScale(num, (data / 360) * 3600);\n            break;\n        case LCDWidgetCategoryOne.Gauge:\n            setGaugeValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.LineMeter:\n            setMeterValue(num, data);\n            break;\n        default:\n            break;\n    }\n}\n\n/**\n * Original block \"draw chart number %num X-axis %xaxis Y-axis %yaxis background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan Feb Mar Apr May Jun\"\n * @param yaxis to yaxis ,eg: \"100 80 60 40 20 0\"\n * @param color to color ,eg: 0xFFFFFF\n * @param styles to styles ,eg: ChartStyles.LineChart\n */\nfunction lcdDrawChart(num: number, xaxis: string, yaxis: string, color: number, styles: ChartStyles) {\n    chartID = num;\n    axisListX = xaxis.split(\" \");\n    axisListY = yaxis.split(\" \");\n    axisListX.forEach((value, index) => { axisYData.push(0) });\n    dataFactor = Math.abs((parseInt(axisListY[0]) - parseInt(axisListY[axisListY.length - 1])) / 100);\n    updateChart(chartID, color, styles);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 0, axisListX);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 1, axisListY);\n}\n\n/**\n * Original block \"Set chart data number %num color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdAddChartData(num: number, color: number) {\n    seriesData[num] = axisYData;\n    updateChartSeries(chartID, num, color);\n    addChartSeriesData(chartID, num, seriesData[num], axisListX.length)\n}\n\n/**\n * Original block \"set chart data number %num X-axis %xaxis data %data\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan\"\n * @param data to data ,eg: 80\n */\nfunction lcdSetChartData(num: number, xaxis: string, data: number) {\n    let index = axisListX.indexOf(xaxis);\n    if (data < parseInt(axisListY[axisListY.length - 1]) || data > parseInt(axisListY[0]))\n        return\n    if (index !== -1) {\n        updateChartPoint(chartID, num, index, Math.round((data - parseInt(axisListY[axisListY.length - 1])) / dataFactor));\n        // seriesData[num][index] = Math.round(data / 10);\n    }\n}\n\n/**\n * Original block \"update chart number %num background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0x007FFF\n * @param styles to styles ,eg: lcdDisplay.ChartStyles.BarChart\n */\nfunction lcdUpdateChart(num: number, color: number, styles: ChartStyles) {\n    updateChart(num, color, styles);\n}\n\n/**\n * Original block \"delete %type=LCDWidgetCategoryTwo_conv number %num\"\n * @param type to type ,eg: LCDWidgetCategoryTwo.Text\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n */\nfunction lcdDeleteWidget(type: number, num: number) {\n    switch (type) {\n        case LCDWidgetCategoryTwo.Slider:\n            deleteSlider(num);\n            break;\n        case LCDWidgetCategoryTwo.Bar:\n            deleteBar(num);\n            break;\n        case LCDWidgetCategoryTwo.Compass:\n            deleteCompass(num);\n            break;\n        case LCDWidgetCategoryTwo.Gauge:\n            deleteGauge(num);\n            break;\n        case LCDWidgetCategoryTwo.LineMeter:\n            deleteLineMeter(num);\n            break;\n        case LCDWidgetCategoryTwo.Chart:\n            deleteChart(num);\n            break;\n        case LCDWidgetCategoryTwo.Text:\n            deleteString(num);\n            break;\n        case LCDWidgetCategoryTwo.Line:\n            deleteLine(num);\n            break;\n        case LCDWidgetCategoryTwo.Rectangle:\n            deleteRect(num);\n            break;\n        case LCDWidgetCategoryTwo.Circle:\n            deleteCircle(num);\n            break;\n        case LCDWidgetCategoryTwo.Triangle:\n            deleteTriangle(num);\n            break;\n        case LCDWidgetCategoryTwo.Icon:\n            deleteIcon(num);\n            break;\n        case LCDWidgetCategoryTwo.Gif:\n            deleteGif(num);\n        default:\n            break;\n    }\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryOne_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryOne number\n */\nfunction getWidgetCategoryOne(item: LCDWidgetCategoryOne): number {\n    return item as number;\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryTwo_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryTwo number\n */\nfunction getLCDWidgetCategoryTwo(item: LCDWidgetCategoryTwo): number {\n    return item as number;\n}\n\nfunction cleanScreen() {\n    let cmd = creatCommand(0x1D, 0x04);\n    writeCommand(cmd, 4);\n    basic.pause(1500);\n}\n\nfunction setBackgroundColor(color: number) {\n    let cmd = creatCommand(CMD_SET_BACKGROUND_COLOR, CMD_SET_LEN);\n    cmd = cmd.concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_SET_LEN);\n    basic.pause(300);\n}\n\nfunction setBackgroundImg(location: number, str: string) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_SET_BACKGROUND_IMG, len + 5);\n    cmd = cmd.concat([location]);\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 5);\n}\n\nfunction drawString(x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TEXT), fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction updateString(id: number, x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([id, fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction deleteString(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TEXT, id])\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.textHead, id);\n}\n\nfunction drawLcdTime(x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    drawString(x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction updateLcdTime(id: number, x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    updateString(id, x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction drawIcon(x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_ICON_INTERNAL)]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction setAngleIcon(id: number, angle: number) {\n    let cmd = creatCommand(CMD_SET_ANGLE_OBJ, CMD_SET_ANGLE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]).concat(data16Tobyte(angle));\n    writeCommand(cmd, CMD_SET_ANGLE_OBJ_LEN);\n}\n\nfunction updateIcon(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteIcon(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.iconHead, id);\n}\n\nfunction drawGif(x: number, y: number, str: string, zoom: number): number {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    let id = getID(CMD_OF_DRAW_GIF_EXTERNAL);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n    return id;\n}\n\nfunction updateGif(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteGif(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GIF_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gifHead, id);\n}\n\nfunction drawLine(x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE), width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n}\n\nfunction updateLine(id: number, x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([id, width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n    basic.pause(10);\n}\n\nfunction deleteLine(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineHead, id);\n}\n\nfunction drawRect(x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_RECT), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction updateRect(id: number, x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction deleteRect(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_RECT, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.rectHead, id);\n}\n\nfunction drawCircle(x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_CIRCLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction updateCircle(id: number, x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction deleteCircle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_CIRCLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.circleHead, id);\n}\n\nfunction drawTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TRIANGLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction updateTriangle(id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction deleteTriangle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TRIANGLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.triangleHead, id);\n}\n\nfunction creatSlider(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_SLIDER)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction updateSlider(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction setSliderValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER_VALUE, CMD_SET_SLIDER_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_SLIDER_VALUE_LEN);\n}\n\nfunction deleteSlider(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_SLIDER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.sliderHead, id);\n}\n\nfunction creatBar(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_BAR)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction updateBar(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction setBarValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR_VALUE, CMD_SET_BAR_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_BAR_VALUE_LEN);\n}\n\nfunction deleteBar(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_BAR, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.barHead, id);\n}\n\nfunction creatCompass(x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_COMPASS)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction updateCompass(id: number, x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction setCompassScale(id: number, scale: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS_VALUE, CMD_SET_COMPASS_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(scale));\n    writeCommand(cmd, CMD_SET_COMPASS_VALUE_LEN);\n}\n\nfunction deleteCompass(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_COMPASS, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.compassHead, id);\n}\n\nfunction creatGauge(x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_GAUGE)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction updateGauge(id: number, x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction setGaugeValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE_VALUE, CMD_SET_GAUGE_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_GAUGE_VALUE_LEN);\n}\n\nfunction deleteGauge(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GAUGE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gaugeHead, id);\n}\n\nfunction creatLineMeter(x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE_METER)]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction updateLineMeter(id: number, x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction setTopLineMeter(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n}\n\nfunction deleteLineMeter(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineMeterHead, id);\n}\n\nfunction creatChart(strX: string[], strY: string[], bgColor: number, type: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    let id = getID(CMD_OF_DRAW_LINE_CHART);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n    basic.pause(100);\n    setChartAxisTexts(id, 0, strX);\n    basic.pause(100);\n    setChartAxisTexts(id, 1, strY);\n    return id;\n}\n\nfunction updateChart(id: number, bgColor: number, type: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n}\n\nfunction creatChartSeries(chartId: number, color: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    let serieId = getID(CMD_OF_DRAW_SERIE);\n    cmd = cmd.concat([serieId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n    return serieId;\n}\n\nfunction updateChartSeries(chartId: number, seriesId: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    cmd = cmd.concat([seriesId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n}\n\nfunction setChartAxisTexts(chartId: number, axis: number, text: string[]) {\n    let len = text.length - 1;\n    text.forEach((value, index) => { len = len + value.length });\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART_TEXT, len + 6);\n    cmd = cmd.concat([chartId, axis]);\n    for (let i = 0; i < text.length; i++) {\n        text[i].split(\"\").forEach((value, index) => {\n            cmd.push(value.charCodeAt(0))\n        })\n        if (i != text.length - 1) {\n            cmd.push(0x0A); // \"\\n\"\n        }\n    }\n    writeCommand(cmd, len + 6);\n}\n\nfunction updateChartPoint(chartId: number, seriesId: number, pointNum: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, 10);\n    cmd = cmd.concat([chartId, seriesId, 1, pointNum]).concat(data16Tobyte(value));\n    writeCommand(cmd, 10);\n}\n\nfunction addChartSeriesData(chartId: number, seriesId: number, point: number[], len: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, len * 2 + 8);\n    cmd = cmd.concat([chartId, seriesId, 0, 0]);\n    point.forEach((value, index) => { cmd = cmd.concat(data16Tobyte(value)) });\n    writeCommand(cmd, len * 2 + 8);\n    return 1;\n}\n\nfunction setTopChart(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_SET_TOP_OBJ_LEN);\n}\n\nfunction deleteChart(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineChartHead, id);\n}\n\nfunction setMeterValue(lineMeterId: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER_VALUE, CMD_SET_LINE_METER_VALUE_LEN);\n    cmd = cmd.concat([lineMeterId]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_LINE_METER_VALUE_LEN);\n}\n\n/********************************************************************************************************************/\nfunction creatList() {\n    list.lineChartHead = new LinkedList();\n    list.seriesHead = new LinkedList();\n    list.compassHead = new LinkedList();\n    list.textHead = new LinkedList();\n    list.gaugeHead = new LinkedList();\n    list.lineHead = new LinkedList();\n    list.rectHead = new LinkedList();\n    list.circleHead = new LinkedList();\n    list.triangleHead = new LinkedList();\n    list.lineMeterHead = new LinkedList();\n    list.barHead = new LinkedList();\n    list.sliderHead = new LinkedList();\n    list.iconHead = new LinkedList();\n    list.gifHead = new LinkedList();\n}\n\nfunction getID(type: number): number {\n    let id = 0;\n    switch (type) {\n        case CMD_OF_DRAW_LINE_CHART:\n            id = getNewID(list.lineChartHead);\n            break;\n        case CMD_OF_DRAW_SERIE:\n            id = getNewID(list.seriesHead);\n            break;\n        case CMD_OF_DRAW_COMPASS:\n            id = getNewID(list.compassHead);\n            break;\n        case CMD_OF_DRAW_TEXT:\n            id = getNewID(list.textHead);\n            break;\n        case CMD_OF_DRAW_GAUGE:\n            id = getNewID(list.gaugeHead);\n            break;\n        case CMD_OF_DRAW_LINE:\n            id = getNewID(list.lineHead);\n            break;\n        case CMD_OF_DRAW_RECT:\n            id = getNewID(list.rectHead);\n            break;\n        case CMD_OF_DRAW_TRIANGLE:\n            id = getNewID(list.triangleHead);\n            break;\n        case CMD_OF_DRAW_CIRCLE:\n            id = getNewID(list.circleHead);\n            break;\n        case CMD_OF_DRAW_LINE_METER:\n            id = getNewID(list.lineMeterHead);\n            break;\n        case CMD_OF_DRAW_BAR:\n            id = getNewID(list.barHead);\n            break;\n        case CMD_OF_DRAW_SLIDER:\n            id = getNewID(list.sliderHead);\n            break;\n        case CMD_OF_DRAW_ICON_INTERNAL:\n            id = getNewID(list.iconHead);\n            break;\n        case CMD_OF_DRAW_GIF_INTERNAL:\n            id = getNewID(list.gifHead);\n            break;\n        default:\n            break;\n    }\n    return id;\n}\n\nfunction getNewID(linkList: LinkedList): number {\n    linkList.append();\n    return linkList.head.id;\n}\n\nfunction deleteNodeByID(linkList: LinkedList, id: number) {\n    linkList.removeId(id);\n}\n\nfunction data16Tobyte(data: number): number[] {\n    return [(data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction data24Tobyte(data: number): number[] {\n    return [(data >> 16) & 0xFF, (data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction colorToCustom(color: number): number {\n    switch (color) {\n        case 0x999999:\n            return 0x696969;\n        case 0x7f00ff:\n            return 0x800080;\n        default:\n            return color;\n    }\n}\n\nfunction creatCommand(cmd: number, len: number): number[] {\n    return [CMD_HEADER_HIGH, CMD_HEADER_LOW, len - CMDLEN_OF_HEAD_LEN, cmd];\n}\n\nfunction writeCommand(data: number[], len: number) {\n    // serial.writeNumbers(data);\n    if (protocol == Protocol.IIC) {\n        let remain = len;\n        let i = 0;\n        while (remain > 0) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? 32 : remain;\n            if (remain > IIC_MAX_TRANSFER_SIZE) {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), true);\n            } else {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), false);\n            }\n            remain = remain - currentTransferSize;\n            i = i + 1;\n        }\n    } else {\n    }\n}\n\nfunction readACK(length: number): Buffer {\n    if (protocol == Protocol.IIC) {\n        let remain = length;\n        let buf: Buffer = pins.createBuffer(0);\n        while (remain) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? IIC_MAX_TRANSFER_SIZE : remain;\n            buf = buf.concat(pins.i2cReadBuffer(address, currentTransferSize));\n            remain = remain - currentTransferSize;\n        }\n        return buf;\n    } else {\n        let buf: Buffer = pins.createBuffer(0);\n        return buf;\n    }\n}\n\n// --------------------------------------\n// End of code from DFRobot lcdDisplay extension\n// --------------------------------------\n\n\n//% blockNamespace=storybrain\nclass StoryMessage {\n    _sender: string;\n    _message: string;\n\n    constructor(sender: string, message: string) {\n        this._sender = sender;\n        this._message = message;\n    }\n\n    //% blockCombine\n    get text() { return this._message }\n\n    //% blockCombine\n    get sender() { return this._sender }\n}\n\n//% color=\"#402504\" icon=\"\\uf02d\" block=\"Story brain\"\nnamespace storybrain {\n\n    const ROOM_ELEMENT_IMAGE_CODE_UNKNOWN: string = 'def';\n\n    /**\n     * Information about an image for an escape room element.\n     */\n    class RoomElementImage {\n        code: string;\n        private _filename: string;\n\n        /**\n         * Constructs the image using \n         */\n        constructor(code: string = null) {\n            if (code === null) {\n                this.code = ROOM_ELEMENT_IMAGE_CODE_UNKNOWN;\n            } else {\n                this.code = code;\n            }\n            this._filename = this.code.toLowerCase();\n        }\n\n        public getFilePath(fresh: boolean = true) {\n            if (fresh) {\n                return \"/escape room icon/\" + this._filename + \"_mid.png\";\n            } else {\n                return \"/escape room icon/\" + this._filename + \"_dark.png\";\n            }\n\n        }\n    }\n\n    class RoomElement {\n        name: string;\n        lastCheckInTime: number;  // Millis since power on.\n        image: RoomElementImage;\n        fresh: boolean;\n        changedState: boolean;\n\n        constructor(name: string, imageCode: string = null) {\n            this.name = name;\n            this.image = new RoomElementImage(imageCode);\n            this.fresh = true;\n            this.changedState = true;\n            this.checkIn();\n        }\n\n        checkIn() {\n            this.lastCheckInTime = control.millis();\n            if (!this.fresh) {\n                this.fresh = true;\n                this.changedState = true;\n            }\n        }\n\n        // Call after updating widget on screen.\n        update() {\n            this.changedState = false;\n            if (this.fresh) {\n                if (control.millis() - this.lastCheckInTime > 8000) {\n                    this.fresh = false;\n                    this.changedState = true;\n                }\n            }\n        }\n    }\n\n    function getIconXPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2;\n            case 2: return 2;\n            case 3: return 2;\n            case 4: return 2;\n            case 5: return 2 + 45 * 1;\n            case 6: return 2 + 45 * 2;\n            case 7: return 2 + 45 * 3;\n            case 8: return 2 + 45 * 4;\n            case 9: return 2 + 45 * 5;\n            case 10: return 2 + 45 * 6;\n            case 11: return 2 + 45 * 6;\n            case 12: return 2 + 45 * 6;\n            case 13: return 2 + 45 * 6;\n            case 14: return 2 + 45 * 6;\n            case 15: return 2 + 45 * 5;\n            case 16: return 2 + 45 * 4;\n            case 17: return 2 + 45 * 3;\n            case 18: return 2 + 45 * 2;\n            case 19: return 2 + 45 * 1;\n            default: return 0;\n        }\n    }\n\n    function getIconYPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2 + 47 * 1;\n            case 2: return 2 + 47 * 2;\n            case 3: return 2 + 47 * 3;\n            case 4: return 2 + 47 * 4;\n            case 5: return 2 + 47 * 4;\n            case 6: return 2 + 47 * 4;\n            case 7: return 2 + 47 * 4;\n            case 8: return 2 + 47 * 4;\n            case 9: return 2 + 47 * 4;\n            case 10: return 2 + 47 * 4;\n            case 11: return 2 + 47 * 3;\n            case 12: return 2 + 47 * 2;\n            case 13: return 2 + 47 * 1;\n            case 14: return 2;\n            case 15: return 2;\n            case 16: return 2;\n            case 17: return 2;\n            case 18: return 2;\n            case 19: return 2;\n            default: return 0;\n        }\n    }\n\n    let roomName: string = 'UNNAMED'\n    let brainInitialized: boolean = false;\n    let startInitializationTime: number;\n    let statusText: string = '';\n    let statusColour: number = lcdGetRgbColor(255, 0, 0);\n    let updatingScreen: boolean = false;\n    const registeredElements: RoomElement[] = [];\n    const uncheckedStoryMessages: StoryMessage[] = [];\n\n    /**\n     * Set up the story brain for the escape room.\n     * @param room the unique name for the room (use a maximum of 4 regular letters)\n     * @param radioGroup the radio group for the room, unique in the vicinity\n    */\n    //% block=\"initialise brain with room name $room and radio group $radioGroup\"\n    //% blockGap=50\n    //% weight=100\n    //% room.defl=\"room\"\n    //% radioGroup.min=0 radioGroup.max=255 radioGroup.defl=20\n    export function initialiseBrain(room: string, radioGroup: number) {\n        initialise(room, radioGroup);\n    }\n\n    /**\n     * Returns true if there any unchecked messages available to grab.\n    */\n    //% block=\"unchecked messages available\"\n    //% weight=52\n    export function uncheckedMessagesAvailable(): boolean {\n        return (uncheckedStoryMessages.length > 0);\n    }\n\n    /**\n     * Grab the next unchecked message, removing it from the inbox.\n    */\n    //% block=\"grab next unchecked message\"\n    //% weight=51\n    //% blockSetVariable=storymessage\n    export function grabNextUncheckedMessage(): StoryMessage {\n        while (updatingScreen) {\n            basic.pause(1);\n        }\n        if (uncheckedStoryMessages.length > 0) {\n            return uncheckedStoryMessages.pop();\n        }\n        return new StoryMessage('no message', 'no message');\n    }\n\n    /**\n     * Use the story brain's colour screen to display a short status message.\n     */\n    //% block=\"Display status $text in $colour\"\n    //% colour.shadow=\"colorNumberPicker\"\n    //% advanced=true\n    //% weight=10\n    export function setStatus(text: string, colour: number) {\n        statusText = text;\n        statusColour = colour;\n    }\n\n    /**\n     * Clear status message on the story brain's colour screen.\n     */\n    //% block=\"Clear status\"\n    //% advanced=true\n    //% weight=9\n    export function clearStatus() {\n        statusText = '';\n    }\n\n    // Ensures that an element is kept up to date in the registeredElements array.\n    function registerElement(name: string, imageCode: string = null) {\n        for (let element of registeredElements) {\n            if (element.name.toUpperCase() === name) {\n                element.checkIn();\n                return;\n            }\n        }\n        registeredElements.push(new RoomElement(name, imageCode));\n    }\n\n    // Capture and process all radio messages coming in as strings.\n    /*\n    / Check-in messages are formatted as follows:   [room name]*[element name]\n    / Check-in messages can also be formatted to give an image:   [room name]*[element name]*I*[image code]\n    / Trigger messages are formatted as follows:   [room name]*[element name]*[message]\n    /\n    / room name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all escape rooms in the vicinity.\n    / element name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all elements in this escape room.\n    / message is a string of no more than 9 characters. Asterisk not allowed.\n    /\n    / Case is always ignored when comparing, so names and IDs must be unique ignoring case.\n    */\n    radio.onReceivedString(function (receivedString: string) {\n        if (!brainInitialized) {\n            return;\n        }\n\n        let messageParts: string[] = receivedString.split('*');\n\n        // If the received string could not be split, ignore it.\n        if (messageParts.length <= 1) {\n            return;\n        }\n        // If the room name doesn't match, ignore it.\n        if (messageParts[0].toUpperCase() != roomName.toUpperCase()) {\n            return;\n        }\n        // Process a basic check-in string.\n        if (messageParts.length == 2) {\n            registerElement(messageParts[1]);\n            return;\n        }\n        // Process an advanced check-in string.\n        if (messageParts.length == 4) {\n            registerElement(messageParts[1], messageParts[3]);\n            return;\n        }\n        registerElement(messageParts[1]);\n        // Process a true story message, but ignore if there is already an unchecked message from that element.\n        for (let message of uncheckedStoryMessages) {\n            if (message.sender.toUpperCase() == messageParts[1].toUpperCase()) {\n                return;\n            }\n        }\n        uncheckedStoryMessages.unshift(new StoryMessage(messageParts[1], messageParts[2]));\n    });\n\n    // Sets up the story brain with a room name and radio group unique in the vicinity.\n    // Must be called before other functions will work.\n    function initialise(room: string, radioGroup: number) {\n        roomName = room;\n        radio.setGroup(radioGroup);\n        lcdInitIIC();\n        lcdClearAll();\n        lcdSetBgcolor(lcdGetRgbColor(0, 0, 0));\n        lcdDisplayImage(250, '/escape room icon/story_brain.png', 123, 71, 255);\n        lcdDisplayText(roomName, 251, 123, 143, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n        startInitializationTime = control.millis();\n    }\n\n    registerElement('box', 'box');\n    registerElement('btns', 'press');\n    registerElement('hmmm');\n    registerElement('tes1');\n    registerElement('tes2');\n    registerElement('tes3');\n    registerElement('tes4');\n    registerElement('tes5');\n    registerElement('tes6');\n    registerElement('tes7');\n    registerElement('tes8');\n    registerElement('tes9');\n    registerElement('tes10');\n    registerElement('tes11');\n    registerElement('tes12');\n    registerElement('tes13');\n    registerElement('tes14');\n    registerElement('tes15');\n    registerElement('tes16');\n    registerElement('tes17');\n    uncheckedStoryMessages.unshift(new StoryMessage('box1', 'hello'));\n    uncheckedStoryMessages.unshift(new StoryMessage('btns', 'yo'));\n    uncheckedStoryMessages.unshift(new StoryMessage('hmmm', 'hi!'));\n\n    basic.forever(function () {\n        basic.pause(200);\n\n        if (!brainInitialized) {\n            if (control.millis() - startInitializationTime > 2000) {\n                brainInitialized = true;\n            } else {\n                return;\n            }\n        }\n\n        // Update elements on screen.\n        updatingScreen = true;\n        for (let i = 0; i < registeredElements.length; i++) {\n            let widgetOrder = (i + 1) * 3;\n            if (registeredElements[i].changedState) {\n                let path;\n                let textColour;\n                if (registeredElements[i].fresh) {\n                    path = registeredElements[i].image.getFilePath();\n                    textColour = lcdGetRgbColor(255, 255, 255)\n                } else {\n                    path = registeredElements[i].image.getFilePath(false);\n                    textColour = lcdGetRgbColor(128, 128, 128)\n                }\n                lcdDisplayImage(widgetOrder, path, getIconXPlacement(i), getIconYPlacement(i), 255);\n                basic.pause(5);  // Pause added to avoid overload in communication with screen.\n                lcdDisplayText(registeredElements[i].name, widgetOrder + 1, getIconXPlacement(i) + 6, getIconYPlacement(i) + 46 - 2 - 18, FontSize.Small, textColour);\n                basic.pause(5);  // Pause added to avoid overload in communication with screen.\n            }\n            // Draw a line if there is an unchecked message from that element.\n            let lineToDraw = false;\n            for (let message of uncheckedStoryMessages) {\n                if (message.sender.toUpperCase() == registeredElements[i].name.toUpperCase()) {\n                    lineToDraw = true;\n                }\n            }\n            if (lineToDraw) {\n                lcdDrawLine(widgetOrder + 2, getIconXPlacement(i) + 23, getIconYPlacement(i) + 23, 159, 119, 5, lcdGetRgbColor(0, 255, 0));\n            } else {\n                lcdDeleteWidget(LCDWidgetCategoryTwo.Line, widgetOrder + 2);\n            }\n            registeredElements[i].update();\n            // Custom status display.\n            if (statusText.length > 0) {\n                lcdDisplayText(statusText, 200, 72, 166, FontSize.Small, statusColour);\n            } else {\n                lcdDeleteWidget(LCDWidgetCategoryTwo.Text, 200);\n            }\n        }\n        updatingScreen = false;\n    })\n\n}\n\n// Test code.\nstorybrain.initialiseBrain('Mars', 10);\n\nbasic.forever(function () {\n    pause(6000);\n//    while (storybrain.uncheckedMessagesAvailable()) {\n        //let myMessage: StoryMessage = storybrain.grabNextUncheckedMessage();\n        //pause(50);\n    //}\n    //pause(5000);\n    if (storybrain.uncheckedMessagesAvailable()) {\n        storybrain.setStatus('Messages still available.', 254);\n    }\n})\n\n","README.md":"","pxt.json":"{\n    \"name\": \"story brain experiments\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1762068747794,"editorVersion":"8.0.18","text":{"main.ts":"// --------------------------------------\n// Code from DFRobot lcdDisplay extension\n// --------------------------------------\n// Original code has MIT license and copyright (c) 2021 TgJe.\n// Available at: https://github.com/DFRobot/pxt-DFRobot_lcdDisplay\n// Modified to hide blocks that access display directly.\n\nconst enum LCDWidgetCategoryOne {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n}\n\nconst enum LCDWidgetCategoryTwo {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n    Chart = 6,\n    Text = 7,\n    Line = 8,\n    Rectangle = 9,\n    Circle = 10,\n    Triangle = 11,\n    Icon = 12,\n    Gif = 13,\n}\n\nenum FontSize {\n    Large = 1,\n    Small = 2,\n}\n\nenum RectangleRound {\n    IsRound = 1,\n    NoneRound = 2,\n}\n\nenum ChartStyles {\n    LineChart = 3,\n    BarChart = 2,\n    ShadingLineChart = 1,\n}\n\nenum DrawType {\n    Fill = 1,\n    NotFill = 2,\n}\n\nenum Protocol {\n    IIC = 1,\n    Serial = 2,\n}\n\nconst IIC_MAX_TRANSFER_SIZE = 32;\n\n// cmd len\nconst CMDLEN_OF_HEAD_LEN = 3;\nconst CMD_DELETE_OBJ_LEN = 0x06;\nconst CMD_SET_TOP_OBJ_LEN = 0x06;\nconst CMD_SET_COMPASS_VALUE_LEN = 0x07;\nconst CMD_SET_LEN = 0x07;\nconst CMD_SET_GAUGE_VALUE_LEN = 0x07;\nconst CMD_SET_LINE_METER_VALUE_LEN = 0x07;\nconst CMD_SET_BAR_VALUE_LEN = 0x07;\nconst CMD_SET_SLIDER_VALUE_LEN = 0x07;\nconst CMD_SET_ANGLE_OBJ_LEN = 0x08;\nconst CMD_DRAW_COMPASS_LEN = 0x0B;\nconst CMD_DRAW_CHART_LEN = 0x09;\nconst CMD_DRAW_SERIE_LEN = 0x09;\nconst CMD_OF_DRAW_ICON_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_GIF_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_BAR_LEN = 0x10;\nconst CMD_OF_DRAW_SLIDER_LEN = 0x10;\nconst CMD_DRAW_PIXEL_LEN = 0x11;\nconst CMD_DRAW_LINE_LEN = 0x11;\nconst CMD_OF_DRAW_CIRCLE_LEN = 0x13;\nconst CMD_OF_DRAW_GAUGE_LEN = 0x15;\nconst CMD_OF_DRAW_LINE_METER_LEN = 0x15;\nconst CMD_OF_DRAW_RECT_LEN = 0x16;\nconst CMD_OF_DRAW_TRIANGLE_LEN = 0x19;\n\n// cmd\nconst CMD_SET_BACKGROUND_COLOR = 0x19;\nconst CMD_SET_BACKGROUND_IMG = 0x1A;\nconst CMD_OF_DRAW_PIXEL = 0x02;\nconst CMD_OF_DRAW_LINE = 0x03;\nconst CMD_OF_DRAW_RECT = 0x04;\nconst CMD_OF_DRAW_CIRCLE = 0x06;\nconst CMD_OF_DRAW_TRIANGLE = 0x07;\nconst CMD_OF_DRAW_ICON_INTERNAL = 0x08;\nconst CMD_OF_DRAW_ICON_EXTERNAL = 0x09;\nconst CMD_OF_DRAW_BAR = 0x0A;\nconst CMD_OF_DRAW_BAR_VALUE = 0x0B;\nconst CMD_OF_DRAW_SLIDER = 0x0C;\nconst CMD_OF_DRAW_SLIDER_VALUE = 0x0D;\nconst CMD_OF_DRAW_LINE_METER = 0x10;\nconst CMD_OF_DRAW_LINE_METER_VALUE = 0x11;\nconst CMD_OF_DRAW_COMPASS = 0x0E;\nconst CMD_OF_DRAW_COMPASS_VALUE = 0x0F;\nconst CMD_OF_DRAW_GAUGE = 0x12;\nconst CMD_OF_DRAW_GAUGE_VALUE = 0x13;\nconst CMD_OF_DRAW_LINE_CHART = 0x14;\nconst CMD_OF_DRAW_LINE_CHART_TEXT = 0x15;\nconst CMD_OF_DRAW_SERIE = 0x16;\nconst CMD_OF_DRAW_SERIE_DATA = 0x17;\nconst CMD_OF_DRAW_TEXT = 0x18;\nconst CMD_DELETE_OBJ = 0x1B;\nconst CMD_SET_TOP_OBJ = 0x1C;\nconst CMD_SET_ANGLE_OBJ = 0x1E;\nconst CMD_OF_DRAW_GIF_INTERNAL = 0x1F;\nconst CMD_OF_DRAW_GIF_EXTERNAL = 0x20;\n\nconst CMD_HEADER_HIGH = 0x55;\nconst CMD_HEADER_LOW = 0xaa;\n\nlet address = 0x2c;\nclass GenericNode {\n    id: number\n    next: GenericNode\n    constructor(id: number) {\n        this.id = id;\n        this.next = null;\n    }\n}\n\nclass LinkedList {\n    head: GenericNode\n    size: number\n    id: number\n    constructor() {\n        this.head = null;\n        this.size = 0;\n        this.id = 1;\n    }\n\n    // adds a node to the end of the linked list\n    append() {\n        const newNode = new GenericNode(this.id);\n        if (this.head == null) {\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        this.size++;\n        this.id++;\n    }\n    // insert a node at a specific location\n    insert(index: number, id: number): boolean {\n        if (index < 0 || index > this.size) {\n            return false;\n        }\n        const newNode = new GenericNode(id);\n        if (index == 0) {\n            newNode.next = this.head;\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            newNode.next = current;\n            previous.next = newNode;\n        }\n        this.size++;\n        return true;\n    }\n    // removes a node at a specific location\n    removeAt(index: number): boolean {\n        if (index < 0 || index >= this.size || this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (index == 0) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n\n    // example Remove a node with a specific id\n    removeId(id: number): boolean {\n        if (this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (current.id == id) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            while (current.id != id) {\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n}\n\ntype GenericList = {\n    lineChartHead: LinkedList | null,\n    seriesHead: LinkedList | null,\n    compassHead: LinkedList | null,\n    textHead: LinkedList | null,\n    gaugeHead: LinkedList | null,\n    lineHead: LinkedList | null,\n    rectHead: LinkedList | null,\n    circleHead: LinkedList | null,\n    triangleHead: LinkedList | null,\n    lineMeterHead: LinkedList | null,\n    barHead: LinkedList | null,\n    sliderHead: LinkedList | null,\n    iconHead: LinkedList | null,\n    gifHead: LinkedList | null,\n}\n\nlet list: GenericList = {\n    lineChartHead: null,\n    seriesHead: null,\n    compassHead: null,\n    textHead: null,\n    gaugeHead: null,\n    lineHead: null,\n    rectHead: null,\n    circleHead: null,\n    triangleHead: null,\n    lineMeterHead: null,\n    barHead: null,\n    sliderHead: null,\n    iconHead: null,\n    gifHead: null,\n}\nlet protocol: Protocol = Protocol.IIC;\nlet chartID = 0;\nlet axisListX: string[] = [];\nlet axisListY: string[] = [];\nlet axisYData: number[] = [];\nlet seriesData: any = {};\nlet dataFactor = 1; // \"data coordinate conversion factors\n\n/**\n * Original block \"ColorScreen I2C initialization\"\n */\nfunction lcdInitIIC() {\n    creatList();\n    protocol = Protocol.IIC;\n    basic.pause(1000);\n}\n\n/**\n * Original block \"clear the screen\"\n */\nfunction lcdClearAll() {\n    cleanScreen();\n}\n\n/**\n * Original block \"set the background color %color\"\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdSetBgcolor(color: number) {\n    setBackgroundColor(colorToCustom(color));\n}\n\n/**\n * Original block \"red %red green %green blue %blue\"\n * Convert red, green and blue channels into a RGB color\n * @param red to red ,eg: 255 (min 0, max 255, default 255)\n * @param green to green ,eg: 255 (min 0, max 255, default 255)\n * @param blue to blue ,eg: 255 (min 0, max 255, default 255)\n */\nfunction lcdGetRgbColor(red: number, green: number, blue: number): number {\n    return (red << 16) + (green << 8) + (blue);\n}\n\n/**\n * Original block \"set the background picture %picture\"\n * @param picture to picture ,eg: \"fruit.png\"\n */\nfunction lcdSetBgIamge(picture: string) {\n    //setBackgroundImg(0, picture); // Internal storage of pictures\n    setBackgroundImg(1, picture); // Usb flash drive to store pictures\n}\n\n/**\n * Original block \"display text %text number %num position x: %x y: %y size %size color %color\"\n * @param text to text ,eg: \"hello\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayText(text: string, num: number, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, text, size, color);\n}\n\n/**\n * Original block \"display time number %num time %time position x: %x y: %y size %size color %color\"\n * Was marked as deprecated.\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param time to time ,eg: \"12:40:30\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayTime(num: number, time: string, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, time, size, color);\n}\n\n/**\n * Original block \"hour %hour minutes %min second %sec\"\n * @param hour to hour ,eg: 12 (min 0, max 23, default 12)\n * @param min to min ,eg: 40 (min 0, max 59, default 40)\n * @param sec to sec ,eg: 30 (min 0, max 59, default 30)\n */\nfunction lcdGetTime(hour: number, min: number, sec: number): string {\n    return `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`\n}\n\n/**\n * Original block \"display image number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param name to name ,eg: \"/expression icon/happy.png\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayImage(num: number, name: string, x: number, y: number, size: number) {\n    updateIcon(num, x, y, name, size);\n}\n\n/**\n * Original block \"rotate image number %num angle %angle\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param angle to angle ,eg: 180 (min 0, max 360, default 180)\n */\nfunction lcdRotateIamge(num: number, angle: number) {\n    setAngleIcon(num, angle * 10);\n}\n\n/**\n * Original block \"display gif number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1\n * @param name to name ,eg: \"Snowy.gif\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayGif(num: number, name: string, x: number, y: number, size: number) {\n    updateGif(num, x, y, name, size);\n}\n\n/**\n * Original block \"draw line number %num start x1: %x1 y1: %y1 end x2: %x2 y2: %y2 width %width color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 40 (min 0, max 320, default 40)\n * @param y1 to y1 ,eg: 120 (min 0, max 240, default 120)\n * @param x2 to x2 ,eg: 300 (min 0, max 320, default 300)\n * @param y2 to y2 ,eg: 120 (min 0, max 240, default 120)\n * @param width to width ,eg: 20\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawLine(num: number, x1: number, y1: number, x2: number, y2: number, width: number, color: number) {\n    updateLine(num, x1, y1, x2, y2, width, color);\n}\n\n/**\n * Original block \"draw rectangle number %num start x: %x y: %y width %w height %h line width %width Border color %bocolor %fill color %fcolor %round\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param w to w ,eg: 300 (min 0, max 320, default 300)\n * @param h to h ,eg: 200 (min 0, max 240, default 200)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n * @param round to round ,eg: lcdDisplay.RectangleRound.NoneRound\n */\nfunction lcdDrawRectangle(num: number, x: number, y: number, w: number, h: number, width: number, bocolor: number, fill: DrawType, fcolor: number, round: RectangleRound) {\n    updateRect(num, x, y, w, h, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor, round === RectangleRound.IsRound ? 1 : 0);\n}\n\n/**\n * Original block \"draw circle number %num center x: %x y: %y radius %r line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 160 (min 0, max 320, default 160)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param r to r ,eg: 120 (min 0, max 120, default 120)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawCircle(num: number, x: number, y: number, r: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateCircle(num, x, y, r, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw triangle number %num x1: %x1 y1: %y1 x2: %x2 y2: %y2 x3: %x3 y3: %y3 line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 160 (min 0, max 320, default 160)\n * @param y1 to y1 ,eg: 0 (min 0, max 240, default 0)\n * @param x2 to x2 ,eg: 0 (min 0, max 320, default 0)\n * @param y2 to y2 ,eg: 240 (min 0, max 240, default 240)\n * @param x3 to x3 ,eg: 320 (min 0, max 320, default 320)\n * @param y3 to y3 ,eg: 240 (min 0, max 240, default 240)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawTriangle(num: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateTriangle(num, x1, y1, x2, y2, x3, y3, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw slider number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawSlider(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateSlider(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw bar number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawBar(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateBar(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw compass number %num position x: %x y: %y radius %r\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n */\nfunction lcdDrawCompass(num: number, x: number, y: number, r: number) {\n    updateCompass(num, x, y, r);\n}\n\n/**\n * Original block \"draw gauge number %num position x: %x y: %y radius %r start of scale %start End of scale %end Pointer color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 360 (min 0, max 360, default 360)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawGauge(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateGauge(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"draw lineMeter number %num position x: %x y: %y radius %r start of scale %start End of scale %end Data color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 100 (min 0, max 360, default 100)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawLineMeter(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateLineMeter(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"set %type=LCDWidgetCategoryOne_conv widget number %num data %data\"\n * @param type to type ,eg: LCDWidgetCategoryOne.Slider\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param data to data ,eg: 80\n */\nfunction lcdSetWidgetData(type: number, num: number, data: number) {\n    switch (type) {\n        case LCDWidgetCategoryOne.Slider:\n            setSliderValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Bar:\n            setBarValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Compass:\n            setCompassScale(num, (data / 360) * 3600);\n            break;\n        case LCDWidgetCategoryOne.Gauge:\n            setGaugeValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.LineMeter:\n            setMeterValue(num, data);\n            break;\n        default:\n            break;\n    }\n}\n\n/**\n * Original block \"draw chart number %num X-axis %xaxis Y-axis %yaxis background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan Feb Mar Apr May Jun\"\n * @param yaxis to yaxis ,eg: \"100 80 60 40 20 0\"\n * @param color to color ,eg: 0xFFFFFF\n * @param styles to styles ,eg: ChartStyles.LineChart\n */\nfunction lcdDrawChart(num: number, xaxis: string, yaxis: string, color: number, styles: ChartStyles) {\n    chartID = num;\n    axisListX = xaxis.split(\" \");\n    axisListY = yaxis.split(\" \");\n    axisListX.forEach((value, index) => { axisYData.push(0) });\n    dataFactor = Math.abs((parseInt(axisListY[0]) - parseInt(axisListY[axisListY.length - 1])) / 100);\n    updateChart(chartID, color, styles);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 0, axisListX);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 1, axisListY);\n}\n\n/**\n * Original block \"Set chart data number %num color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdAddChartData(num: number, color: number) {\n    seriesData[num] = axisYData;\n    updateChartSeries(chartID, num, color);\n    addChartSeriesData(chartID, num, seriesData[num], axisListX.length)\n}\n\n/**\n * Original block \"set chart data number %num X-axis %xaxis data %data\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan\"\n * @param data to data ,eg: 80\n */\nfunction lcdSetChartData(num: number, xaxis: string, data: number) {\n    let index = axisListX.indexOf(xaxis);\n    if (data < parseInt(axisListY[axisListY.length - 1]) || data > parseInt(axisListY[0]))\n        return\n    if (index !== -1) {\n        updateChartPoint(chartID, num, index, Math.round((data - parseInt(axisListY[axisListY.length - 1])) / dataFactor));\n        // seriesData[num][index] = Math.round(data / 10);\n    }\n}\n\n/**\n * Original block \"update chart number %num background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0x007FFF\n * @param styles to styles ,eg: lcdDisplay.ChartStyles.BarChart\n */\nfunction lcdUpdateChart(num: number, color: number, styles: ChartStyles) {\n    updateChart(num, color, styles);\n}\n\n/**\n * Original block \"delete %type=LCDWidgetCategoryTwo_conv number %num\"\n * @param type to type ,eg: LCDWidgetCategoryTwo.Text\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n */\nfunction lcdDeleteWidget(type: number, num: number) {\n    switch (type) {\n        case LCDWidgetCategoryTwo.Slider:\n            deleteSlider(num);\n            break;\n        case LCDWidgetCategoryTwo.Bar:\n            deleteBar(num);\n            break;\n        case LCDWidgetCategoryTwo.Compass:\n            deleteCompass(num);\n            break;\n        case LCDWidgetCategoryTwo.Gauge:\n            deleteGauge(num);\n            break;\n        case LCDWidgetCategoryTwo.LineMeter:\n            deleteLineMeter(num);\n            break;\n        case LCDWidgetCategoryTwo.Chart:\n            deleteChart(num);\n            break;\n        case LCDWidgetCategoryTwo.Text:\n            deleteString(num);\n            break;\n        case LCDWidgetCategoryTwo.Line:\n            deleteLine(num);\n            break;\n        case LCDWidgetCategoryTwo.Rectangle:\n            deleteRect(num);\n            break;\n        case LCDWidgetCategoryTwo.Circle:\n            deleteCircle(num);\n            break;\n        case LCDWidgetCategoryTwo.Triangle:\n            deleteTriangle(num);\n            break;\n        case LCDWidgetCategoryTwo.Icon:\n            deleteIcon(num);\n            break;\n        case LCDWidgetCategoryTwo.Gif:\n            deleteGif(num);\n        default:\n            break;\n    }\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryOne_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryOne number\n */\nfunction getWidgetCategoryOne(item: LCDWidgetCategoryOne): number {\n    return item as number;\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryTwo_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryTwo number\n */\nfunction getLCDWidgetCategoryTwo(item: LCDWidgetCategoryTwo): number {\n    return item as number;\n}\n\nfunction cleanScreen() {\n    let cmd = creatCommand(0x1D, 0x04);\n    writeCommand(cmd, 4);\n    basic.pause(1500);\n}\n\nfunction setBackgroundColor(color: number) {\n    let cmd = creatCommand(CMD_SET_BACKGROUND_COLOR, CMD_SET_LEN);\n    cmd = cmd.concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_SET_LEN);\n    basic.pause(300);\n}\n\nfunction setBackgroundImg(location: number, str: string) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_SET_BACKGROUND_IMG, len + 5);\n    cmd = cmd.concat([location]);\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 5);\n}\n\nfunction drawString(x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TEXT), fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction updateString(id: number, x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([id, fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction deleteString(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TEXT, id])\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.textHead, id);\n}\n\nfunction drawLcdTime(x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    drawString(x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction updateLcdTime(id: number, x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    updateString(id, x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction drawIcon(x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_ICON_INTERNAL)]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction setAngleIcon(id: number, angle: number) {\n    let cmd = creatCommand(CMD_SET_ANGLE_OBJ, CMD_SET_ANGLE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]).concat(data16Tobyte(angle));\n    writeCommand(cmd, CMD_SET_ANGLE_OBJ_LEN);\n}\n\nfunction updateIcon(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteIcon(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.iconHead, id);\n}\n\nfunction drawGif(x: number, y: number, str: string, zoom: number): number {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    let id = getID(CMD_OF_DRAW_GIF_EXTERNAL);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n    return id;\n}\n\nfunction updateGif(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteGif(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GIF_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gifHead, id);\n}\n\nfunction drawLine(x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE), width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n}\n\nfunction updateLine(id: number, x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([id, width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n    basic.pause(10);\n}\n\nfunction deleteLine(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineHead, id);\n}\n\nfunction drawRect(x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_RECT), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction updateRect(id: number, x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction deleteRect(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_RECT, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.rectHead, id);\n}\n\nfunction drawCircle(x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_CIRCLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction updateCircle(id: number, x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction deleteCircle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_CIRCLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.circleHead, id);\n}\n\nfunction drawTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TRIANGLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction updateTriangle(id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction deleteTriangle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TRIANGLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.triangleHead, id);\n}\n\nfunction creatSlider(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_SLIDER)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction updateSlider(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction setSliderValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER_VALUE, CMD_SET_SLIDER_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_SLIDER_VALUE_LEN);\n}\n\nfunction deleteSlider(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_SLIDER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.sliderHead, id);\n}\n\nfunction creatBar(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_BAR)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction updateBar(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction setBarValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR_VALUE, CMD_SET_BAR_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_BAR_VALUE_LEN);\n}\n\nfunction deleteBar(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_BAR, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.barHead, id);\n}\n\nfunction creatCompass(x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_COMPASS)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction updateCompass(id: number, x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction setCompassScale(id: number, scale: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS_VALUE, CMD_SET_COMPASS_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(scale));\n    writeCommand(cmd, CMD_SET_COMPASS_VALUE_LEN);\n}\n\nfunction deleteCompass(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_COMPASS, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.compassHead, id);\n}\n\nfunction creatGauge(x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_GAUGE)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction updateGauge(id: number, x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction setGaugeValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE_VALUE, CMD_SET_GAUGE_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_GAUGE_VALUE_LEN);\n}\n\nfunction deleteGauge(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GAUGE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gaugeHead, id);\n}\n\nfunction creatLineMeter(x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE_METER)]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction updateLineMeter(id: number, x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction setTopLineMeter(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n}\n\nfunction deleteLineMeter(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineMeterHead, id);\n}\n\nfunction creatChart(strX: string[], strY: string[], bgColor: number, type: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    let id = getID(CMD_OF_DRAW_LINE_CHART);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n    basic.pause(100);\n    setChartAxisTexts(id, 0, strX);\n    basic.pause(100);\n    setChartAxisTexts(id, 1, strY);\n    return id;\n}\n\nfunction updateChart(id: number, bgColor: number, type: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n}\n\nfunction creatChartSeries(chartId: number, color: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    let serieId = getID(CMD_OF_DRAW_SERIE);\n    cmd = cmd.concat([serieId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n    return serieId;\n}\n\nfunction updateChartSeries(chartId: number, seriesId: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    cmd = cmd.concat([seriesId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n}\n\nfunction setChartAxisTexts(chartId: number, axis: number, text: string[]) {\n    let len = text.length - 1;\n    text.forEach((value, index) => { len = len + value.length });\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART_TEXT, len + 6);\n    cmd = cmd.concat([chartId, axis]);\n    for (let i = 0; i < text.length; i++) {\n        text[i].split(\"\").forEach((value, index) => {\n            cmd.push(value.charCodeAt(0))\n        })\n        if (i != text.length - 1) {\n            cmd.push(0x0A); // \"\\n\"\n        }\n    }\n    writeCommand(cmd, len + 6);\n}\n\nfunction updateChartPoint(chartId: number, seriesId: number, pointNum: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, 10);\n    cmd = cmd.concat([chartId, seriesId, 1, pointNum]).concat(data16Tobyte(value));\n    writeCommand(cmd, 10);\n}\n\nfunction addChartSeriesData(chartId: number, seriesId: number, point: number[], len: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, len * 2 + 8);\n    cmd = cmd.concat([chartId, seriesId, 0, 0]);\n    point.forEach((value, index) => { cmd = cmd.concat(data16Tobyte(value)) });\n    writeCommand(cmd, len * 2 + 8);\n    return 1;\n}\n\nfunction setTopChart(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_SET_TOP_OBJ_LEN);\n}\n\nfunction deleteChart(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineChartHead, id);\n}\n\nfunction setMeterValue(lineMeterId: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER_VALUE, CMD_SET_LINE_METER_VALUE_LEN);\n    cmd = cmd.concat([lineMeterId]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_LINE_METER_VALUE_LEN);\n}\n\n/********************************************************************************************************************/\nfunction creatList() {\n    list.lineChartHead = new LinkedList();\n    list.seriesHead = new LinkedList();\n    list.compassHead = new LinkedList();\n    list.textHead = new LinkedList();\n    list.gaugeHead = new LinkedList();\n    list.lineHead = new LinkedList();\n    list.rectHead = new LinkedList();\n    list.circleHead = new LinkedList();\n    list.triangleHead = new LinkedList();\n    list.lineMeterHead = new LinkedList();\n    list.barHead = new LinkedList();\n    list.sliderHead = new LinkedList();\n    list.iconHead = new LinkedList();\n    list.gifHead = new LinkedList();\n}\n\nfunction getID(type: number): number {\n    let id = 0;\n    switch (type) {\n        case CMD_OF_DRAW_LINE_CHART:\n            id = getNewID(list.lineChartHead);\n            break;\n        case CMD_OF_DRAW_SERIE:\n            id = getNewID(list.seriesHead);\n            break;\n        case CMD_OF_DRAW_COMPASS:\n            id = getNewID(list.compassHead);\n            break;\n        case CMD_OF_DRAW_TEXT:\n            id = getNewID(list.textHead);\n            break;\n        case CMD_OF_DRAW_GAUGE:\n            id = getNewID(list.gaugeHead);\n            break;\n        case CMD_OF_DRAW_LINE:\n            id = getNewID(list.lineHead);\n            break;\n        case CMD_OF_DRAW_RECT:\n            id = getNewID(list.rectHead);\n            break;\n        case CMD_OF_DRAW_TRIANGLE:\n            id = getNewID(list.triangleHead);\n            break;\n        case CMD_OF_DRAW_CIRCLE:\n            id = getNewID(list.circleHead);\n            break;\n        case CMD_OF_DRAW_LINE_METER:\n            id = getNewID(list.lineMeterHead);\n            break;\n        case CMD_OF_DRAW_BAR:\n            id = getNewID(list.barHead);\n            break;\n        case CMD_OF_DRAW_SLIDER:\n            id = getNewID(list.sliderHead);\n            break;\n        case CMD_OF_DRAW_ICON_INTERNAL:\n            id = getNewID(list.iconHead);\n            break;\n        case CMD_OF_DRAW_GIF_INTERNAL:\n            id = getNewID(list.gifHead);\n            break;\n        default:\n            break;\n    }\n    return id;\n}\n\nfunction getNewID(linkList: LinkedList): number {\n    linkList.append();\n    return linkList.head.id;\n}\n\nfunction deleteNodeByID(linkList: LinkedList, id: number) {\n    linkList.removeId(id);\n}\n\nfunction data16Tobyte(data: number): number[] {\n    return [(data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction data24Tobyte(data: number): number[] {\n    return [(data >> 16) & 0xFF, (data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction colorToCustom(color: number): number {\n    switch (color) {\n        case 0x999999:\n            return 0x696969;\n        case 0x7f00ff:\n            return 0x800080;\n        default:\n            return color;\n    }\n}\n\nfunction creatCommand(cmd: number, len: number): number[] {\n    return [CMD_HEADER_HIGH, CMD_HEADER_LOW, len - CMDLEN_OF_HEAD_LEN, cmd];\n}\n\nfunction writeCommand(data: number[], len: number) {\n    // serial.writeNumbers(data);\n    if (protocol == Protocol.IIC) {\n        let remain = len;\n        let i = 0;\n        while (remain > 0) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? 32 : remain;\n            if (remain > IIC_MAX_TRANSFER_SIZE) {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), true);\n            } else {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), false);\n            }\n            remain = remain - currentTransferSize;\n            i = i + 1;\n        }\n    } else {\n    }\n}\n\nfunction readACK(length: number): Buffer {\n    if (protocol == Protocol.IIC) {\n        let remain = length;\n        let buf: Buffer = pins.createBuffer(0);\n        while (remain) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? IIC_MAX_TRANSFER_SIZE : remain;\n            buf = buf.concat(pins.i2cReadBuffer(address, currentTransferSize));\n            remain = remain - currentTransferSize;\n        }\n        return buf;\n    } else {\n        let buf: Buffer = pins.createBuffer(0);\n        return buf;\n    }\n}\n\n// --------------------------------------\n// End of code from DFRobot lcdDisplay extension\n// --------------------------------------\n\n\n//% blockNamespace=storybrain\nclass StoryMessage {\n    _sender: string;\n    _message: string;\n\n    constructor(sender: string, message: string) {\n        this._sender = sender;\n        this._message = message;\n    }\n\n    //% blockCombine\n    get text() { return this._message }\n\n    //% blockCombine\n    get sender() { return this._sender }\n}\n\n//% color=\"#402504\" icon=\"\\uf02d\" block=\"Story brain\"\nnamespace storybrain {\n\n    const ROOM_ELEMENT_IMAGE_CODE_UNKNOWN: string = 'def';\n\n    /**\n     * Information about an image for an escape room element.\n     */\n    class RoomElementImage {\n        code: string;\n        private _filename: string;\n\n        /**\n         * Constructs the image using \n         */\n        constructor(code: string = null) {\n            if (code === null) {\n                this.code = ROOM_ELEMENT_IMAGE_CODE_UNKNOWN;\n            } else {\n                this.code = code;\n            }\n            this._filename = this.code.toLowerCase();\n        }\n\n        public getFilePath(fresh: boolean = true) {\n            if (fresh) {\n                return \"/escape room icon/\" + this._filename + \"_mid.png\";\n            } else {\n                return \"/escape room icon/\" + this._filename + \"_dark.png\";\n            }\n\n        }\n    }\n\n    class RoomElement {\n        name: string;\n        lastCheckInTime: number;  // Millis since power on.\n        image: RoomElementImage;\n        fresh: boolean;\n        changedState: boolean;\n\n        constructor(name: string, imageCode: string = null) {\n            this.name = name;\n            this.image = new RoomElementImage(imageCode);\n            this.fresh = true;\n            this.changedState = true;\n            this.checkIn();\n        }\n\n        checkIn() {\n            this.lastCheckInTime = control.millis();\n            if (!this.fresh) {\n                this.fresh = true;\n                this.changedState = true;\n            }\n        }\n\n        // Call after updating widget on screen.\n        update() {\n            this.changedState = false;\n            if (this.fresh) {\n                if (control.millis() - this.lastCheckInTime > 8000) {\n                    this.fresh = false;\n                    this.changedState = true;\n                }\n            }\n        }\n    }\n\n    function getIconXPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2;\n            case 2: return 2;\n            case 3: return 2;\n            case 4: return 2;\n            case 5: return 2 + 45 * 1;\n            case 6: return 2 + 45 * 2;\n            case 7: return 2 + 45 * 3;\n            case 8: return 2 + 45 * 4;\n            case 9: return 2 + 45 * 5;\n            case 10: return 2 + 45 * 6;\n            case 11: return 2 + 45 * 6;\n            case 12: return 2 + 45 * 6;\n            case 13: return 2 + 45 * 6;\n            case 14: return 2 + 45 * 6;\n            case 15: return 2 + 45 * 5;\n            case 16: return 2 + 45 * 4;\n            case 17: return 2 + 45 * 3;\n            case 18: return 2 + 45 * 2;\n            case 19: return 2 + 45 * 1;\n            default: return 0;\n        }\n    }\n\n    function getIconYPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2 + 47 * 1;\n            case 2: return 2 + 47 * 2;\n            case 3: return 2 + 47 * 3;\n            case 4: return 2 + 47 * 4;\n            case 5: return 2 + 47 * 4;\n            case 6: return 2 + 47 * 4;\n            case 7: return 2 + 47 * 4;\n            case 8: return 2 + 47 * 4;\n            case 9: return 2 + 47 * 4;\n            case 10: return 2 + 47 * 4;\n            case 11: return 2 + 47 * 3;\n            case 12: return 2 + 47 * 2;\n            case 13: return 2 + 47 * 1;\n            case 14: return 2;\n            case 15: return 2;\n            case 16: return 2;\n            case 17: return 2;\n            case 18: return 2;\n            case 19: return 2;\n            default: return 0;\n        }\n    }\n\n    let roomName: string = 'UNNAMED'\n    let brainInitialized: boolean = false;\n    let startInitializationTime: number;\n    let statusText: string = '';\n    let statusColour: number = lcdGetRgbColor(255, 0, 0);\n    let updatingScreen: boolean = false;\n    const registeredElements: RoomElement[] = [];\n    const uncheckedStoryMessages: StoryMessage[] = [];\n\n    /**\n     * Set up the story brain for the escape room.\n     * @param room the unique name for the room (use a maximum of 4 regular letters)\n     * @param radioGroup the radio group for the room, unique in the vicinity\n    */\n    //% block=\"initialise brain with room name $room and radio group $radioGroup\"\n    //% blockGap=50\n    //% weight=100\n    //% room.defl=\"room\"\n    //% radioGroup.min=0 radioGroup.max=255 radioGroup.defl=20\n    export function initialiseBrain(room: string, radioGroup: number) {\n        initialise(room, radioGroup);\n    }\n\n    /**\n     * Returns true if there any unchecked messages available to grab.\n    */\n    //% block=\"unchecked messages available\"\n    //% weight=52\n    export function uncheckedMessagesAvailable(): boolean {\n        return (uncheckedStoryMessages.length > 0);\n    }\n\n    /**\n     * Grab the next unchecked message, removing it from the inbox.\n    */\n    //% block=\"grab next unchecked message\"\n    //% weight=51\n    //% blockSetVariable=storymessage\n    export function grabNextUncheckedMessage(): StoryMessage {\n        while (updatingScreen) {\n            basic.pause(1);\n        }\n        if (uncheckedStoryMessages.length > 0) {\n            return uncheckedStoryMessages.pop();\n        }\n        return new StoryMessage('no message', 'no message');\n    }\n\n    /**\n     * Use the story brain's colour screen to display a short status message.\n     */\n    //% block=\"Display status $text in $colour\"\n    //% colour.shadow=\"colorNumberPicker\"\n    //% advanced=true\n    //% weight=10\n    export function setStatus(text: string, colour: number) {\n        statusText = text;\n        statusColour = colour;\n    }\n\n    /**\n     * Clear status message on the story brain's colour screen.\n     */\n    //% block=\"Clear status\"\n    //% advanced=true\n    //% weight=9\n    export function clearStatus() {\n        statusText = '';\n    }\n\n    // Ensures that an element is kept up to date in the registeredElements array.\n    function registerElement(name: string, imageCode: string = null) {\n        for (let element of registeredElements) {\n            if (element.name.toUpperCase() === name) {\n                element.checkIn();\n                return;\n            }\n        }\n        registeredElements.push(new RoomElement(name, imageCode));\n    }\n\n    // Capture and process all radio messages coming in as strings.\n    /*\n    / Check-in messages are formatted as follows:   [room name]*[element name]\n    / Check-in messages can also be formatted to give an image:   [room name]*[element name]*I*[image code]\n    / Trigger messages are formatted as follows:   [room name]*[element name]*[message]\n    /\n    / room name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all escape rooms in the vicinity.\n    / element name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all elements in this escape room.\n    / message is a string of no more than 9 characters. Asterisk not allowed.\n    /\n    / Case is always ignored when comparing, so names and IDs must be unique ignoring case.\n    */\n    radio.onReceivedString(function (receivedString: string) {\n        if (!brainInitialized) {\n            return;\n        }\n\n        let messageParts: string[] = receivedString.split('*');\n\n        // If the received string could not be split, ignore it.\n        if (messageParts.length <= 1) {\n            return;\n        }\n        // If the room name doesn't match, ignore it.\n        if (messageParts[0].toUpperCase() != roomName.toUpperCase()) {\n            return;\n        }\n        // Process a basic check-in string.\n        if (messageParts.length == 2) {\n            registerElement(messageParts[1]);\n            return;\n        }\n        // Process an advanced check-in string.\n        if (messageParts.length == 4) {\n            registerElement(messageParts[1], messageParts[3]);\n            return;\n        }\n        registerElement(messageParts[1]);\n        // Process a true story message, but ignore if there is already an unchecked message from that element.\n        for (let message of uncheckedStoryMessages) {\n            if (message.sender.toUpperCase() == messageParts[1].toUpperCase()) {\n                return;\n            }\n        }\n        uncheckedStoryMessages.unshift(new StoryMessage(messageParts[1], messageParts[2]));\n    });\n\n    // Sets up the story brain with a room name and radio group unique in the vicinity.\n    // Must be called before other functions will work.\n    function initialise(room: string, radioGroup: number) {\n        roomName = room;\n        radio.setGroup(radioGroup);\n        lcdInitIIC();\n        lcdClearAll();\n        lcdSetBgcolor(lcdGetRgbColor(0, 0, 0));\n        lcdDisplayImage(250, '/escape room icon/story_brain.png', 123, 71, 255);\n        lcdDisplayText(roomName, 251, 123, 143, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n        startInitializationTime = control.millis();\n    }\n\n    registerElement('box', 'box');\n    registerElement('btns', 'press');\n    registerElement('hmmm');\n    registerElement('tes1');\n    registerElement('tes2');\n    registerElement('tes3');\n    registerElement('tes4');\n    registerElement('tes5');\n    registerElement('tes6');\n    registerElement('tes7');\n    registerElement('tes8');\n    registerElement('tes9');\n    registerElement('tes10');\n    registerElement('tes11');\n    registerElement('tes12');\n    registerElement('tes13');\n    registerElement('tes14');\n    registerElement('tes15');\n    registerElement('tes16');\n    registerElement('tes17');\n    uncheckedStoryMessages.unshift(new StoryMessage('box', 'hello'));\n    uncheckedStoryMessages.unshift(new StoryMessage('btns', 'yo'));\n    uncheckedStoryMessages.unshift(new StoryMessage('hmmm', 'hi!'));\n\n    basic.forever(function () {\n        basic.pause(200);\n\n        if (!brainInitialized) {\n            if (control.millis() - startInitializationTime > 2000) {\n                brainInitialized = true;\n            } else {\n                return;\n            }\n        }\n\n        // Update elements on screen.\n        updatingScreen = true;\n        for (let i = 0; i < registeredElements.length; i++) {\n            let widgetOrder = (i + 1) * 3;\n            if (registeredElements[i].changedState) {\n                let path;\n                let textColour;\n                if (registeredElements[i].fresh) {\n                    path = registeredElements[i].image.getFilePath();\n                    textColour = lcdGetRgbColor(255, 255, 255)\n                } else {\n                    path = registeredElements[i].image.getFilePath(false);\n                    textColour = lcdGetRgbColor(128, 128, 128)\n                }\n                lcdDisplayImage(widgetOrder, path, getIconXPlacement(i), getIconYPlacement(i), 255);\n                basic.pause(5);  // Pause added to avoid overload in communication with screen.\n                lcdDisplayText(registeredElements[i].name, widgetOrder + 1, getIconXPlacement(i) + 6, getIconYPlacement(i) + 46 - 2 - 18, FontSize.Small, textColour);\n                basic.pause(5);  // Pause added to avoid overload in communication with screen.\n            }\n            // Draw a line if there is an unchecked message from that element.\n            let lineToDraw = false;\n            for (let message of uncheckedStoryMessages) {\n                if (message.sender.toUpperCase() == registeredElements[i].name.toUpperCase()) {\n                    lineToDraw = true;\n                }\n            }\n            if (lineToDraw) {\n                lcdDrawLine(widgetOrder + 2, getIconXPlacement(i) + 23, getIconYPlacement(i) + 23, 159, 119, 5, lcdGetRgbColor(0, 255, 0));\n            } else {\n                lcdDeleteWidget(LCDWidgetCategoryTwo.Line, widgetOrder + 2);\n            }\n            registeredElements[i].update();\n            // Custom status display.\n            if (statusText.length > 0) {\n                lcdDisplayText(statusText, 200, 72, 166, FontSize.Small, statusColour);\n            } else {\n                lcdDeleteWidget(LCDWidgetCategoryTwo.Text, 200);\n            }\n        }\n        updatingScreen = false;\n    })\n\n}\n\n// Test code.\nstorybrain.initialiseBrain('Mars', 10);\n\nbasic.forever(function () {\n    pause(6000);\n    while (storybrain.uncheckedMessagesAvailable()) {\n        let myMessage: StoryMessage = storybrain.grabNextUncheckedMessage();\n        basic.showString(myMessage.text, 100);\n    }\n    if (storybrain.uncheckedMessagesAvailable()) {\n        storybrain.setStatus('Messages still available.', 254);\n    }\n})\n\n","README.md":"","pxt.json":"{\n    \"name\": \"story brain experiments\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1762116378016,"editorVersion":"8.0.18","text":{"main.ts":"// --------------------------------------\n// Code from DFRobot lcdDisplay extension\n// --------------------------------------\n// Original code has MIT license and copyright (c) 2021 TgJe.\n// Available at: https://github.com/DFRobot/pxt-DFRobot_lcdDisplay\n// Modified to hide blocks that access display directly.\n\nconst enum LCDWidgetCategoryOne {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n}\n\nconst enum LCDWidgetCategoryTwo {\n    Slider = 1,\n    Bar = 2,\n    Compass = 3,\n    Gauge = 4,\n    LineMeter = 5,\n    Chart = 6,\n    Text = 7,\n    Line = 8,\n    Rectangle = 9,\n    Circle = 10,\n    Triangle = 11,\n    Icon = 12,\n    Gif = 13,\n}\n\nenum FontSize {\n    Large = 1,\n    Small = 2,\n}\n\nenum RectangleRound {\n    IsRound = 1,\n    NoneRound = 2,\n}\n\nenum ChartStyles {\n    LineChart = 3,\n    BarChart = 2,\n    ShadingLineChart = 1,\n}\n\nenum DrawType {\n    Fill = 1,\n    NotFill = 2,\n}\n\nenum Protocol {\n    IIC = 1,\n    Serial = 2,\n}\n\nconst IIC_MAX_TRANSFER_SIZE = 32;\n\n// cmd len\nconst CMDLEN_OF_HEAD_LEN = 3;\nconst CMD_DELETE_OBJ_LEN = 0x06;\nconst CMD_SET_TOP_OBJ_LEN = 0x06;\nconst CMD_SET_COMPASS_VALUE_LEN = 0x07;\nconst CMD_SET_LEN = 0x07;\nconst CMD_SET_GAUGE_VALUE_LEN = 0x07;\nconst CMD_SET_LINE_METER_VALUE_LEN = 0x07;\nconst CMD_SET_BAR_VALUE_LEN = 0x07;\nconst CMD_SET_SLIDER_VALUE_LEN = 0x07;\nconst CMD_SET_ANGLE_OBJ_LEN = 0x08;\nconst CMD_DRAW_COMPASS_LEN = 0x0B;\nconst CMD_DRAW_CHART_LEN = 0x09;\nconst CMD_DRAW_SERIE_LEN = 0x09;\nconst CMD_OF_DRAW_ICON_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_GIF_INTERNAL_LEN = 0x0D;\nconst CMD_OF_DRAW_BAR_LEN = 0x10;\nconst CMD_OF_DRAW_SLIDER_LEN = 0x10;\nconst CMD_DRAW_PIXEL_LEN = 0x11;\nconst CMD_DRAW_LINE_LEN = 0x11;\nconst CMD_OF_DRAW_CIRCLE_LEN = 0x13;\nconst CMD_OF_DRAW_GAUGE_LEN = 0x15;\nconst CMD_OF_DRAW_LINE_METER_LEN = 0x15;\nconst CMD_OF_DRAW_RECT_LEN = 0x16;\nconst CMD_OF_DRAW_TRIANGLE_LEN = 0x19;\n\n// cmd\nconst CMD_SET_BACKGROUND_COLOR = 0x19;\nconst CMD_SET_BACKGROUND_IMG = 0x1A;\nconst CMD_OF_DRAW_PIXEL = 0x02;\nconst CMD_OF_DRAW_LINE = 0x03;\nconst CMD_OF_DRAW_RECT = 0x04;\nconst CMD_OF_DRAW_CIRCLE = 0x06;\nconst CMD_OF_DRAW_TRIANGLE = 0x07;\nconst CMD_OF_DRAW_ICON_INTERNAL = 0x08;\nconst CMD_OF_DRAW_ICON_EXTERNAL = 0x09;\nconst CMD_OF_DRAW_BAR = 0x0A;\nconst CMD_OF_DRAW_BAR_VALUE = 0x0B;\nconst CMD_OF_DRAW_SLIDER = 0x0C;\nconst CMD_OF_DRAW_SLIDER_VALUE = 0x0D;\nconst CMD_OF_DRAW_LINE_METER = 0x10;\nconst CMD_OF_DRAW_LINE_METER_VALUE = 0x11;\nconst CMD_OF_DRAW_COMPASS = 0x0E;\nconst CMD_OF_DRAW_COMPASS_VALUE = 0x0F;\nconst CMD_OF_DRAW_GAUGE = 0x12;\nconst CMD_OF_DRAW_GAUGE_VALUE = 0x13;\nconst CMD_OF_DRAW_LINE_CHART = 0x14;\nconst CMD_OF_DRAW_LINE_CHART_TEXT = 0x15;\nconst CMD_OF_DRAW_SERIE = 0x16;\nconst CMD_OF_DRAW_SERIE_DATA = 0x17;\nconst CMD_OF_DRAW_TEXT = 0x18;\nconst CMD_DELETE_OBJ = 0x1B;\nconst CMD_SET_TOP_OBJ = 0x1C;\nconst CMD_SET_ANGLE_OBJ = 0x1E;\nconst CMD_OF_DRAW_GIF_INTERNAL = 0x1F;\nconst CMD_OF_DRAW_GIF_EXTERNAL = 0x20;\n\nconst CMD_HEADER_HIGH = 0x55;\nconst CMD_HEADER_LOW = 0xaa;\n\nlet address = 0x2c;\nclass GenericNode {\n    id: number\n    next: GenericNode\n    constructor(id: number) {\n        this.id = id;\n        this.next = null;\n    }\n}\n\nclass LinkedList {\n    head: GenericNode\n    size: number\n    id: number\n    constructor() {\n        this.head = null;\n        this.size = 0;\n        this.id = 1;\n    }\n\n    // adds a node to the end of the linked list\n    append() {\n        const newNode = new GenericNode(this.id);\n        if (this.head == null) {\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        this.size++;\n        this.id++;\n    }\n    // insert a node at a specific location\n    insert(index: number, id: number): boolean {\n        if (index < 0 || index > this.size) {\n            return false;\n        }\n        const newNode = new GenericNode(id);\n        if (index == 0) {\n            newNode.next = this.head;\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            newNode.next = current;\n            previous.next = newNode;\n        }\n        this.size++;\n        return true;\n    }\n    // removes a node at a specific location\n    removeAt(index: number): boolean {\n        if (index < 0 || index >= this.size || this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (index == 0) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            let i = 0;\n            while (i < index) {\n                previous = current;\n                current = current.next;\n                i++;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n\n    // example Remove a node with a specific id\n    removeId(id: number): boolean {\n        if (this.head == null) {\n            return false;\n        }\n        let current = this.head;\n        if (current.id == id) {\n            this.head = current.next;\n        } else {\n            let previous = null;\n            while (current.id != id) {\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.size--;\n        return true;\n    }\n}\n\ntype GenericList = {\n    lineChartHead: LinkedList | null,\n    seriesHead: LinkedList | null,\n    compassHead: LinkedList | null,\n    textHead: LinkedList | null,\n    gaugeHead: LinkedList | null,\n    lineHead: LinkedList | null,\n    rectHead: LinkedList | null,\n    circleHead: LinkedList | null,\n    triangleHead: LinkedList | null,\n    lineMeterHead: LinkedList | null,\n    barHead: LinkedList | null,\n    sliderHead: LinkedList | null,\n    iconHead: LinkedList | null,\n    gifHead: LinkedList | null,\n}\n\nlet list: GenericList = {\n    lineChartHead: null,\n    seriesHead: null,\n    compassHead: null,\n    textHead: null,\n    gaugeHead: null,\n    lineHead: null,\n    rectHead: null,\n    circleHead: null,\n    triangleHead: null,\n    lineMeterHead: null,\n    barHead: null,\n    sliderHead: null,\n    iconHead: null,\n    gifHead: null,\n}\nlet protocol: Protocol = Protocol.IIC;\nlet chartID = 0;\nlet axisListX: string[] = [];\nlet axisListY: string[] = [];\nlet axisYData: number[] = [];\nlet seriesData: any = {};\nlet dataFactor = 1; // \"data coordinate conversion factors\n\n/**\n * Original block \"ColorScreen I2C initialization\"\n */\nfunction lcdInitIIC() {\n    creatList();\n    protocol = Protocol.IIC;\n    basic.pause(1000);\n}\n\n/**\n * Original block \"clear the screen\"\n */\nfunction lcdClearAll() {\n    cleanScreen();\n}\n\n/**\n * Original block \"set the background color %color\"\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdSetBgcolor(color: number) {\n    setBackgroundColor(colorToCustom(color));\n}\n\n/**\n * Original block \"red %red green %green blue %blue\"\n * Convert red, green and blue channels into a RGB color\n * @param red to red ,eg: 255 (min 0, max 255, default 255)\n * @param green to green ,eg: 255 (min 0, max 255, default 255)\n * @param blue to blue ,eg: 255 (min 0, max 255, default 255)\n */\nfunction lcdGetRgbColor(red: number, green: number, blue: number): number {\n    return (red << 16) + (green << 8) + (blue);\n}\n\n/**\n * Original block \"set the background picture %picture\"\n * @param picture to picture ,eg: \"fruit.png\"\n */\nfunction lcdSetBgIamge(picture: string) {\n    //setBackgroundImg(0, picture); // Internal storage of pictures\n    setBackgroundImg(1, picture); // Usb flash drive to store pictures\n}\n\n/**\n * Original block \"display text %text number %num position x: %x y: %y size %size color %color\"\n * @param text to text ,eg: \"hello\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayText(text: string, num: number, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, text, size, color);\n}\n\n/**\n * Original block \"display time number %num time %time position x: %x y: %y size %size color %color\"\n * Was marked as deprecated.\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param time to time ,eg: \"12:40:30\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdDisplayTime(num: number, time: string, x: number, y: number, size: FontSize, color: number) {\n    updateString(num, x, y, time, size, color);\n}\n\n/**\n * Original block \"hour %hour minutes %min second %sec\"\n * @param hour to hour ,eg: 12 (min 0, max 23, default 12)\n * @param min to min ,eg: 40 (min 0, max 59, default 40)\n * @param sec to sec ,eg: 30 (min 0, max 59, default 30)\n */\nfunction lcdGetTime(hour: number, min: number, sec: number): string {\n    return `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`\n}\n\n/**\n * Original block \"display image number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param name to name ,eg: \"/expression icon/happy.png\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayImage(num: number, name: string, x: number, y: number, size: number) {\n    updateIcon(num, x, y, name, size);\n}\n\n/**\n * Original block \"rotate image number %num angle %angle\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param angle to angle ,eg: 180 (min 0, max 360, default 180)\n */\nfunction lcdRotateIamge(num: number, angle: number) {\n    setAngleIcon(num, angle * 10);\n}\n\n/**\n * Original block \"display gif number %num name %name position x: %x y: %y size %size\"\n * @param num to num ,eg: 1\n * @param name to name ,eg: \"Snowy.gif\"\n * @param x to x ,eg: 120 (min 0, max 320, default 120)\n * @param y to y ,eg: 120 (min 0, max 320, default 120)\n * @param size to size ,eg: FontSize.Large\n */\nfunction lcdDisplayGif(num: number, name: string, x: number, y: number, size: number) {\n    updateGif(num, x, y, name, size);\n}\n\n/**\n * Original block \"draw line number %num start x1: %x1 y1: %y1 end x2: %x2 y2: %y2 width %width color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 40 (min 0, max 320, default 40)\n * @param y1 to y1 ,eg: 120 (min 0, max 240, default 120)\n * @param x2 to x2 ,eg: 300 (min 0, max 320, default 300)\n * @param y2 to y2 ,eg: 120 (min 0, max 240, default 120)\n * @param width to width ,eg: 20\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawLine(num: number, x1: number, y1: number, x2: number, y2: number, width: number, color: number) {\n    updateLine(num, x1, y1, x2, y2, width, color);\n}\n\n/**\n * Original block \"draw rectangle number %num start x: %x y: %y width %w height %h line width %width Border color %bocolor %fill color %fcolor %round\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param w to w ,eg: 300 (min 0, max 320, default 300)\n * @param h to h ,eg: 200 (min 0, max 240, default 200)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n * @param round to round ,eg: lcdDisplay.RectangleRound.NoneRound\n */\nfunction lcdDrawRectangle(num: number, x: number, y: number, w: number, h: number, width: number, bocolor: number, fill: DrawType, fcolor: number, round: RectangleRound) {\n    updateRect(num, x, y, w, h, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor, round === RectangleRound.IsRound ? 1 : 0);\n}\n\n/**\n * Original block \"draw circle number %num center x: %x y: %y radius %r line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 160 (min 0, max 320, default 160)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param r to r ,eg: 120 (min 0, max 120, default 120)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawCircle(num: number, x: number, y: number, r: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateCircle(num, x, y, r, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw triangle number %num x1: %x1 y1: %y1 x2: %x2 y2: %y2 x3: %x3 y3: %y3 line width %width Border color %bocolor %fill color %fcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x1 to x1 ,eg: 160 (min 0, max 320, default 160)\n * @param y1 to y1 ,eg: 0 (min 0, max 240, default 0)\n * @param x2 to x2 ,eg: 0 (min 0, max 320, default 0)\n * @param y2 to y2 ,eg: 240 (min 0, max 240, default 240)\n * @param x3 to x3 ,eg: 320 (min 0, max 320, default 320)\n * @param y3 to y3 ,eg: 240 (min 0, max 240, default 240)\n * @param width to width ,eg: 5\n * @param bocolor to bocolor ,eg: 0xFF0000\n * @param fill to fill ,eg: DrawType.Fill\n * @param fcolor to fcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawTriangle(num: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, width: number, bocolor: number, fill: DrawType, fcolor: number) {\n    updateTriangle(num, x1, y1, x2, y2, x3, y3, width, bocolor, fill === DrawType.Fill ? 1 : 0, fcolor);\n}\n\n/**\n * Original block \"draw slider number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawSlider(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateSlider(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw bar number %num position x: %x y: %y width %w height %h color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 80 (min 0, max 320, default 80)\n * @param y to y ,eg: 120 (min 0, max 240, default 120)\n * @param w to w ,eg: 200 (min 0, max 320, default 200)\n * @param h to h ,eg: 20 (min 0, max 240, default 20)\n * @param color to color ,eg: 0x007FFF\n */\nfunction lcdDrawBar(num: number, x: number, y: number, w: number, h: number, color: number) {\n    updateBar(num, x, y, w, h, color);\n}\n\n/**\n * Original block \"draw compass number %num position x: %x y: %y radius %r\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n */\nfunction lcdDrawCompass(num: number, x: number, y: number, r: number) {\n    updateCompass(num, x, y, r);\n}\n\n/**\n * Original block \"draw gauge number %num position x: %x y: %y radius %r start of scale %start End of scale %end Pointer color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 50 (min 0, max 320, default 50)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 360 (min 0, max 360, default 360)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawGauge(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateGauge(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"draw lineMeter number %num position x: %x y: %y radius %r start of scale %start End of scale %end Data color %color Dial color %dcolor\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param x to x ,eg: 0 (min 0, max 320, default 0)\n * @param y to y ,eg: 0 (min 0, max 240, default 0)\n * @param r to r ,eg: 240 (min 0, max 320, default 240)\n * @param start to start ,eg: 0 (min 0, max 360, default 0)\n * @param end to end ,eg: 100 (min 0, max 360, default 100)\n * @param color to color ,eg: 0x000000\n * @param dcolor to dcolor ,eg: 0xFFFFFF\n */\nfunction lcdDrawLineMeter(num: number, x: number, y: number, r: number, start: number, end: number, color: number, dcolor: number) {\n    updateLineMeter(num, x, y, r, start, end, color, dcolor);\n}\n\n/**\n * Original block \"set %type=LCDWidgetCategoryOne_conv widget number %num data %data\"\n * @param type to type ,eg: LCDWidgetCategoryOne.Slider\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param data to data ,eg: 80\n */\nfunction lcdSetWidgetData(type: number, num: number, data: number) {\n    switch (type) {\n        case LCDWidgetCategoryOne.Slider:\n            setSliderValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Bar:\n            setBarValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.Compass:\n            setCompassScale(num, (data / 360) * 3600);\n            break;\n        case LCDWidgetCategoryOne.Gauge:\n            setGaugeValue(num, data);\n            break;\n        case LCDWidgetCategoryOne.LineMeter:\n            setMeterValue(num, data);\n            break;\n        default:\n            break;\n    }\n}\n\n/**\n * Original block \"draw chart number %num X-axis %xaxis Y-axis %yaxis background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan Feb Mar Apr May Jun\"\n * @param yaxis to yaxis ,eg: \"100 80 60 40 20 0\"\n * @param color to color ,eg: 0xFFFFFF\n * @param styles to styles ,eg: ChartStyles.LineChart\n */\nfunction lcdDrawChart(num: number, xaxis: string, yaxis: string, color: number, styles: ChartStyles) {\n    chartID = num;\n    axisListX = xaxis.split(\" \");\n    axisListY = yaxis.split(\" \");\n    axisListX.forEach((value, index) => { axisYData.push(0) });\n    dataFactor = Math.abs((parseInt(axisListY[0]) - parseInt(axisListY[axisListY.length - 1])) / 100);\n    updateChart(chartID, color, styles);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 0, axisListX);\n    basic.pause(100);\n    setChartAxisTexts(chartID, 1, axisListY);\n}\n\n/**\n * Original block \"Set chart data number %num color %color\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0xFF0000\n */\nfunction lcdAddChartData(num: number, color: number) {\n    seriesData[num] = axisYData;\n    updateChartSeries(chartID, num, color);\n    addChartSeriesData(chartID, num, seriesData[num], axisListX.length)\n}\n\n/**\n * Original block \"set chart data number %num X-axis %xaxis data %data\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param xaxis to xaxis ,eg: \"Jan\"\n * @param data to data ,eg: 80\n */\nfunction lcdSetChartData(num: number, xaxis: string, data: number) {\n    let index = axisListX.indexOf(xaxis);\n    if (data < parseInt(axisListY[axisListY.length - 1]) || data > parseInt(axisListY[0]))\n        return\n    if (index !== -1) {\n        updateChartPoint(chartID, num, index, Math.round((data - parseInt(axisListY[axisListY.length - 1])) / dataFactor));\n        // seriesData[num][index] = Math.round(data / 10);\n    }\n}\n\n/**\n * Original block \"update chart number %num background color %color styles %styles\"\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n * @param color to color ,eg: 0x007FFF\n * @param styles to styles ,eg: lcdDisplay.ChartStyles.BarChart\n */\nfunction lcdUpdateChart(num: number, color: number, styles: ChartStyles) {\n    updateChart(num, color, styles);\n}\n\n/**\n * Original block \"delete %type=LCDWidgetCategoryTwo_conv number %num\"\n * @param type to type ,eg: LCDWidgetCategoryTwo.Text\n * @param num to num ,eg: 1 (min 1, max 255, default 1)\n */\nfunction lcdDeleteWidget(type: number, num: number) {\n    switch (type) {\n        case LCDWidgetCategoryTwo.Slider:\n            deleteSlider(num);\n            break;\n        case LCDWidgetCategoryTwo.Bar:\n            deleteBar(num);\n            break;\n        case LCDWidgetCategoryTwo.Compass:\n            deleteCompass(num);\n            break;\n        case LCDWidgetCategoryTwo.Gauge:\n            deleteGauge(num);\n            break;\n        case LCDWidgetCategoryTwo.LineMeter:\n            deleteLineMeter(num);\n            break;\n        case LCDWidgetCategoryTwo.Chart:\n            deleteChart(num);\n            break;\n        case LCDWidgetCategoryTwo.Text:\n            deleteString(num);\n            break;\n        case LCDWidgetCategoryTwo.Line:\n            deleteLine(num);\n            break;\n        case LCDWidgetCategoryTwo.Rectangle:\n            deleteRect(num);\n            break;\n        case LCDWidgetCategoryTwo.Circle:\n            deleteCircle(num);\n            break;\n        case LCDWidgetCategoryTwo.Triangle:\n            deleteTriangle(num);\n            break;\n        case LCDWidgetCategoryTwo.Icon:\n            deleteIcon(num);\n            break;\n        case LCDWidgetCategoryTwo.Gif:\n            deleteGif(num);\n        default:\n            break;\n    }\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryOne_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryOne number\n */\nfunction getWidgetCategoryOne(item: LCDWidgetCategoryOne): number {\n    return item as number;\n}\n\n/**\n * Original blockId \"LCDWidgetCategoryTwo_conv\" and block \"%item\"\n * return the corresponding LCDWidgetCategoryTwo number\n */\nfunction getLCDWidgetCategoryTwo(item: LCDWidgetCategoryTwo): number {\n    return item as number;\n}\n\nfunction cleanScreen() {\n    let cmd = creatCommand(0x1D, 0x04);\n    writeCommand(cmd, 4);\n    basic.pause(1500);\n}\n\nfunction setBackgroundColor(color: number) {\n    let cmd = creatCommand(CMD_SET_BACKGROUND_COLOR, CMD_SET_LEN);\n    cmd = cmd.concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_SET_LEN);\n    basic.pause(300);\n}\n\nfunction setBackgroundImg(location: number, str: string) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_SET_BACKGROUND_IMG, len + 5);\n    cmd = cmd.concat([location]);\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 5);\n}\n\nfunction drawString(x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TEXT), fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction updateString(id: number, x: number, y: number, str: string, fontSize: number, color: number) {\n    let len = str.length > 242 ? 242 : str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_TEXT, len + 13);\n    cmd = cmd.concat([id, fontSize]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 13);\n}\n\nfunction deleteString(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TEXT, id])\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.textHead, id);\n}\n\nfunction drawLcdTime(x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    drawString(x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction updateLcdTime(id: number, x: number, y: number, hour: number, min: number, sec: number, fontSize: number, color: number) {\n    updateString(id, x, y, `${hour < 10 ? \"0\" + hour : \"\" + hour}:${min < 10 ? \"0\" + min : \"\" + min}:${sec < 10 ? \"0\" + sec : \"\" + sec}`, fontSize, color);\n}\n\nfunction drawIcon(x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_ICON_INTERNAL)]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction setAngleIcon(id: number, angle: number) {\n    let cmd = creatCommand(CMD_SET_ANGLE_OBJ, CMD_SET_ANGLE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]).concat(data16Tobyte(angle));\n    writeCommand(cmd, CMD_SET_ANGLE_OBJ_LEN);\n}\n\nfunction updateIcon(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_ICON_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteIcon(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_ICON_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.iconHead, id);\n}\n\nfunction drawGif(x: number, y: number, str: string, zoom: number): number {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    let id = getID(CMD_OF_DRAW_GIF_EXTERNAL);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n    return id;\n}\n\nfunction updateGif(id: number, x: number, y: number, str: string, zoom: number) {\n    let len = str.length;\n    let cmd = creatCommand(CMD_OF_DRAW_GIF_EXTERNAL, len + 11);\n    cmd = cmd.concat([id]).concat(data16Tobyte(zoom)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    str.split(\"\").forEach((value, index) => { cmd.push(value.charCodeAt(0)) });\n    writeCommand(cmd, len + 11);\n}\n\nfunction deleteGif(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GIF_INTERNAL, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gifHead, id);\n}\n\nfunction drawLine(x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE), width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n}\n\nfunction updateLine(id: number, x0: number, y0: number, x1: number, y1: number, width: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE, CMD_DRAW_LINE_LEN);\n    cmd = cmd.concat([id, width]).concat(data24Tobyte(color)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1));\n    writeCommand(cmd, CMD_DRAW_LINE_LEN);\n    basic.pause(10);\n}\n\nfunction deleteLine(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineHead, id);\n}\n\nfunction drawRect(x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_RECT), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction updateRect(id: number, x: number, y: number, w: number, h: number, bw: number, boColor: number, fill: number, fillColor: number, rounded: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_RECT, CMD_OF_DRAW_RECT_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat([rounded]).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_RECT_LEN);\n}\n\nfunction deleteRect(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_RECT, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.rectHead, id);\n}\n\nfunction drawCircle(x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_CIRCLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction updateCircle(id: number, x: number, y: number, r: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_CIRCLE, CMD_OF_DRAW_CIRCLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(r)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_CIRCLE_LEN);\n}\n\nfunction deleteCircle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_CIRCLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.circleHead, id);\n}\n\nfunction drawTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_TRIANGLE), bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction updateTriangle(id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, bw: number, boColor: number, fill: number, fillColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_TRIANGLE, CMD_OF_DRAW_TRIANGLE_LEN);\n    cmd = cmd.concat([id, bw]).concat(data24Tobyte(boColor)).concat([fill]).concat(data24Tobyte(fillColor)).concat(data16Tobyte(x0)).concat(data16Tobyte(y0)).concat(data16Tobyte(x1)).concat(data16Tobyte(y1)).concat(data16Tobyte(x2)).concat(data16Tobyte(y2));\n    writeCommand(cmd, CMD_OF_DRAW_TRIANGLE_LEN);\n}\n\nfunction deleteTriangle(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_TRIANGLE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.triangleHead, id);\n}\n\nfunction creatSlider(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_SLIDER)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction updateSlider(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER, CMD_OF_DRAW_SLIDER_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_SLIDER_LEN);\n}\n\nfunction setSliderValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SLIDER_VALUE, CMD_SET_SLIDER_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_SLIDER_VALUE_LEN);\n}\n\nfunction deleteSlider(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_SLIDER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.sliderHead, id);\n}\n\nfunction creatBar(x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_BAR)]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction updateBar(id: number, x: number, y: number, w: number, h: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR, CMD_OF_DRAW_BAR_LEN);\n    cmd = cmd.concat([id]).concat(data24Tobyte(color)).concat(data16Tobyte(x)).concat(data16Tobyte(y)).concat(data16Tobyte(w)).concat(data16Tobyte(h));\n    writeCommand(cmd, CMD_OF_DRAW_BAR_LEN);\n}\n\nfunction setBarValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_BAR_VALUE, CMD_SET_BAR_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_BAR_VALUE_LEN);\n}\n\nfunction deleteBar(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_BAR, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.barHead, id);\n}\n\nfunction creatCompass(x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_COMPASS)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction updateCompass(id: number, x: number, y: number, diameter: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS, CMD_DRAW_COMPASS_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_DRAW_COMPASS_LEN);\n}\n\nfunction setCompassScale(id: number, scale: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_COMPASS_VALUE, CMD_SET_COMPASS_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(scale));\n    writeCommand(cmd, CMD_SET_COMPASS_VALUE_LEN);\n}\n\nfunction deleteCompass(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_COMPASS, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.compassHead, id);\n}\n\nfunction creatGauge(x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_GAUGE)]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction updateGauge(id: number, x: number, y: number, diameter: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE, CMD_OF_DRAW_GAUGE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(diameter)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_GAUGE_LEN);\n}\n\nfunction setGaugeValue(id: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_GAUGE_VALUE, CMD_SET_GAUGE_VALUE_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_GAUGE_VALUE_LEN);\n}\n\nfunction deleteGauge(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_GAUGE, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.gaugeHead, id);\n}\n\nfunction creatLineMeter(x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([getID(CMD_OF_DRAW_LINE_METER)]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction updateLineMeter(id: number, x: number, y: number, size: number, start: number, end: number, pointerColor: number, bgColor: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER, CMD_OF_DRAW_LINE_METER_LEN);\n    cmd = cmd.concat([id]).concat(data16Tobyte(size)).concat(data16Tobyte(start)).concat(data16Tobyte(end)).concat(data24Tobyte(pointerColor)).concat(data24Tobyte(bgColor)).concat(data16Tobyte(x)).concat(data16Tobyte(y));\n    writeCommand(cmd, CMD_OF_DRAW_LINE_METER_LEN);\n}\n\nfunction setTopLineMeter(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n}\n\nfunction deleteLineMeter(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_METER, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineMeterHead, id);\n}\n\nfunction creatChart(strX: string[], strY: string[], bgColor: number, type: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    let id = getID(CMD_OF_DRAW_LINE_CHART);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n    basic.pause(100);\n    setChartAxisTexts(id, 0, strX);\n    basic.pause(100);\n    setChartAxisTexts(id, 1, strY);\n    return id;\n}\n\nfunction updateChart(id: number, bgColor: number, type: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART, CMD_DRAW_CHART_LEN);\n    cmd = cmd.concat([id, type]).concat(data24Tobyte(bgColor));\n    writeCommand(cmd, CMD_DRAW_CHART_LEN);\n}\n\nfunction creatChartSeries(chartId: number, color: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    let serieId = getID(CMD_OF_DRAW_SERIE);\n    cmd = cmd.concat([serieId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n    return serieId;\n}\n\nfunction updateChartSeries(chartId: number, seriesId: number, color: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE, CMD_DRAW_SERIE_LEN);\n    cmd = cmd.concat([seriesId, chartId]).concat(data24Tobyte(color));\n    writeCommand(cmd, CMD_DRAW_SERIE_LEN);\n}\n\nfunction setChartAxisTexts(chartId: number, axis: number, text: string[]) {\n    let len = text.length - 1;\n    text.forEach((value, index) => { len = len + value.length });\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_CHART_TEXT, len + 6);\n    cmd = cmd.concat([chartId, axis]);\n    for (let i = 0; i < text.length; i++) {\n        text[i].split(\"\").forEach((value, index) => {\n            cmd.push(value.charCodeAt(0))\n        })\n        if (i != text.length - 1) {\n            cmd.push(0x0A); // \"\\n\"\n        }\n    }\n    writeCommand(cmd, len + 6);\n}\n\nfunction updateChartPoint(chartId: number, seriesId: number, pointNum: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, 10);\n    cmd = cmd.concat([chartId, seriesId, 1, pointNum]).concat(data16Tobyte(value));\n    writeCommand(cmd, 10);\n}\n\nfunction addChartSeriesData(chartId: number, seriesId: number, point: number[], len: number): number {\n    let cmd = creatCommand(CMD_OF_DRAW_SERIE_DATA, len * 2 + 8);\n    cmd = cmd.concat([chartId, seriesId, 0, 0]);\n    point.forEach((value, index) => { cmd = cmd.concat(data16Tobyte(value)) });\n    writeCommand(cmd, len * 2 + 8);\n    return 1;\n}\n\nfunction setTopChart(id: number) {\n    let cmd = creatCommand(CMD_SET_TOP_OBJ, CMD_SET_TOP_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_SET_TOP_OBJ_LEN);\n}\n\nfunction deleteChart(id: number) {\n    let cmd = creatCommand(CMD_DELETE_OBJ, CMD_DELETE_OBJ_LEN);\n    cmd = cmd.concat([CMD_OF_DRAW_LINE_CHART, id]);\n    writeCommand(cmd, CMD_DELETE_OBJ_LEN);\n    deleteNodeByID(list.lineChartHead, id);\n}\n\nfunction setMeterValue(lineMeterId: number, value: number) {\n    let cmd = creatCommand(CMD_OF_DRAW_LINE_METER_VALUE, CMD_SET_LINE_METER_VALUE_LEN);\n    cmd = cmd.concat([lineMeterId]).concat(data16Tobyte(value));\n    writeCommand(cmd, CMD_SET_LINE_METER_VALUE_LEN);\n}\n\n/********************************************************************************************************************/\nfunction creatList() {\n    list.lineChartHead = new LinkedList();\n    list.seriesHead = new LinkedList();\n    list.compassHead = new LinkedList();\n    list.textHead = new LinkedList();\n    list.gaugeHead = new LinkedList();\n    list.lineHead = new LinkedList();\n    list.rectHead = new LinkedList();\n    list.circleHead = new LinkedList();\n    list.triangleHead = new LinkedList();\n    list.lineMeterHead = new LinkedList();\n    list.barHead = new LinkedList();\n    list.sliderHead = new LinkedList();\n    list.iconHead = new LinkedList();\n    list.gifHead = new LinkedList();\n}\n\nfunction getID(type: number): number {\n    let id = 0;\n    switch (type) {\n        case CMD_OF_DRAW_LINE_CHART:\n            id = getNewID(list.lineChartHead);\n            break;\n        case CMD_OF_DRAW_SERIE:\n            id = getNewID(list.seriesHead);\n            break;\n        case CMD_OF_DRAW_COMPASS:\n            id = getNewID(list.compassHead);\n            break;\n        case CMD_OF_DRAW_TEXT:\n            id = getNewID(list.textHead);\n            break;\n        case CMD_OF_DRAW_GAUGE:\n            id = getNewID(list.gaugeHead);\n            break;\n        case CMD_OF_DRAW_LINE:\n            id = getNewID(list.lineHead);\n            break;\n        case CMD_OF_DRAW_RECT:\n            id = getNewID(list.rectHead);\n            break;\n        case CMD_OF_DRAW_TRIANGLE:\n            id = getNewID(list.triangleHead);\n            break;\n        case CMD_OF_DRAW_CIRCLE:\n            id = getNewID(list.circleHead);\n            break;\n        case CMD_OF_DRAW_LINE_METER:\n            id = getNewID(list.lineMeterHead);\n            break;\n        case CMD_OF_DRAW_BAR:\n            id = getNewID(list.barHead);\n            break;\n        case CMD_OF_DRAW_SLIDER:\n            id = getNewID(list.sliderHead);\n            break;\n        case CMD_OF_DRAW_ICON_INTERNAL:\n            id = getNewID(list.iconHead);\n            break;\n        case CMD_OF_DRAW_GIF_INTERNAL:\n            id = getNewID(list.gifHead);\n            break;\n        default:\n            break;\n    }\n    return id;\n}\n\nfunction getNewID(linkList: LinkedList): number {\n    linkList.append();\n    return linkList.head.id;\n}\n\nfunction deleteNodeByID(linkList: LinkedList, id: number) {\n    linkList.removeId(id);\n}\n\nfunction data16Tobyte(data: number): number[] {\n    return [(data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction data24Tobyte(data: number): number[] {\n    return [(data >> 16) & 0xFF, (data >> 8) & 0xFF, data & 0xFF];\n}\n\nfunction colorToCustom(color: number): number {\n    switch (color) {\n        case 0x999999:\n            return 0x696969;\n        case 0x7f00ff:\n            return 0x800080;\n        default:\n            return color;\n    }\n}\n\nfunction creatCommand(cmd: number, len: number): number[] {\n    return [CMD_HEADER_HIGH, CMD_HEADER_LOW, len - CMDLEN_OF_HEAD_LEN, cmd];\n}\n\nfunction writeCommand(data: number[], len: number) {\n    // serial.writeNumbers(data);\n    if (protocol == Protocol.IIC) {\n        let remain = len;\n        let i = 0;\n        while (remain > 0) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? 32 : remain;\n            if (remain > IIC_MAX_TRANSFER_SIZE) {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), true);\n            } else {\n                pins.i2cWriteBuffer(address, pins.createBufferFromArray(data.slice(i * IIC_MAX_TRANSFER_SIZE, i * IIC_MAX_TRANSFER_SIZE + currentTransferSize)), false);\n            }\n            remain = remain - currentTransferSize;\n            i = i + 1;\n        }\n    } else {\n    }\n}\n\nfunction readACK(length: number): Buffer {\n    if (protocol == Protocol.IIC) {\n        let remain = length;\n        let buf: Buffer = pins.createBuffer(0);\n        while (remain) {\n            let currentTransferSize = (remain > IIC_MAX_TRANSFER_SIZE) ? IIC_MAX_TRANSFER_SIZE : remain;\n            buf = buf.concat(pins.i2cReadBuffer(address, currentTransferSize));\n            remain = remain - currentTransferSize;\n        }\n        return buf;\n    } else {\n        let buf: Buffer = pins.createBuffer(0);\n        return buf;\n    }\n}\n\n// --------------------------------------\n// End of code from DFRobot lcdDisplay extension\n// --------------------------------------\n\n\n//% blockNamespace=storybrain\nclass StoryMessage {\n    _sender: string;\n    _message: string;\n\n    constructor(sender: string, message: string) {\n        this._sender = sender;\n        this._message = message;\n    }\n\n    //% blockCombine\n    get text() { return this._message }\n\n    //% blockCombine\n    get sender() { return this._sender }\n}\n\n//% color=\"#402504\" icon=\"\\uf02d\" block=\"Story brain\"\nnamespace storybrain {\n\n    const ROOM_ELEMENT_IMAGE_CODE_UNKNOWN: string = 'def';\n\n    /**\n     * Information about an image for an escape room element.\n     */\n    class RoomElementImage {\n        code: string;\n        private _filename: string;\n\n        /**\n         * Constructs the image using \n         */\n        constructor(code: string = null) {\n            if (code === null) {\n                this.code = ROOM_ELEMENT_IMAGE_CODE_UNKNOWN;\n            } else {\n                this.code = code;\n            }\n            this._filename = this.code.toLowerCase();\n        }\n\n        public getFilePath(fresh: boolean = true) {\n            if (fresh) {\n                return \"/escape room icon/\" + this._filename + \"_mid.png\";\n            } else {\n                return \"/escape room icon/\" + this._filename + \"_dark.png\";\n            }\n\n        }\n    }\n\n    class RoomElement {\n        name: string;\n        lastCheckInTime: number;  // Millis since power on.\n        image: RoomElementImage;\n        fresh: boolean;\n        changedState: boolean;\n\n        constructor(name: string, imageCode: string = null) {\n            this.name = name;\n            this.image = new RoomElementImage(imageCode);\n            this.fresh = true;\n            this.changedState = true;\n            this.checkIn();\n        }\n\n        checkIn() {\n            this.lastCheckInTime = control.millis();\n            if (!this.fresh) {\n                this.fresh = true;\n                this.changedState = true;\n            }\n        }\n\n        // Call after updating widget on screen.\n        update() {\n            this.changedState = false;\n            if (this.fresh) {\n                if (control.millis() - this.lastCheckInTime > 8000) {\n                    this.fresh = false;\n                    this.changedState = true;\n                }\n            }\n        }\n    }\n\n    function getIconXPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2;\n            case 2: return 2;\n            case 3: return 2;\n            case 4: return 2;\n            case 5: return 2 + 45 * 1;\n            case 6: return 2 + 45 * 2;\n            case 7: return 2 + 45 * 3;\n            case 8: return 2 + 45 * 4;\n            case 9: return 2 + 45 * 5;\n            case 10: return 2 + 45 * 6;\n            case 11: return 2 + 45 * 6;\n            case 12: return 2 + 45 * 6;\n            case 13: return 2 + 45 * 6;\n            case 14: return 2 + 45 * 6;\n            case 15: return 2 + 45 * 5;\n            case 16: return 2 + 45 * 4;\n            case 17: return 2 + 45 * 3;\n            case 18: return 2 + 45 * 2;\n            case 19: return 2 + 45 * 1;\n            default: return 0;\n        }\n    }\n\n    function getIconYPlacement(elementOrder: number) {\n        switch (elementOrder) {\n            case 0: return 2;\n            case 1: return 2 + 47 * 1;\n            case 2: return 2 + 47 * 2;\n            case 3: return 2 + 47 * 3;\n            case 4: return 2 + 47 * 4;\n            case 5: return 2 + 47 * 4;\n            case 6: return 2 + 47 * 4;\n            case 7: return 2 + 47 * 4;\n            case 8: return 2 + 47 * 4;\n            case 9: return 2 + 47 * 4;\n            case 10: return 2 + 47 * 4;\n            case 11: return 2 + 47 * 3;\n            case 12: return 2 + 47 * 2;\n            case 13: return 2 + 47 * 1;\n            case 14: return 2;\n            case 15: return 2;\n            case 16: return 2;\n            case 17: return 2;\n            case 18: return 2;\n            case 19: return 2;\n            default: return 0;\n        }\n    }\n\n    let roomName: string = 'UNNAMED'\n    let brainInitialized: boolean = false;\n    let startInitializationTime: number;\n    let statusText: string = '';\n    let statusColour: number = lcdGetRgbColor(255, 0, 0);\n    let updatingScreen: boolean = false;\n    const registeredElements: RoomElement[] = [];\n    const uncheckedStoryMessages: StoryMessage[] = [];\n\n    /**\n     * Set up the story brain for the escape room.\n     * @param room the unique name for the room (use a maximum of 4 regular letters)\n     * @param radioGroup the radio group for the room, unique in the vicinity\n    */\n    //% block=\"initialise brain with room name $room and radio group $radioGroup\"\n    //% blockGap=50\n    //% weight=100\n    //% room.defl=\"room\"\n    //% radioGroup.min=0 radioGroup.max=255 radioGroup.defl=20\n    export function initialiseBrain(room: string, radioGroup: number) {\n        initialise(room, radioGroup);\n    }\n\n    /**\n     * Returns true if there any unchecked messages available to grab.\n    */\n    //% block=\"unchecked messages available\"\n    //% weight=52\n    export function uncheckedMessagesAvailable(): boolean {\n        return (uncheckedStoryMessages.length > 0);\n    }\n\n    /**\n     * Grab the next unchecked message, removing it from the inbox.\n    */\n    //% block=\"grab next unchecked message\"\n    //% weight=51\n    //% blockSetVariable=storymessage\n    export function grabNextUncheckedMessage(): StoryMessage {\n        while (updatingScreen) {\n            basic.pause(1);\n        }\n        if (uncheckedStoryMessages.length > 0) {\n            return uncheckedStoryMessages.pop();\n        }\n        return new StoryMessage('no message', 'no message');\n    }\n\n    /**\n     * Use the story brain's colour screen to display a short status message.\n     */\n    //% block=\"Display status $text in $colour\"\n    //% colour.shadow=\"colorNumberPicker\"\n    //% advanced=true\n    //% weight=10\n    export function setStatus(text: string, colour: number) {\n        statusText = text;\n        statusColour = colour;\n    }\n\n    /**\n     * Clear status message on the story brain's colour screen.\n     */\n    //% block=\"Clear status\"\n    //% advanced=true\n    //% weight=9\n    export function clearStatus() {\n        statusText = '';\n    }\n\n    // Ensures that an element is kept up to date in the registeredElements array.\n    function registerElement(name: string, imageCode: string = null) {\n        for (let element of registeredElements) {\n            if (element.name.toUpperCase() === name) {\n                element.checkIn();\n                return;\n            }\n        }\n        registeredElements.push(new RoomElement(name, imageCode));\n    }\n\n    // Capture and process all radio messages coming in as strings.\n    /*\n    / Check-in messages are formatted as follows:   [room name]*[element name]\n    / Check-in messages can also be formatted to give an image:   [room name]*[element name]*I*[image code]\n    / Trigger messages are formatted as follows:   [room name]*[element name]*[message]\n    /\n    / room name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all escape rooms in the vicinity.\n    / element name is a string of no more than 4 characters. Asterisk not allowed. Must be unique among all elements in this escape room.\n    / message is a string of no more than 9 characters. Asterisk not allowed.\n    /\n    / Case is always ignored when comparing, so names and IDs must be unique ignoring case.\n    */\n    radio.onReceivedString(function (receivedString: string) {\n        if (!brainInitialized) {\n            return;\n        }\n\n        let messageParts: string[] = receivedString.split('*');\n\n        // If the received string could not be split, ignore it.\n        if (messageParts.length <= 1) {\n            return;\n        }\n        // If the room name doesn't match, ignore it.\n        if (messageParts[0].toUpperCase() != roomName.toUpperCase()) {\n            return;\n        }\n        // Process a basic check-in string.\n        if (messageParts.length == 2) {\n            registerElement(messageParts[1]);\n            return;\n        }\n        // Process an advanced check-in string.\n        if (messageParts.length == 4) {\n            registerElement(messageParts[1], messageParts[3]);\n            return;\n        }\n        registerElement(messageParts[1]);\n        // Process a true story message, but ignore if there is already an unchecked message from that element.\n        for (let message of uncheckedStoryMessages) {\n            if (message.sender.toUpperCase() == messageParts[1].toUpperCase()) {\n                return;\n            }\n        }\n        uncheckedStoryMessages.unshift(new StoryMessage(messageParts[1], messageParts[2]));\n    });\n\n    // Sets up the story brain with a room name and radio group unique in the vicinity.\n    // Must be called before other functions will work.\n    function initialise(room: string, radioGroup: number) {\n        roomName = room;\n        radio.setGroup(radioGroup);\n        lcdInitIIC();\n        lcdClearAll();\n        lcdSetBgcolor(lcdGetRgbColor(0, 0, 0));\n        lcdDisplayImage(250, '/escape room icon/story_brain.png', 123, 71, 255);\n        lcdDisplayText(roomName, 251, 123, 143, FontSize.Small, lcdGetRgbColor(255, 255, 255));\n        startInitializationTime = control.millis();\n    }\n\n    // Test code\n    /*\n    registerElement('box', 'box');\n    registerElement('btns', 'press');\n    registerElement('hmmm');\n    registerElement('tes2');\n    registerElement('tes3');\n    registerElement('tes4');\n    registerElement('tes5');\n    registerElement('tes6');\n    registerElement('tes7');\n    registerElement('tes8');\n    registerElement('tes9');\n    registerElement('tes10');\n    registerElement('tes11');\n    registerElement('tes12');\n    registerElement('tes13');\n    registerElement('tes14');\n    registerElement('tes15');\n    registerElement('tes16');\n    registerElement('tes17');\n    uncheckedStoryMessages.unshift(new StoryMessage('box', 'hello'));\n    uncheckedStoryMessages.unshift(new StoryMessage('btns', 'yo'));\n    uncheckedStoryMessages.unshift(new StoryMessage('hmmm', 'hi!'));\n    */\n\n    basic.forever(function () {\n        basic.pause(200);\n\n        if (!brainInitialized) {\n            if (control.millis() - startInitializationTime > 2000) {\n                brainInitialized = true;\n            } else {\n                return;\n            }\n        }\n\n        // Update elements on screen.\n        updatingScreen = true;\n        for (let i = 0; i < registeredElements.length; i++) {\n            let widgetOrder = (i + 1) * 3;\n            if (registeredElements[i].changedState) {\n                let path;\n                let textColour;\n                if (registeredElements[i].fresh) {\n                    path = registeredElements[i].image.getFilePath();\n                    textColour = lcdGetRgbColor(255, 255, 255)\n                } else {\n                    path = registeredElements[i].image.getFilePath(false);\n                    textColour = lcdGetRgbColor(128, 128, 128)\n                }\n                lcdDisplayImage(widgetOrder, path, getIconXPlacement(i), getIconYPlacement(i), 255);\n                basic.pause(5);  // Pause added to avoid overload in communication with screen.\n                lcdDisplayText(registeredElements[i].name, widgetOrder + 1, getIconXPlacement(i) + 6, getIconYPlacement(i) + 46 - 2 - 18, FontSize.Small, textColour);\n                basic.pause(5);  // Pause added to avoid overload in communication with screen.\n            }\n            // Draw a line if there is an unchecked message from that element.\n            let lineToDraw = false;\n            for (let message of uncheckedStoryMessages) {\n                if (message.sender.toUpperCase() == registeredElements[i].name.toUpperCase()) {\n                    lineToDraw = true;\n                }\n            }\n            if (lineToDraw) {\n                lcdDrawLine(widgetOrder + 2, getIconXPlacement(i) + 23, getIconYPlacement(i) + 23, 159, 119, 5, lcdGetRgbColor(0, 255, 0));\n            } else {\n                lcdDeleteWidget(LCDWidgetCategoryTwo.Line, widgetOrder + 2);\n            }\n            registeredElements[i].update();\n            // Custom status display.\n            if (statusText.length > 0) {\n                lcdDisplayText(statusText, 200, 72, 166, FontSize.Small, statusColour);\n            } else {\n                lcdDeleteWidget(LCDWidgetCategoryTwo.Text, 200);\n            }\n        }\n        updatingScreen = false;\n    })\n\n}\n\n// Test code.\nstorybrain.initialiseBrain('Mars', 42);\n\nbasic.forever(function () {\n    pause(6000);\n    while (storybrain.uncheckedMessagesAvailable()) {\n        let myMessage: StoryMessage = storybrain.grabNextUncheckedMessage();\n        basic.showString(myMessage.text, 100);\n    }\n    if (storybrain.uncheckedMessagesAvailable()) {\n        storybrain.setStatus('Messages still available.', 254);\n    }\n})\n\n","README.md":"","pxt.json":"{\n    \"name\": \"story brain experiments\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1762116757692}